<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>动态延时任务总结 | xyhao的博客</title><meta name="author" content="xyhao"><meta name="copyright" content="xyhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="之所以要用延时任务就是为了将更新数据库的时间延时到下一个文件片更新之后，然后将延时的时间继续向后延，避免反复请求数据库。个人理解这是一种动态延时任务。">
<meta property="og:type" content="article">
<meta property="og:title" content="动态延时任务总结">
<meta property="og:url" content="http://juziblog.space/2024/10/02/2024-10-02-%E5%8A%A8%E6%80%81%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="xyhao的博客">
<meta property="og:description" content="之所以要用延时任务就是为了将更新数据库的时间延时到下一个文件片更新之后，然后将延时的时间继续向后延，避免反复请求数据库。个人理解这是一种动态延时任务。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/2024-10-02-fileUpLoad.png">
<meta property="article:published_time" content="2024-10-02T00:00:00.000Z">
<meta property="article:modified_time" content="2025-06-15T11:52:37.414Z">
<meta property="article:author" content="xyhao">
<meta property="article:tag" content="任务调度">
<meta property="article:tag" content="延时任务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/2024-10-02-fileUpLoad.png"><link rel="shortcut icon" href="https://gitee.com/xyhaooo/picrepo/raw/master/favicon.png"><link rel="canonical" href="http://juziblog.space/2024/10/02/2024-10-02-%E5%8A%A8%E6%80%81%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//unpkg.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"已经过了","messageNext":"天自上次更新，文章内容可能已过时。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '动态延时任务总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-15 11:52:37'
}</script><meta name="referrer" content="no-referrer" /><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/transpancy.css"><script defer src="https://cloud.umami.is/script.js" data-website-id="5b9ef408-bff2-4b30-8d1e-28cb3c95721a"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="xyhao的博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(https://pic.imgdb.cn/item/672c4d1ad29ded1a8cbde4f5.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/xyhaooo/picrepo/raw/master/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/2024-10-02-fileUpLoad.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">xyhao的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">动态延时任务总结</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">动态延时任务总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-02T00:00:00.000Z" title="发表于 2024-10-02 00:00:00">2024-10-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-15T11:52:37.414Z" title="更新于 2025-06-15 11:52:37">2025-06-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>之所以延时任务就是为了将更新数据库的时间延时到下一个文件片更新之后，然后延时任务刷新，避免反复请求数据库。</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>文件上传是一个很古老的业务了，业界在设计的时候都会规划三个功能：秒传、分片上传、断点续传。</p>
<h3 id="MD5密码杂凑算法"><a href="#MD5密码杂凑算法" class="headerlink" title="MD5密码杂凑算法"></a>MD5密码杂凑算法</h3><p>在介绍这三点之前，需要先了解MD5算法。这是一种密码杂凑算法，对于给定的任何输入，都会输出128位固定长度的16进制数字。既然长度固定，就会有重复的风险。国产算法SM3就是MD5的改良版，它优化了加密流程，也将输出的比特数增加到256位。</p>
<p>MD5重复的问题不是本文的重点，因此在接下来的叙述中不会考虑MD5重复的问题。</p>
<p>针对于MD5算法，我们任意输入文件名不同但文件内容相同的文件，都能得到相同的MD5值。这就是秒传的原理。如果数据库中已经存在客户端传过来的MD5值，那就说明以前有人已经上传过这份文件了，只需要新增一条用户和文件的对应关系即可。可以通俗的理解为：MD5值就是文件的身份证。</p>
<h3 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h3><p>很明显，用户和文件之间是多对多的关系。</p>
<p>我思考过两种表结构：</p>
<ol>
<li>只建立用户表和文件表，在文件表里关联用户表主键。</li>
<li>建立用户表、文件表、用户文件关联表。</li>
</ol>
<p>考虑到网盘的场景，文件内容相同的文件虽然文件名不同，但它们实际上还是同一份文件。</p>
<h4 id="采用第一种方案"><a href="#采用第一种方案" class="headerlink" title="采用第一种方案"></a>采用第一种方案</h4><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>MD5不能做主键，放着天然的主键属性不要，得让业务去生成主键。假如说有一个文件<code>程序员的自我修养.txt</code>，A用户上传完成后，在文件表增加一条<br><code>程序员的自我修养.txt-&gt;A</code>的一行数据。B把它更名为<code>自我修养.txt</code>上传，虽然文件名不同，MD5值却是相同的。但是文件表里肯定要再插入一条数据<br><code>自我修养.txt-&gt;B</code>的记录。MD5做主键就会冲突。但是这不是什么要紧的事。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>相比于第二种方案，可以少建一张表，且避免了回表查询。</p>
<h4 id="用第二种方案"><a href="#用第二种方案" class="headerlink" title="用第二种方案"></a>用第二种方案</h4><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ol>
<li>MD5还是不能做主键。在这种方案里，如果文件表用MD5做主键，同一份文件只有一行数据，A对这个文件的文件名做了修改，在B用户看来，文件名是被同步修改的。B用户肯定会觉得碰上鬼打墙了，啥都没干文件名就被改了。</li>
<li><strong>要多建一张表，且会导致回表查询。</strong>查询某个用户上传的全部文件。如果是建立关联表的话，得先查关联表，拿到文件ID列表再去做回表查询。但如果是在文件表加用户字段，只需要查询<br><code>where userID ＝ xxx</code>就可以把用户上传的全部文件查出来。</li>
</ol>
<h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>相比于第一种方案并没有什么优点。</p>
<h3 id="三个功能"><a href="#三个功能" class="headerlink" title="三个功能"></a>三个功能</h3><ul>
<li>秒传：发现数据库里已经存在相同MD5值的文件时，去文件表新增一行数据，判定此次上传完毕。</li>
<li>分片上传：将文件划分为多个子部分，分别上传每个子部分，是断点续传的实现原理。</li>
<li>断点续传：如果上一次上传被中断需要重新上传，不需要从头开始上传，而是从上一次已上传的最新部分开始上传。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然由于场景限制导致MD5这一天然的主键属性不能作为主键，这是产品特性决定的，同一份文件可能在不同用户的视角下名字不一样。但是MD5这个属性可以建立非唯一索引。</p>
<p>总体来看，流程比较简单，但是深究起来其中还是有不少可以挖掘的业务问题。</p>
<h2 id="没上传完怎么办？"><a href="#没上传完怎么办？" class="headerlink" title="没上传完怎么办？"></a>没上传完怎么办？</h2><h3 id="上传后的文件片怎么处理？"><a href="#上传后的文件片怎么处理？" class="headerlink" title="上传后的文件片怎么处理？"></a>上传后的文件片怎么处理？</h3><p>服务端需要将上传的那些文件片按照一定的规则（年-月）保存在临时目录中。出于需要实现断点续传的考虑，临时目录不能立马删掉。得保存一段时间。</p>
<ul>
<li>后续由延时任务将它删除吗？我认为并不需要，临时目录的删除并不需要很高的时间精准度，犯不着用延时任务增加系统复杂度。</li>
<li>那把删除临时目录的任务发送到MQ？也没有必要。在MQ不出现消息积压的情况下，几秒钟内消息就会被消费。破坏了断点续传。</li>
</ul>
<p>我认为最好的办法就是在月初统一删除上一个月的临时目录。比如第一级文件夹是xxxx年，第二级是xx月，里面保存了所有在xx月上传的文件片(<br>当然根据需要也可以精确到天，增加三级目录xx天)<br>。虽然会导致极端场景下断点续传失效（月底的晚上开始上传），但没必要为了极端场景做非常多优化。这些优化本身的成本可能比极端场景发生后的损失还大。技术总是服务于业务。（那我现在写的就是极端场景下恶意上传打垮服务器的解决方案，为什么要考虑它的解决方案？不考虑解决方案我怎么写简历？）</p>
<h3 id="有人恶意攻击怎么办"><a href="#有人恶意攻击怎么办" class="headerlink" title="有人恶意攻击怎么办"></a>有人恶意攻击怎么办</h3><p>前面说到文件片按照一定的规则（年-月）保存在临时目录中，月初才清理。</p>
<p>且文件片只有在全部上传完毕后才会合并，并更新用户已使用空间。</p>
<p>假如现在硬盘资源有限，有人从月初开始攻击服务器，具体表现为上传文件时不上传完。那么这些上传的文件碎片就会白白占据服务器硬盘资源而上传它们的用户的已使用空间却不会增加。久而久之用户上传的文件片已经远远超过他们的额度，服务器硬盘资源会被打垮。怎么解决？</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>每个文件片上传时都去数据库里增加用户已使用空间吗？这会不会给数据库带来压力呢？数据库是整个服务端的最后方的组件，将数据持久化至硬盘，因此数据库本身的QPS完全比不上缓存。所以不能随随便便就请求数据库。</p>
<p>那就引入缓存？</p>
<p>将用户的已使用空间保存在redis里面？那是不是要考虑和数据库的一致性呢？redis虽然本身有备份机制，**<br>但他的备份机制并不能保证完全不丢数据。如果需要保证和数据库的一致性，**那和直接更新数据库没有任何区别，因为这些请求全部是写请求。</p>
<p>还有一个问题。用户上传到一半手动取消上传了，从用户角度考虑，用户肯定不希望在查看已使用空间时看到取消上传的文件还占据着已使用空间。这就带来一个新的问题：<br>服务器视角下的已使用大小是已上传完毕的文件总大小加上未上传完毕的总大小。用户视角下的已使用大小是他已经上传完毕的那些文件的总大小（实际使用中发现百度网盘、夸克网盘等等都是这样做的）。这就需要我们准备两套计算已使用大小的方案。</p>
<p>在用户表里用两个字段分别表示已上传完毕文件总大小以及未上传完毕总大小。前者只在文件片合并和删除文件时更新即可，后者则是每有一个文件片上传都需要更新。</p>
<p>服务器在判断是否超出限额时需要将两者相加。</p>
<p>在 Redis 中记录用户的这两个字段。每个文件片更新时更新未上传完毕总大小。然后保证和数据库的一致性。</p>
<p>但是这样做和直接更新数据库还是没有区别。有多少文件片被上传就要更新多少次数据库。能不能减少更新次数？</p>
<p>注意到即使更新无数次数据库，每一次更新都可以覆盖前一次更新。</p>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>第一次更新是将未上传完大小<code>100M</code>加上这次文件片的大小<code>5M</code>得到<code>105M</code>；第二次更新是将未上传完大小<code>105M</code>加上这次文件片的大小<br><code>5M</code>得到<code>110M</code>。更新了两次数据库。如果在第二次更新时加上<code>5M * 2 = 10M</code>，再把第一次更新删除，也就是<code>100M + 10M = 110M</code>。这样做只更新了一次数据库。</p>
<p>因此考虑引入延时任务,每个文件片上传后，在上一个延时任务执行之前刷新延时任务的执行时间，将它接着向后延。让最后一次更新覆盖之前所有更新，做到只更新一次数据库。</p>
<h3 id="延时任务"><a href="#延时任务" class="headerlink" title="延时任务"></a>延时任务</h3><h4 id="存储延时任务的结构"><a href="#存储延时任务的结构" class="headerlink" title="存储延时任务的结构"></a>存储延时任务的结构</h4><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p>插入：O(1)</p>
<p>查询：O(logN)</p>
<p>实现：我们可以利用列表去存即将触发的任务信息，通过遍历的方式去取到大于当前时间的任务，并且触发。</p>
<p>优点：实现简单</p>
<p>缺点：但需要对所有任务进行遍历，查出很多无效数据，极其低效。</p>
<h5 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h5><p>删除：O(logN)</p>
<p>查询：O(1)</p>
<p>实现：我们也可以利用大顶堆的性质，每次都取堆顶元素，如果堆顶元素大于当前时间，那么就取最大元素。其余元素会利用大顶堆的性质，继续浮出最大的元素，然后继续比较。</p>
<p>优点：查询快，只会查到快到时间的任务，实现简单。</p>
<p>缺点：需要维护自身堆的性质，cpu压力高，无法抗住高并发。</p>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>查询：O(logN)</p>
<p>B+树（B-plus tree）是一种自平衡的树数据结构，它能够保持数据有序，允许插入、删除和查找操作在对数时间内完成。B+树特别适合于磁盘或其他直接存取辅助设备的存储系统，因为它能够最大化地减少I&#x2F;O操作次数。</p>
<h5 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h5><p>查询：O(logN)</p>
<p>跳表（Skip List）是一种基于有序链表的高效数据结构，它通过在链表的基础上增加多级索引来实现快速的查找操作。跳表允许在对数时间内完成搜索、插入和删除操作，且插入和删除操作不需要频繁调整数据结构。</p>
<h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><p>总的来说，列表和大顶堆由于自身的性质，并不适合这样的场景。对于扫表+触发的模式，其实本质是需要一个能高速范围查询的数据结构。</p>
<p>B+树和跳表都是高效的能范围查询数据结构，但它们各自适用于不同的场景。B+树更适合于磁盘存储和范围查询，而跳表则更适合于内存中的快速查找和分布式环境。</p>
<h4 id="存储数据库分析"><a href="#存储数据库分析" class="headerlink" title="存储数据库分析"></a>存储数据库分析</h4><p>我们举出基于内存的数据库的代表Redis和基于磁盘的数据库进行分析。</p>
<h5 id="Redis-VS-MySQL"><a href="#Redis-VS-MySQL" class="headerlink" title="Redis VS MySQL"></a>Redis VS MySQL</h5><p>1.Redis的底层是跳表，而MySQL的底层是B+树。就范围查询而言，两者不分伯仲。</p>
<p>2.但Redis没有事务概念，内部实现是单线程，没有锁竞争，再加上IO多路复用的特性和极其高效的数据结构实现，就注定单机qps要远超过mysql。</p>
<p>3.mysql在这个场景下的优势则是有持久化能力，不容易丢数据，Redis可能在RDB和AOF的过程中有丢数据的可能性。</p>
<p>因此，mysql和redis都有可能是作为存储任务的数据库，需要区分场景。</p>
<p>综合考虑下我选用Redis。虽然Redis有丢数据的风险无法完美保证延时任务不丢，但是在本文中描述的延时任务是不断更新的，是动态的。比如某条数据现在是10M，然后执行RDB备份。再然后更新延时任务变成11M，假设此时断电宕机，11M这个数据没保存下来，但是10M这个数据已经保存了啊。虽然丢了一点数据，但是不多。系统停机维护时把延时任务和临时目录全删了，再把数据库中记录用户未上传完大小的这个字段置为0。一切又回到最初的起点。</p>
<blockquote>
<p>问题又来了，既然这里可以接受丢数据，那为什么不把未上传完大小这个字段放在 redis ，然后不保证和 mysql 的一致性？或者说只有<br>redis 里放未上传完大小，mysql 表字段里只有用户已上传完大小。都是相同的丢数据风险。为什么这里可以接受上面不可以接受？</p>
<p>其实这个需求就不是个合理的需求。只是我需要通过这个需求找到一个可以写简历的亮点。恰好对任务调度比较熟悉，所以需要通过这个不合理的需求引入任务调度。</p>
</blockquote>
<p>如果用mysql存储动态延时任务，那就要经常更新mysql。其实也可以。但是mysql扛不住比较大的QPS，速度不如redis。综合考虑我还是用redis存延时任务。</p>
<h4 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h4><p>只要涉及到了缓存和数据库就一定会有缓存一致性问题，延时任务也不例外。</p>
<p>这里用的策略是先更新缓存，再更新数据库。</p>
<p>数据库的更新取决于延时任务被执行的时间。</p>
<p>通过延时任务的执行来保证 redis 和 mysql 的最终一致性。</p>
<h4 id="延时任务的具体思路"><a href="#延时任务的具体思路" class="headerlink" title="延时任务的具体思路"></a>延时任务的具体思路</h4><p>文件片被上传时，用一个redis结构保存延时任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">    <span class="type">long</span> timestamp; <span class="comment">// 任务被创建或更新的时间</span></span><br><span class="line">    <span class="type">long</span> unfinishedDBSize;<span class="comment">// 待更新至数据库的未上传完成大小</span></span><br><span class="line">    String userID; <span class="comment">// 任务执行器需要根据UserID写SQL</span></span><br><span class="line">    String md5;<span class="comment">//标识唯一文件</span></span><br><span class="line">    <span class="type">int</span> flag;<span class="comment">//标识当前延时任务是否被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义zset中的member</p>
<p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-02-fileIUpLoad/img.png"></p>
<p>zset 中 member 的整体结构设计。<br>同一个zset桶中，同一个用户的不同延时任务的时间戳可能相同，这需要member中保存userID和md5作为辨别。</p>
<blockquote>
<p>对上图的更正：</p>
<ol>
<li>HashMap结构中的V保存时间戳与userID的或运算结果与Zset桶的编号</li>
<li>zset中的score保存时间戳与UserId的或运算结果。因为在某个zset桶中，不同用户上传的文件片延时任务的时间戳可能相同。但如果只是时间戳+userID的话太长了，不能作为 score。因此改为或运算结果(时间戳是Long类型，占低41位，高23位是0。userID的高23位有1有0，也就是说高23位的或运算结果就是userid的高23位。在时间戳相同的情况下，区分度完全由Userid决定，这就避免了不同用户上传的文件片的延时任务在zset桶中具有相关的score)。同时对于单个zset而言，score有不有序不重要，重要的是能通过score定义到唯一的member。但是这也意味着某个zset桶中可能存在同一个用户的不同延时任务。</li>
</ol>
<p>再次更正：</p>
<p>既然 score 用 timestamp 与 userID 的或运算结果，而且区分度取决于 userID。那为什么不直接用 userID 作为 score？</p>
<p>最终结果：</p>
<ol>
<li>HashMap结构中的V保存Zset桶的编号</li>
<li>zset 桶中的score 是 userID</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table user_info</span><br><span class="line">(</span><br><span class="line">    user_id              varchar(12) not null primary key,</span><br><span class="line">    use_space_finished   bigint default 1024 comment &#x27;已上传完毕文件使用总空间,单位byte&#x27;,</span><br><span class="line">    use_space_unfinished bigint default 0 comment &#x27;未上传完毕文件使用总空间,单位byte&#x27;,</span><br><span class="line">    total_space          bigint comment &#x27;总空间&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>用户表相关字段</p>
<p>某文件第一个文件分片上传完后，创建出一个任务。根据当前时间戳 ，得到目标 zset 桶编号(如23-54-1）， 以 userID 作为 score，任务作为<code>member</code>加入到<code>zset</code>中。再用一个 map 记录md5+userid 和zset 桶编号(23-54-1)的映射。</p>
<p>后续的文件分片上传时，因为任务需要更新，。所以需要设计了以下几个步骤：</p>
<ol>
<li>从 hashmap 中根据 userID+md5 拿到zset 桶编号。</li>
<li>从 zset 桶中用 <code>ZRANGEBYSOCRE</code> 取出这个 userID 对应的任务列表(都是这个用户上传的文件片的任务且还没有被调度)，并从中找到当前 md5 对应的任务。如果找不到说明任务被调度了，创建新任务。</li>
<li>更新任务信息</li>
<li>根据当前 timestamp 算出存储任务的桶，如果还是这个桶，就通过 <code>ZADD</code>命令把任务列表放回桶(23-54-1) ，跳过第五步；如果不是，就计算出新的桶编号，如：(23-59-3)，并执行第五步。</li>
<li>将任务列表中的目标任务删除，任务列表重新插入 zset 桶(23-54-1)，目标任务加入到 zset 桶(23-59-4)中。</li>
<li>更新HashMap中记录的时间戳与桶编号</li>
</ol>
<p>第5,6步中对 redis 的操作不是原子性的，可能会有这样的问题吗？</p>
<ol>
<li>调度器先扫描了 zset 桶(23-54-1)，然后任务列表才被重新放回桶中，导致任务要晚一天执行。<blockquote>
<p>并不会有，延时任务在业务的设定下是延时23个小时。调度器调度的任务是23个小时之前的，不会调度现在新增的任务</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>为什么 不用 文件id作为key呢？</p>
</blockquote>
<p>主要是考虑到在文件被完全上传完之前，确定id没有意义。除非客户端在上传一个文件时携带id，且保证发生断点续传时，第二次上传携带的id和第一次相同。但是满足这个条件的id的生成规则肯定和雪花算法不同，因为雪花算法生成的id和时间有关，但当前场景下需要时间无关。注意。这里的意思并不是说一个文件被重复上传时客户端生成的id前后都一样，而是在一次上传流程中，如果因为应用重启等原因出现了中断，中断后的上传请求中的文件id和中断前保持相同。重复上传时的id则必须不同。</p>
<blockquote>
<p>文件只在完全被上传后才会为它生成 id，否则用 md5+userid表示</p>
<p>而且这篇文章是针对于服务端的，我假设客户端上传时不携带id信息。另外，我认为服务端一个重要的原则就是不要相信客户端传来的数据，能做检验的数据一定要做检验。客户端传来的数据都是可以被篡改的。https虽然安全，但如果出现了中间服务器，https报文就变成明文了。</p>
</blockquote>
<p>后续文件片上传时，去 map 里根据md5+userid 拿到保存任务的 zset 编号，根据当前时间所属分钟 + 5s 是否等于该 zset 所属的分钟得到<br>boolean 类型变量 x。 去这个 zset 里根据md5+userid 找到这个文件的任务。如果 x &#x3D;&#x3D; true, 修改该任务。否则将该任务删除，移至下一分钟的<br>zset。</p>
<p>当所有文件片正常上传完触发文件片合并，然后数据库更新<code>use_space_finished</code>字段。</p>
<p>之后根据<code>map</code>通过<code>用户id + 文件md5值</code>获取 zset 编号，获取该<code>zset</code>中对应任务的<code>unfinishedDBSize</code>和<code>unfinishedSize</code>。</p>
<p>执行<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> - <code>unfinishedDBSize</code> - <code>unfinishedSize</code>。这是补偿用户的操作。</p>
<p>因为延时任务肯定会被执行的(<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> + <code>unfinishedDBSize</code>)，先减<code>unfinishedDBSize</code><br>和后减<code>unfinishedDBSize</code>没区别。至于<code>unfinishedSize</code><br>？只要这个文件的延时任务没有被执行过，它就是0。即使执行过也没关系，见<a href="#custom">3.4 考虑断点续传，用户只上传了一部分就宕机了，然后恢复机器继续上传。但是此时这个文件在zset里的任务已经更新到数据库了。后续的一部分文件上传是什么流程？</a></p>
<p>（延时任务能不能成功执行至关重要！！！最终一致性全靠它保证！！！）</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>一个文件片上传完后，有六个步骤：</p>
<ol>
<li>如果没有这个文件 md5 + userid 的临时目录，那么创建任务，放入当前实际的 Zset，在 map 里记录 Zset 和 MD5+</li>
<li>后续的文件片上传根据<code>文件md5值+用户id</code>去<code>map</code>里找到保存上一个文件片延时任务的 zset，在根据 md5 + userid 去 Zset<br>里找到延时任务</li>
<li>修改任务，根据当前时间 + 5s 决定任务修改后是否移至另一 Zset 。是考虑到调度器的调度时机。</li>
<li>写<code>map</code>，更新<code>文件md5值+用户id</code>对应的 Zset 编号。</li>
<li>执行延时任务，<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> + <code>unfinishedDBSize</code></li>
<li>文件上传完成，<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> - <code>unfinishedDBSize</code> - <code>unfinishedSize</code></li>
</ol>
<p>第五步和第六步的执行顺序没有要求！谁先执行都可以！</p>
<hr>
<h3 id="延时任务执行调度"><a href="#延时任务执行调度" class="headerlink" title="延时任务执行调度"></a>延时任务执行调度</h3><p>当任务量很大时，任务的执行调度也需要花心思设计。</p>
<h4 id="调度器扫描"><a href="#调度器扫描" class="headerlink" title="调度器扫描"></a>调度器扫描</h4><p>集群模式下的调度器每分钟执行一次，扫描上一个小时的该分钟内所有的 zset 桶。注意由于是集群模式，需要先获得目标桶的锁才能扫描，抢锁用 redission 看门狗实现。如果调度器执行过程中挂了，里面这些任务就得晚一天执行了。</p>
<blockquote>
<p>如果某个调度器获得了一个桶的锁却挂了，有没有一种核验机制能够确定这一分钟内的桶哪些被扫描执行了哪些没被扫描执行呢？</p>
<p>有，另起一个定时任务，检查上一分钟的那些桶的里有没有数据。如果有，调度一遍。</p>
<p>原因见下文。刚被调度了的桶再想有数据新增，得等 1 个小时。</p>
<p>所以上一分钟的那些桶里如果还有数据，一定是调度器有问题，得看日志排查。</p>
</blockquote>
<p>任务扫描这里有个问题：扫描出来的任务在下发后要从桶中删掉，桶里新增的任务也会被删，怎么办？</p>
<blockquote>
<p>由于任务调度的那些桶对应的时间比当前时间早一个小时，新增的任务都放在当前时间的那些桶里了，当前扫描的桶里的任务都是 23 小时前增加的。</p>
<p>比如现在时间是 2023-12-21  20:40, 某个调度器扫描了(21-40-1)这个桶，这个桶里的任务都是2023-12-20  21:40 放进去的，现在新增的任务进的桶是(20-40-1) - (20-40-n)。</p>
<p>(21-40-1)这个桶再想有数据新增，得等 1 个小时。</p>
<p>除非生产者的机器时钟有问题，否则绝对不会有数据新增。</p>
</blockquote>
<p>这也就意味着一天 24 个小时，每时每刻 23 个小时里的桶有数据，1 个小时里的桶没数据。如果不能理解可以这样理解：24 个小时都没数据，零点开始运行，第零个小时里的桶有数据。扫描器扫描的是第一个小时，无数据………到了 23 点，第 23 个小时的桶开始有数据，扫描器开始扫描第零个小时的桶，有数据。<br>当然延时 23 个小时有点太长了，也可以根据真实业务场景用分钟代替小时，每 23 分钟一循环。</p>
<h4 id="任务下发"><a href="#任务下发" class="headerlink" title="任务下发"></a>任务下发</h4><p>扫描出来的任务通过带回调函数的 send 方法发给 Kafka，配置好 ack。所有任务都发给 Kafka 后，删除这个桶里全部数据。</p>
<p>有些任务实在发不出去，也不能留在桶里，因为调度器只要正常调度了，桶里的数据就要删掉，Kafka 的问题是 Kafka 的问题，和调度器没关系。</p>
<p>发不出去的任务在回调函数中设置存入数据库里的死信表里等运维人员处理。</p>
<blockquote>
<p>如果任务发不出去，数据库也挂了怎么办？<br>消息发送前先写日志。数据库挂了先恢复，再根据日志里的记录和表中数据比对，比对不上的做数据恢复。</p>
</blockquote>
<p>任务调度的更多细节具体参考</p>
<p><a href="https://juziblog.space/2024/08/30/2024-08-30-%E9%AB%98%E6%80%A7%E8%83%BD%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/">高性能调度系统设计总结</a></p>
<h2 id="一些A-Q"><a href="#一些A-Q" class="headerlink" title="一些A&amp;&amp;Q"></a>一些A&amp;&amp;Q</h2><h3 id="延时任务重复问题"><a href="#延时任务重复问题" class="headerlink" title="延时任务重复问题"></a>延时任务重复问题</h3><p>一个文件多个分片上传，会造成该文件有多个延时任务。也就说一个分片一个延时任务。如何解决重复的问题？</p>
<p>只有第一个分片会创建延时任务，后续文件片根据 <code>MD5 + userid</code> 会找到延时任务删除、修改、新增。</p>
<h3 id="用户开多个客户端同时上传，怎么保证延时任务更新正确？"><a href="#用户开多个客户端同时上传，怎么保证延时任务更新正确？" class="headerlink" title="用户开多个客户端同时上传，怎么保证延时任务更新正确？"></a>用户开多个客户端同时上传，怎么保证延时任务更新正确？</h3><p><code>zset</code>中的延时任务只和某一个文件有关。开多个客户端上传多个文件，就会出现多个延时任务，彼此互不干扰，并不会有什么问题。</p>
<h4 id="开多个客户端上传同一份文件呢？"><a href="#开多个客户端上传同一份文件呢？" class="headerlink" title="开多个客户端上传同一份文件呢？"></a>开多个客户端上传同一份文件呢？</h4><p>那就让他传。本质上和开多个客户端上传多个文件没有区别。只是服务器上会出现两份相同的文件。</p>
<p>而且这种情况出现概率非常小。</p>
<h3 id="用户开多个客户端同时上传，怎么保证不会超过限额？"><a href="#用户开多个客户端同时上传，怎么保证不会超过限额？" class="headerlink" title="用户开多个客户端同时上传，怎么保证不会超过限额？"></a>用户开多个客户端同时上传，怎么保证不会超过限额？</h3><p>网盘产品里，用户一但登录了，大概率会开第二个客户端也登录，比如手机登录了，上传一个文件，网页接着登录，下载该文件。这期间，用户可能会多次刷新网页或者打开网盘的别的页面。而每个页面都需要显示用户已使用空间和总空间。</p>
<p>于是可以考虑在用户登录后缓存一些数据。在 Redis 中保存每个用户的总空间<code>total_Space</code>，已上传完毕大小<code>finishedFileSize</code>和未上传完毕大小<code>unfinishedFileSize</code>。</p>
<p>文件片上传前，判断下<code>unfinishedFileSize</code>+ <code>finishedFileSize</code> 是否大于<code>total_Space</code>。如果大于，就返回错误信息，直接告诉用户别的客户端上传的文件有点大，超过了限额，当前文件不能上传。</p>
<p>如果上面的校验没问题，那就让<code>unfinishedFileSize</code>加上文件总大小。</p>
<p>文件上传完毕，从<code>unfinishedFileSize</code>中减去该文件的大小。</p>
<p>显示给用户看的已使用空间就是<code>finishedFileSize</code>。只把<code>finishedFileSize</code>返回即可。</p>
<h3 id="custom">考虑断点续传，用户只上传了一部分就宕机了，然后恢复机器继续上传。但是此时这个文件在zset里的任务已经更新到数据库了。后续的一部分文件上传是什么流程？</h3>

<p>举个场景例子并给出解决方案：</p>
<p>某用户在数据库中<code>use_space_unfinished</code>字段是0。<code>zset</code>里<code>unfinishedDBSize</code>字段是10M。</p>
<p>然后用户宕机，延时任务没有被刷新而是被触发，导致用户在数据库中的<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> + <code>10M</code>  &#x3D; <code>0M</code> + <code>10M</code>&#x3D; <code>10M</code>。任务触发后被删除。</p>
<p>用户重启客户端发生断点续传，下一个大小为<code>1M</code>的文件片被上传了。于是写<code>zset</code>，新增一个延时任务，<code>unfinishedDBSize</code>字段是<code>1M</code>。</p>
<p>假如这个大小为<code>1M</code>的文件片是最后一个文件片，上传完就触发文件片合并流程。在合并的流程中，计算出真实合并了<code>11M</code>大小的文件片，于是修改<code>use_space_unfinished</code>字段，<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> - <code>11M</code> &#x3D; <code>-1M</code>。</p>
<p>但是延时任务还没执行，等到延时任务执行后，<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> + <code>1M</code>  &#x3D; <code>-1M</code> + <code>1M</code>&#x3D; <code>0M</code>。保证了最终一致性。</p>
<h3 id="为什么不用md5-userid-作为文件表主键呢？"><a href="#为什么不用md5-userid-作为文件表主键呢？" class="headerlink" title="为什么不用md5+userid 作为文件表主键呢？"></a>为什么不用md5+userid 作为文件表主键呢？</h3><p>因为用户可以一份文件上传多次，会出现主键重复问题</p>
<h3 id="为什么延时任务不设计成一个用户一个任务而是一个文件一个任务？"><a href="#为什么延时任务不设计成一个用户一个任务而是一个文件一个任务？" class="headerlink" title="为什么延时任务不设计成一个用户一个任务而是一个文件一个任务？"></a>为什么延时任务不设计成一个用户一个任务而是一个文件一个任务？</h3><p>一个用户一个任务是更优的方案，可以显著降低任务的数量。这是一个优化点。</p>
<p>在一个用户一个客户端的情况下，一个用户一个任务和一个文件一个任务是一样的。</p>
<p>一个用户开多个客户端上传或者单客户端并行上传多文件，可以降低任务的数量。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://juziblog.space">xyhao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://juziblog.space/2024/10/02/2024-10-02-%E5%8A%A8%E6%80%81%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%80%BB%E7%BB%93/">http://juziblog.space/2024/10/02/2024-10-02-动态延时任务总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://juziblog.space" target="_blank">xyhao的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">任务调度</a><a class="post-meta__tags" href="/tags/%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1/">延时任务</a></div><div class="post-share"><div class="social-share" data-image="https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/2024-10-02-fileUpLoad.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2024/10/18/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/" title="九大服务架构性能优化方式"><img class="cover" src="https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/Tencent.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">九大服务架构性能优化方式</div></div></a><a class="next-post pull-right" href="/2024/08/30/2024-08-30-%E9%AB%98%E6%80%A7%E8%83%BD%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/" title="高性能调度系统设计总结"><img class="cover" src="https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/Tencent.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">高性能调度系统设计总结</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2024/08/30/2024-08-30-%E9%AB%98%E6%80%A7%E8%83%BD%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/" title="高性能调度系统设计总结"><img class="cover" src="https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/Tencent.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-30</div><div class="title">高性能调度系统设计总结</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="https://gitee.com/xyhaooo/picrepo/raw/master/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xyhao</div><div class="author-info-description">软件工程专业2025届本科毕业生，Java服务端开发方向</br>工作经历：</br>2025年6月-至今 拼多多-Java开发</br></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Juzi-xyhao"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Juzi-xyhao" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:xyhaomail@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a><a class="social-icon" href="https://space.bilibili.com" rel="external nofollow noreferrer" target="_blank" title="Bilibili"><i class="fas fa-tv"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">未来的一些更新：</br> YouTube视频：System Design Interview 笔记 </br> && DDIA（数据密集型应用系统设计）笔记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MD5%E5%AF%86%E7%A0%81%E6%9D%82%E5%87%91%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">MD5密码杂凑算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">表结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">采用第一种方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">优点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.2.</span> <span class="toc-text">用第二种方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">优点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.</span> <span class="toc-text">三个功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E4%B8%8A%E4%BC%A0%E5%AE%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">没上传完怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6%E7%89%87%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">上传后的文件片怎么处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BA%BA%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">2.2.</span> <span class="toc-text">有人恶意攻击怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">2.3.1.</span> <span class="toc-text">举个例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.4.</span> <span class="toc-text">延时任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">存储延时任务的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%A1%A8"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E9%A1%B6%E5%A0%86"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">大顶堆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">B+树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">跳表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.1.5.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E6%9E%90"><span class="toc-number">2.4.2.</span> <span class="toc-text">存储数据库分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis-VS-MySQL"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">Redis VS MySQL</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.3.</span> <span class="toc-text">缓存一致性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%85%B7%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="toc-number">2.4.4.</span> <span class="toc-text">延时任务的具体思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%B0%83%E5%BA%A6"><span class="toc-number">2.5.</span> <span class="toc-text">延时任务执行调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E6%89%AB%E6%8F%8F"><span class="toc-number">2.5.1.</span> <span class="toc-text">调度器扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%8B%E5%8F%91"><span class="toc-number">2.5.2.</span> <span class="toc-text">任务下发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9BA-Q"><span class="toc-number">3.</span> <span class="toc-text">一些A&amp;&amp;Q</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">延时任务重复问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%BC%80%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%9B%B4%E6%96%B0%E6%AD%A3%E7%A1%AE%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">用户开多个客户端同时上传，怎么保证延时任务更新正确？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E4%BC%A0%E5%90%8C%E4%B8%80%E4%BB%BD%E6%96%87%E4%BB%B6%E5%91%A2%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">开多个客户端上传同一份文件呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%BC%80%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%BC%9A%E8%B6%85%E8%BF%87%E9%99%90%E9%A2%9D%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">用户开多个客户端同时上传，怎么保证不会超过限额？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#custom"><span class="toc-number">3.4.</span> <span class="toc-text">考虑断点续传，用户只上传了一部分就宕机了，然后恢复机器继续上传。但是此时这个文件在zset里的任务已经更新到数据库了。后续的一部分文件上传是什么流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8md5-userid-%E4%BD%9C%E4%B8%BA%E6%96%87%E4%BB%B6%E8%A1%A8%E4%B8%BB%E9%94%AE%E5%91%A2%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">为什么不用md5+userid 作为文件表主键呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%B8%8D%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E8%80%8C%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">为什么延时任务不设计成一个用户一个任务而是一个文件一个任务？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/14/2025-05-14-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%E7%A0%94%E7%A9%B6/" title="性能优化：字符串替换研究"><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/前缀树.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="性能优化：字符串替换研究"/></a><div class="content"><a class="title" href="/2025/05/14/2025-05-14-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%E7%A0%94%E7%A9%B6/" title="性能优化：字符串替换研究">性能优化：字符串替换研究</a><time datetime="2025-05-14T11:00:00.000Z" title="发表于 2025-05-14 11:00:00">2025-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/21/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/" title="常用的Linux命令"><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/Linux.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用的Linux命令"/></a><div class="content"><a class="title" href="/2025/03/21/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/" title="常用的Linux命令">常用的Linux命令</a><time datetime="2025-03-21T11:00:00.000Z" title="发表于 2025-03-21 11:00:00">2025-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/20/2025-03-20-shell%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95/" title="shell的一些简单语法"><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/shell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shell的一些简单语法"/></a><div class="content"><a class="title" href="/2025/03/20/2025-03-20-shell%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95/" title="shell的一些简单语法">shell的一些简单语法</a><time datetime="2025-03-20T11:00:00.000Z" title="发表于 2025-03-20 11:00:00">2025-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/17/2025-02-17-JavaDoc/" title="JavaDoc"><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaDoc"/></a><div class="content"><a class="title" href="/2025/02/17/2025-02-17-JavaDoc/" title="JavaDoc">JavaDoc</a><time datetime="2025-02-17T12:00:00.000Z" title="发表于 2025-02-17 12:00:00">2025-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/16/2025-02-16-%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/" title="浅浅理解Java中的逆变与协变"><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleCover/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浅浅理解Java中的逆变与协变"/></a><div class="content"><a class="title" href="/2025/02/16/2025-02-16-%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/" title="浅浅理解Java中的逆变与协变">浅浅理解Java中的逆变与协变</a><time datetime="2025-02-16T12:00:00.000Z" title="发表于 2025-02-16 12:00:00">2025-02-16</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By xyhao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/instant.page/instantpage.js" type="module"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="7509532357" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-order="random"> </div><script>(function(a,h,g,f,e,d,c,b){b=function(){d=h.createElement(g);c=h.getElementsByTagName(g)[0];d.src=e;d.charset="utf-8";d.async=1;c.parentNode.insertBefore(d,c)};a["SeniverseWeatherWidgetObject"]=f;a[f]||(a[f]=function(){(a[f].q=a[f].q||[]).push(arguments)});a[f].l=+new Date();if(a.attachEvent){a.attachEvent("onload",b)}else{a.addEventListener("load",b,false)}}(window,document,"script","SeniverseWeatherWidget","//cdn.sencdn.com/widget2/static/js/bundle.js?t="+parseInt((new Date().getTime()/100000000).toString(),10)));window.SeniverseWeatherWidget('show',{flavor:"slim",location:"WWMKWU0KKVZP",geolocation:true,language:"zh-Hans",unit:"c",theme:"auto",token:"be6ff036-8674-43e7-8f27-8716c37b157b",hover:"disabled",container:"tp-weather-widget"});</script><script>(() => {
  const option = null
  const config = {"site_uv":false,"site_pv":false,"page_pv":false,"token":"GIavIQd5ls6rab5DTfY42p1VRA4DfPQo"}

  const runTrack = () => {
    umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
  }

  const loadUmamiJS = () => {
    btf.getScript('https://cloud.umami.is/script.js', {
      'data-website-id': '5b9ef408-bff2-4b30-8d1e-28cb3c95721a',
      'data-auto-track': 'false',
      ...option
    }).then(runTrack)
  }

  const getData = async (isPost) => {
    const now = Date.now()
    const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
    const headerList = { 'Accept': 'application/json' }
    if (false) headerList['Authorization'] = `Bearer ${config.token}`
    else headerList['x-umami-api-key'] = config.token
    const res = await fetch(`https://api.umami.is/v1/websites/5b9ef408-bff2-4b30-8d1e-28cb3c95721a/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
      method: "GET",
      headers: headerList
    })
    return await res.json()
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.isPost && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          pagePV.textContent = data.pageviews.value
        }
      } else {
        const data = (config.site_uv || config.site_pv) && await getData()
        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV) siteUV.textContent = data.visitors.value
        }
        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV) sitePV.textContent = data.pageviews.value
        }
      }
    } catch (e) {
      console.error('Failed to load Umami Analytics:', e)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')

  loadUmamiJS()
  insertData()
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>