<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>性能优化：字符串替换研究</title>
      <link href="/2025/05/14/2025-05-14-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%E7%A0%94%E7%A9%B6/"/>
      <url>/2025/05/14/2025-05-14-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：周德东<br>原文链接：<a href="https://mp.weixin.qq.com/s/GmryGL9hkMFbyB1Lh7K7aA">字符串替换研究</a>  </p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>需求非常简单，给定一组关键词，需要将商品名称中出现过的关键字替换掉；</p><p>如：skuName&#x3D;”HUAWEI Pura 70 Pro 国家补贴500元 羽砂黑 12GB+512GB 超高速风驰闪拍 华为鸿蒙智能手机” 需要替换成 </p><p>skuName&#x3D;”HUAWEI Pura 70 Pro 羽砂黑 12GB+512GB 超高速风驰闪拍 华为鸿蒙智能手机” 这里的关键字”国家补贴500元”;</p><p>直接skuName.replace(“国家补贴500元”, “”)，不就可以了吗？如果是一组，那就循环替换就完了嘛，再考虑到关键字前缀问题，对这一组关键词，按字符长度进行排序，先替换长的关键词，再替换短的就ok了；</p><p>如果这一组关键词非常多，上千个怎么办？真实场景也是这样的，一般需要替换的关键词都是比较多，并且使用String.replace上线后，直接CPU打满，基本不可用；</p><p>这个字段替换本质上与敏感词过滤是一样的原理，针对敏感词的深入研究，出现了 Aho-Corasick（AC自动机） 算法；</p><p>Aho-Corasick（AC自动机）是一种多模式字符串匹配算法，结合了Trie树的前缀匹配能力和KMP算法的失败跳转思想，能够在单次文本扫描中高效匹配多个模式串。其核心优势在于时间复杂度为O(n + m + z)（n为文本长度，m为模式串总长度，z为匹配次数），适用于敏感词过滤、基因序列分析等场景。</p><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>针对这几种算法进行对比；</p><p>字符串替换，定义一个接口，通过4个不同的方案实现，进行性能对比</p><p><code>public interface Replacer &#123;String replaceKeywords(String text);&#125;</code></p><h2 id="String-replace-方案"><a href="#String-replace-方案" class="headerlink" title="String.replace 方案"></a>String.replace 方案</h2><p>这种方案最简单，也是关键词少的时候，最有效，最好用的;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrReplacer</span> <span class="keyword">implements</span> <span class="title class_">Replacer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; keyWordList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StrReplacer</span><span class="params">(String keyWords)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.keyWordList = Lists.newArrayList(keyWords.split(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        <span class="comment">// 按关键字长度降序排序，确保长关键字优先匹配</span></span><br><span class="line">        keyWordList.sort((a, b) -&gt; Integer.compare(b.length(), a.length()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 替换文本中所有匹配的关键字为空字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceKeywords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newTxt</span> <span class="operator">=</span> text;</span><br><span class="line">        <span class="keyword">for</span> (String s : keyWordList) &#123;</span><br><span class="line">            newTxt = newTxt.replace(s, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则替换方案"><a href="#正则替换方案" class="headerlink" title="正则替换方案"></a>正则替换方案</h2><p>String.replace本质，还是使用正则进行替换的，通过代码实现使用编译好的正则进行替换性能会好于直接使用replace；</p><p>String.replace的实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(target.toString(), Pattern.LITERAL).matcher(</span><br><span class="line">        <span class="built_in">this</span>).replaceAll(Matcher.quoteReplacement(replacement.toString()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用正则替换的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternReplacer</span> <span class="keyword">implements</span> <span class="title class_">Replacer</span> &#123;</span><br><span class="line">    <span class="comment">// 预编译正则表达式模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pattern pattern;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PatternReplacer</span><span class="params">(String keyWords)</span> &#123;</span><br><span class="line">        List&lt;String&gt; keywords = Lists.newArrayList(keyWords.split(<span class="string">&quot;;&quot;</span>));</span><br><span class="line">        <span class="comment">// 按关键字长度降序排序，确保长关键字优先匹配</span></span><br><span class="line">        keywords.sort((a, b) -&gt; Integer.compare(b.length(), a.length()));</span><br><span class="line">        <span class="comment">// 转义每个关键字并用|连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> keywords.stream()</span><br><span class="line">        .map(Pattern::quote)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;|&quot;</span>));</span><br><span class="line">        <span class="built_in">this</span>.pattern = Pattern.compile(regex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 替换方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceKeywords</span><span class="params">(String skuName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(skuName).replaceAll(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Aho-Corasick（AC自动机）-算法实现"><a href="#使用Aho-Corasick（AC自动机）-算法实现" class="headerlink" title="使用Aho-Corasick（AC自动机） 算法实现"></a>使用Aho-Corasick（AC自动机） 算法实现</h2><p>在java中已有现成的算法实现，源代码github-robert-bor&#x2F;aho-corasick，</p><p>引入jar包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.ahocorasick&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ahocorasick&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.6</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>基于 Aho-Corasick 算法的字符串替换实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AhoCorasickReplacer</span> <span class="keyword">implements</span> <span class="title class_">Replacer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Trie trie;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AhoCorasickReplacer</span><span class="params">(String keyWords)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建Aho-Corasick自动机</span></span><br><span class="line">        Trie.<span class="type">TrieBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Trie.builder().ignoreOverlaps().onlyWholeWords();</span><br><span class="line">        <span class="comment">//trie.caseInsensitive();</span></span><br><span class="line">        <span class="comment">//trie.onlyWholeWords();</span></span><br><span class="line">        <span class="keyword">for</span> (String s : keyWords.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            builder.addKeyword(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.trie = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换文本中所有匹配的关键字为空字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceKeywords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (text == <span class="literal">null</span> || text.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> text;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Collection&lt;Emit&gt; emits = trie.parseText(text); <span class="comment">// 获取所有匹配结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastEnd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Emit emit : emits) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> emit.getStart();</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> emit.getEnd();</span><br><span class="line">            <span class="comment">// 添加未匹配的前缀部分</span></span><br><span class="line">            <span class="keyword">if</span> (start &gt; lastEnd) &#123;</span><br><span class="line">                result.append(text, lastEnd, start);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 跳过匹配的关键字（即替换为空）</span></span><br><span class="line">            lastEnd = end + <span class="number">1</span>; <span class="comment">// 注意：end是闭区间，需+1移动到下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加剩余未匹配的后缀部分</span></span><br><span class="line">        <span class="keyword">if</span> (lastEnd &lt;= text.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            result.append(text.substring(lastEnd));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自己实现Trie树算法实现"><a href="#自己实现Trie树算法实现" class="headerlink" title="自己实现Trie树算法实现"></a>自己实现Trie树算法实现</h2><p>通过deepseek等人工智能，是非常容易自己实现一个Trie树，我们就只实现字符串替换的功能，其他的就不使用了；</p><p>Trie树，又叫字典树，前缀树(Prefix Tree)，单词查找树，是一种多叉树的结构。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-05-14-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%E7%A0%94%E7%A9%B6/img.png"></p><p>结构说明： 表示根节点（空节点）</p><p>每个节点表示一个字符</p><p>粉色节点表示单词结束标记（使用 CSS class 实现）</p><p>路径示例：</p><p>root → c → a → t 组成 “cat”</p><p>root → c → a → r 组成 “car”</p><p>root → d → o → g 组成 “dog”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieKeywordReplacer</span> <span class="keyword">implements</span> <span class="title class_">Replacer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Trie trie;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceKeywords</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> trie.replaceKeywords(text, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieKeywordReplacer</span><span class="params">(String keyWords)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : keyWords.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            trie.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.trie = trie;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        Map&lt;Character,TrieNode&gt; children;</span><br><span class="line">        <span class="type">boolean</span> isEndOfWord;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            isEndOfWord = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> TrieNode root;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.children.get(c) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.children.put(c, <span class="keyword">new</span> <span class="title class_">TrieNode</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.children.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">            node.isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">replaceKeywords</span><span class="params">(String text, String replacement)</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; text.length()) &#123;</span><br><span class="line">                <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="type">TrieNode</span> <span class="variable">endNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; text.length() &amp;&amp; node.children.get(text.charAt(j)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    node = node.children.get(text.charAt(j));</span><br><span class="line">                    <span class="keyword">if</span> (node.isEndOfWord) &#123;</span><br><span class="line">                        endNode = node;</span><br><span class="line">                        endIndex = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (endNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                    result.append(replacement);</span><br><span class="line">                    i = endIndex + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.append(text.charAt(i));</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h2><p>4个实现类对象的大小对比:</p><table><thead><tr><th>类</th><th>对象大小</th></tr></thead><tbody><tr><td>StrReplacer</td><td>12560</td></tr><tr><td>PatternReplacer</td><td>21592</td></tr><tr><td>TrieKeywordReplacer</td><td>184944</td></tr><tr><td>AhoCorasickReplacer</td><td>253896</td></tr></tbody></table><p>性能对比</p><p>说明：待替换一组关键词共 400个；JDK1.8</p><table><thead><tr><th></th><th>StrReplacer</th><th>PatternReplacer</th><th>TrieKeywordReplacer</th><th>AhoCorasickReplacer</th></tr></thead><tbody><tr><td>单线程循环1w次，平均单次性能(ns)</td><td>21843ns</td><td>28846ns</td><td>532ns</td><td>727ns</td></tr><tr><td>名称中只有1个待替换的关键词，2个并发线程，循环1w次，平均单次性能(ns)，机器 CPU 30%左右</td><td>23444ns</td><td>39984ns</td><td>680ns</td><td>1157ns</td></tr><tr><td>名称中只有20待替换的关键词，2个并发线程，循环1w次，平均单次性能(ns)，机器 CPU 30%左右</td><td>252738ns</td><td>114740ns</td><td>33900ns</td><td>113764ns</td></tr><tr><td>名称中只有无待替换的关键词，2个并发线程，循环1w次，平均单次性能(ns)，机器 CPU 30%左右</td><td>22248ns</td><td>9253ns</td><td>397ns</td><td>738ns</td></tr></tbody></table><p>通过性能对比，自己实现的Trie树的性能是最好的，因为只做了替换的逻辑，没有实现其他功能，其次是使用AhoCorasick算法，因为使用 AhoCorasick算法，实现字符串替换是最基本的功能，AhoCorasick算法，还能精准的匹配到在什么地方，出现过多少次等信息，功能非常强大；</p><p>通过对比编译好的正则性能确实是比使用原生String.replace 更好;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplacerTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTrieKeywordReplacer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//String name = skuName;</span></span><br><span class="line">        <span class="comment">//String expected = v2;</span></span><br><span class="line">        <span class="comment">//String name = &quot;三星Samsung Galaxy S25+ 超拟人AI助理 骁龙8至尊版 AI拍照 翻译手机 游戏手机 12GB+256GB 冷川蓝&quot;;</span></span><br><span class="line">        <span class="comment">//String expected = name;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> keyWords;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expected</span> <span class="operator">=</span> v1;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">Replacer</span> <span class="variable">replacer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieKeywordReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 替换所有关键字() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//String name = skuName;</span></span><br><span class="line">        <span class="comment">//String expected = v2;</span></span><br><span class="line">        <span class="comment">//String name = &quot;三星Samsung Galaxy S25+ 超拟人AI助理 骁龙8至尊版 AI拍照 翻译手机 游戏手机 12GB+256GB 冷川蓝&quot;;</span></span><br><span class="line">        <span class="comment">//String expected = name;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> keyWords;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expected</span> <span class="operator">=</span> v1;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;替换：&quot;</span> + name);</span><br><span class="line">        <span class="type">Replacer</span> <span class="variable">replacer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">        replacer = <span class="keyword">new</span> <span class="title class_">PatternReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">        replacer = <span class="keyword">new</span> <span class="title class_">TrieKeywordReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">        replacer = <span class="keyword">new</span> <span class="title class_">AhoCorasickReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 无关键字替换() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//String name = skuName;</span></span><br><span class="line">        <span class="comment">//String expected = v2;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;三星Samsung Galaxy S25+ 超拟人AI助理 骁龙8至尊版 AI拍照 翻译手机 游戏手机 12GB+256GB 冷川蓝&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expected</span> <span class="operator">=</span> name;</span><br><span class="line">        <span class="comment">//String name = keyWords;</span></span><br><span class="line">        <span class="comment">//String expected = v1;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;替换：&quot;</span> + name);</span><br><span class="line">        <span class="type">Replacer</span> <span class="variable">replacer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">        replacer = <span class="keyword">new</span> <span class="title class_">PatternReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">        replacer = <span class="keyword">new</span> <span class="title class_">TrieKeywordReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">        replacer = <span class="keyword">new</span> <span class="title class_">AhoCorasickReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 有<span class="number">1</span>个关键字替换() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//String name = skuName;</span></span><br><span class="line">        <span class="comment">//String expected = v2;</span></span><br><span class="line">        <span class="comment">//String name = &quot;三星Samsung Galaxy S25+ 超拟人AI助理 骁龙8至尊版 AI拍照 翻译手机 游戏手机 12GB+256GB 冷川蓝&quot;;</span></span><br><span class="line">        <span class="comment">//String expected = name;</span></span><br><span class="line">        <span class="comment">//String name = keyWords;</span></span><br><span class="line">        <span class="comment">//String expected = v1;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;HUAWEI Pura 70 Pro 国家补贴500元 羽砂黑 12GB+512GB 超高速风驰闪拍 华为鸿蒙智能手机&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expected</span> <span class="operator">=</span> <span class="string">&quot;HUAWEI Pura 70 Pro 500元 羽砂黑 12GB+512GB 超高速风驰闪拍 华为鸿蒙智能手机&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;替换：&quot;</span> + name);</span><br><span class="line">        <span class="type">Replacer</span> <span class="variable">replacer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">        replacer = <span class="keyword">new</span> <span class="title class_">PatternReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">        replacer = <span class="keyword">new</span> <span class="title class_">TrieKeywordReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">        replacer = <span class="keyword">new</span> <span class="title class_">AhoCorasickReplacer</span>(keyWords);</span><br><span class="line">        check(replacer, name, expected);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            checkExec(replacer, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(Replacer replacer, String name, String expected)</span> &#123;</span><br><span class="line">        System.out.println(replacer.getClass().getName()+<span class="string">&quot;，对象大小：&quot;</span>+ObjectSizeCalculator.getObjectSize(replacer));</span><br><span class="line">        <span class="type">String</span> <span class="variable">newTxt</span> <span class="operator">=</span> replacer.replaceKeywords(name);</span><br><span class="line">        <span class="comment">//System.out.println(newTxt);</span></span><br><span class="line">        Assert.assertEquals(replacer.getClass().getName() + <span class="string">&quot;,对比不一致!&quot;</span>, expected, newTxt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">checkExec</span><span class="params">(Replacer replacer, String name)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newTxt</span> <span class="operator">=</span> replacer.replaceKeywords(name);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nThreads</span>  <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(nThreads);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">downLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(nThreads);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; nThreads) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">ns</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    <span class="keyword">while</span> (i++ &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">                        replacer.replaceKeywords(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> replacer.getClass().getName();</span><br><span class="line">                    downLatch.countDown();</span><br><span class="line">                    System.out.println(StringUtils.substring(name, name.length() - <span class="number">50</span>, name.length()) + <span class="string">&quot;\ti=&quot;</span> + i + <span class="string">&quot;, \t耗时：&quot;</span> + (System.nanoTime() - ns) / i + <span class="string">&quot;ns&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            downLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><ol><li>使用现成的AhoCorasick算法进行实现，是性能与稳定性最优的选择，非常强调性能，还是可以自己实现Trie树来实现；</li><li>在真实的使用过程中，因为大部分的商品名称最多出现几个关键词，并且待替换的关键词往往都是比较多的，可以从待替换的关键词中找出几个有代表性的词，判断商品名称中是否存在该词；再进行全量替换。如待替换的关键词有：“政府补贴”、“国补”、“支持国补”； 那么我们并不是直接循环这个待替换的关键词组，而是找出这么关键词中都有的关键字”补”先判断商品名称中是否存在“补”字后，再做处理; 这里的前置判断，还可以使用布隆过滤器实现；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceKeywords</span> <span class="params">(String skuName)</span>&#123;</span><br><span class="line">    <span class="type">Replacer</span> <span class="variable">replacer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AhoCorasickReplacer</span>(keyWords);</span><br><span class="line">    <span class="keyword">if</span>(skuName.contains(<span class="string">&quot;补&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span>  replacer.replaceKeywords(skuName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> skuName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我的理解：<br>但是每次的关键字列表都是不一样的，所以我们还得设计一段代码，找出关键词列表中出现次数最多的公共字符（每个字符串对每个独特的字符只计一次数，如字符串“国补、支持国补”，包含关键字’补’两次，但只计算一次，否则形如字符串“补贴贴贴贴贴贴贴”中的“贴”就会成为出现次数最多的公共字符）。<br>针对包含该公共字符的子字符串列表，做前置判断。这又是一道算法题。<br>思路是用哈希表维护全局的公共字符出现次数。对关键词列表做遍历，将出现的字符串放入哈希表记录出现次数。</p></blockquote><p>简单实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">example</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span> <span class="variable">maxCountChar</span> <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">func</span><span class="params">(List&lt;String&gt; keyWordList)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : keyWordList) &#123;</span><br><span class="line">            HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(c)) &#123;</span><br><span class="line">                    map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(map.get(c) &gt; maxCount) &#123;</span><br><span class="line">                        maxCount = map.get(c);</span><br><span class="line">                        maxCountChar = c;</span><br><span class="line">                    &#125;</span><br><span class="line">                    set.add(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCountChar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是关键字列表中的字符总数。真实业务场景里，通常不会大于200，毕竟哪来那么多关键字呢？<br>用不大于O(200)的时间复杂度去节省包含<code>maxCountChar</code> 的子关键字列表对<code>skuName</code>列表的遍历，还是很值得的。</p>]]></content>
      
      
      <categories>
          
          <category> 开发细节 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的Linux命令</title>
      <link href="/2025/03/21/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/03/21/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="cat-less-tail-vim-日志"><a href="#cat-less-tail-vim-日志" class="headerlink" title="cat &amp; less &amp; tail &amp; vim 日志"></a>cat &amp; less &amp; tail &amp; vim 日志</h2><p>主要是用来处理日志，后端这个岗几乎每天都要跟日志打交道。服务出故障了来查日志，用户有问题要查日志……  </p><p>一般来说，查日志要么就登录 ElasticSearch等服务搜索，要么就直接对日志文件做查询，所以熟悉日志处理的各种命令，是很重要的。</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>输出文件的全部内容，不会分页</p><h4 id="输出文件内容"><a href="#输出文件内容" class="headerlink" title="输出文件内容"></a>输出文件内容</h4><p><code>cat filename</code></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img.png"></p><h4 id="创建新文件"><a href="#创建新文件" class="headerlink" title="创建新文件"></a>创建新文件</h4><p><code>cat &gt; newfile</code></p><h4 id="合并文件内容"><a href="#合并文件内容" class="headerlink" title="合并文件内容"></a>合并文件内容</h4><p><code>cat file1 file2 &gt; file3</code></p><p> 创建 file3 文件，并将 file1 和 file2 先后写入新创建的 file3 中</p><h4 id="追加内容到文件"><a href="#追加内容到文件" class="headerlink" title="追加内容到文件"></a>追加内容到文件</h4><p><code>cat &gt;&gt; existingfile</code></p><p>将终端输入的内容追加到 <code>existingfile.txt</code> 的末尾(不会覆盖)</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_1.png"></p><h4 id="将文件内容写入另一个文件"><a href="#将文件内容写入另一个文件" class="headerlink" title="将文件内容写入另一个文件"></a>将文件内容写入另一个文件</h4><p><code>cat filename &gt; newfile.txt</code>，会覆盖 newfile.txt 的原有内容</p><h4 id="合并文件并显示内容"><a href="#合并文件并显示内容" class="headerlink" title="合并文件并显示内容"></a>合并文件并显示内容</h4><p><code>cat file1 file2</code></p><h4 id="清空文件内容"><a href="#清空文件内容" class="headerlink" title="清空文件内容"></a>清空文件内容</h4><p><code>cat /dev/null &gt; filename</code></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_2.png"></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="n-显示行号"><a href="#n-显示行号" class="headerlink" title="-n 显示行号"></a>-n 显示行号</h5><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_3.png"></p><h5 id="v-显示特殊字符"><a href="#v-显示特殊字符" class="headerlink" title="-v 显示特殊字符"></a>-v 显示特殊字符</h5><h5 id="b-显示非空行的行号"><a href="#b-显示非空行的行号" class="headerlink" title="-b 显示非空行的行号"></a>-b 显示非空行的行号</h5><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_4.png"></p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>cat命令会把整个文件内容全部输出。要知道，日志文件都是很大的，一次性打印只会狂刷控制它，除了闪瞎眼之外没有其他用处。需要使用less命令，逐行逐页地打印日志内容，再输入”&#x2F;“使用搜索功能，才能方便我们查看日志。</p><h4 id="分页查看文件内容："><a href="#分页查看文件内容：" class="headerlink" title="分页查看文件内容："></a>分页查看文件内容：</h4><p><code>less file.txt</code></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_5.png"></p><ul><li>按 <code>空格</code> 向下翻页，<code>b</code> 向上翻页，<code>q</code> 退出。</li><li>鼠标滚轮也可以自由滚动查看页面</li><li>按 <code>/</code> 输入关键词后回车，可向下搜索（按 <code>n</code> 跳转到下一个匹配项）。</li><li>按 <code>?</code> 输入关键词后回车，可向上搜索（按 <code>N</code> 跳转到上一个匹配项）。</li></ul><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><h5 id="N-显示行号"><a href="#N-显示行号" class="headerlink" title="-N 显示行号"></a>-N 显示行号</h5><p><code>less -N newfile.txt</code></p><h5 id="从指定行开始查看"><a href="#从指定行开始查看" class="headerlink" title="+ 从指定行开始查看"></a>+ 从指定行开始查看</h5><p><code>less +100 newfile.txt</code></p><h5 id="S-查看宽表禁用自动换行"><a href="#S-查看宽表禁用自动换行" class="headerlink" title="-S 查看宽表禁用自动换行"></a>-S 查看宽表禁用自动换行</h5><h5 id="i-搜索忽略大小写"><a href="#i-搜索忽略大小写" class="headerlink" title="-i 搜索忽略大小写"></a>-i 搜索忽略大小写</h5><p><code>less -i newfile.txt</code></p><p>进入 less 界面后，输入 <code>/ERROR</code>可匹配 <code>error</code></p><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>显示文件末尾的数据</p><p>有时候我们需要一边运行程序，一边实时观察日志打印的内容。就需要tail -f命令，它会一直监听日志变化，并实施打印日志新增内容。还可以和grep命令结合起来只打印我们感兴趣的内容。</p><h4 id="查看文件末尾数据："><a href="#查看文件末尾数据：" class="headerlink" title="查看文件末尾数据："></a>查看文件末尾数据：</h4><p><code>tail filename.txt</code></p><h4 id="查看管道输入的末尾内容："><a href="#查看管道输入的末尾内容：" class="headerlink" title="查看管道输入的末尾内容："></a>查看管道输入的末尾内容：</h4><p><code>sh xxx.sh | tail</code></p><p>将脚本的输出传递给 tail，打印出最后几次的脚本输出</p><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数</th><th>用途与示例</th></tr></thead><tbody><tr><td><code>-n &lt;行数&gt;</code></td><td>显示最后 N 行：   <code>tail -n 20 filename.txt</code><br/>（显示最后 20 行）</td></tr><tr><td><code>-f</code></td><td>实时跟踪文件更新（常用于监控日志）：   <code>tail -f app.log</code></td></tr><tr><td><code>-F</code></td><td>增强版实时跟踪（文件被轮转或删除后仍继续跟踪）：   <code>tail -F app.log</code></td></tr><tr><td><code>-q</code></td><td>静默模式（不显示多文件名称）：   <code>tail -q file1.txt file2.txt</code></td></tr><tr><td><code>-s &lt;秒数&gt;</code></td><td>设置监控间隔（与 <code>-f</code><br/> 配合使用）：   <code>tail -f -s 5 app.log</code><br/>（每 5 秒刷新）</td></tr><tr><td><code>-c &lt;字节数&gt;</code></td><td>按字节输出末尾内容：   <code>tail -c 100 filename.txt</code><br/>（显示最后 100 字节）</td></tr><tr><td><code>--pid=&lt;PID&gt;</code></td><td>与 <code>-f</code><br/> 结合，当指定进程结束时停止跟踪：   <code>tail -f --pid=1234 app.log</code></td></tr></tbody></table><h5 id="n-xx-显示最后-n-行"><a href="#n-xx-显示最后-n-行" class="headerlink" title="-n xx 显示最后 n 行"></a>-n xx 显示最后 n 行</h5><p>tail -n 10 app.log显示倒数十行</p><blockquote><p>但是数字前加上’+’就变成正向开始的十行<br><code>tail -n+10 app.log</code> 从第十行开始显示直到文件末尾<br>再配合 head 命令可以实现只输出第 n 行的效果<br><code>tail -n+10 app.log | head - 1</code><br>-1 表示只输出head接收到的数据的前1行<br>类似的，-n表示前n行</p></blockquote><h5 id="f-实时跟踪文件末尾的新增数据"><a href="#f-实时跟踪文件末尾的新增数据" class="headerlink" title="-f 实时跟踪文件末尾的新增数据"></a>-f 实时跟踪文件末尾的新增数据</h5><p><code>tail -f app.log</code></p><h5 id="F-文件被改名后仍继续跟踪"><a href="#F-文件被改名后仍继续跟踪" class="headerlink" title="-F  文件被改名后仍继续跟踪"></a>-F  文件被改名后仍继续跟踪</h5><p><code>tail -F app.log</code></p><h5 id="s-xx-每几秒刷新一次显示内容"><a href="#s-xx-每几秒刷新一次显示内容" class="headerlink" title="-s xx 每几秒刷新一次显示内容"></a>-s xx 每几秒刷新一次显示内容</h5><p><code>tail -f -s 5 app.log</code>每 5 秒刷新</p><h5 id="pid-xxx-当指定进程结束时停止显示内容"><a href="#pid-xxx-当指定进程结束时停止显示内容" class="headerlink" title="-pid&#x3D;xxx 当指定进程结束时停止显示内容"></a>-pid&#x3D;xxx 当指定进程结束时停止显示内容</h5><p><code>tail -f --pid=1234 app.log</code></p><h4 id="经典组合"><a href="#经典组合" class="headerlink" title="经典组合"></a>经典组合</h4><p>实时监控日志并显示最后 50 行：</p><p><code>tail -n 50 -f app.log</code></p><p>监控多个日志文件：</p><p><code>tail -f app.log error.log</code></p><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>vim编辑器无需多言，能把 vim 用成 ide 的人是真牛逼。</p><p>个人对 vim 的使用仅限于：</p><ul><li>-i  修改</li><li>esc 回到普通模式</li><li>:wq 退出</li><li>gg 回到开头，G 回到末尾</li></ul><h4 id="高频快捷键"><a href="#高频快捷键" class="headerlink" title="高频快捷键"></a>高频快捷键</h4><table><thead><tr><th>快捷键</th><th>用途</th></tr></thead><tbody><tr><td>移动光标</td><td></td></tr><tr><td><code>h</code><br/> <code>j</code><br/> <code>k</code><br/> <code>l</code></td><td>左、下、上、右移动。</td></tr><tr><td><code>gg</code></td><td>跳转到文件开头。</td></tr><tr><td><code>G</code></td><td>跳转到文件末尾。</td></tr><tr><td><code>0</code></td><td>跳转到行首。</td></tr><tr><td><code>$</code></td><td>跳转到行尾。</td></tr><tr><td>文本编辑</td><td></td></tr><tr><td><code>x</code></td><td>删除当前字符。</td></tr><tr><td><code>dd</code></td><td>删除整行。</td></tr><tr><td><code>yy</code></td><td>复制当前行。</td></tr><tr><td><code>p</code></td><td>粘贴到光标下一行。</td></tr><tr><td><code>u</code></td><td>撤销操作。</td></tr><tr><td><code>Ctrl + r</code></td><td>重做操作。</td></tr><tr><td>搜索替换</td><td></td></tr><tr><td><code>/关键词</code></td><td>向下搜索关键词（按 <code>n</code><br/> 跳转下一个，<code>N</code><br/> 上一个）。</td></tr><tr><td><code>?关键词</code></td><td>向上搜索关键词。</td></tr><tr><td><code>:%s/old/new/g</code></td><td>全局替换所有匹配的 <code>old</code><br/> 为 <code>new</code><br/>（需在命令行模式输入）。</td></tr></tbody></table><h4 id="命令行模式常用命令"><a href="#命令行模式常用命令" class="headerlink" title="命令行模式常用命令"></a>命令行模式常用命令</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>:w</code></td><td>保存文件。</td></tr><tr><td><code>:q</code></td><td>退出 vim。</td></tr><tr><td><code>:q!</code></td><td>强制退出不保存。</td></tr><tr><td><code>:wq</code><br/> 或 <code>:x</code></td><td>保存并退出。</td></tr><tr><td><code>:set nu</code></td><td>显示行号。</td></tr><tr><td><code>:set nonu</code></td><td>隐藏行号。</td></tr><tr><td><code>:sp 文件名</code></td><td>水平分屏打开新文件。</td></tr><tr><td><code>:vsp 文件名</code></td><td>垂直分屏打开新文件。</td></tr></tbody></table><h4 id="vimtutor"><a href="#vimtutor" class="headerlink" title="vimtutor"></a>vimtutor</h4><ul><li>输入<code>vimtutor</code> 可进入交互式教程</li></ul><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_6.png"></p><h2 id="ping-telnet-netstat-lsof-网络"><a href="#ping-telnet-netstat-lsof-网络" class="headerlink" title="ping &amp; telnet &amp; netstat &amp; lsof 网络"></a>ping &amp; telnet &amp; netstat &amp; lsof 网络</h2><p>排查网络故障也是工作中常见的场景。其中最高频的指令就是ping和telnet，它们一个用来检查主机是否连通和是否有丢包，一个用来检查端口是否连通。</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>两个作用，一个是用来检测目标网络是否连通，一个是用来检查是否存在丢包的情况。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_7.png"></p><p>连通且没有丢包</p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>用来检查目标某端口是否正常连通。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_8.png"></p><p>端口连通</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>用来显示当前主机网络状态的指令。</p><h4 id="列出本机所有正在监听的-TCP-端口，并显示对应的进程信息"><a href="#列出本机所有正在监听的-TCP-端口，并显示对应的进程信息" class="headerlink" title="列出本机所有正在监听的 TCP 端口，并显示对应的进程信息"></a>列出本机所有正在监听的 TCP 端口，并显示对应的进程信息</h4><p><code>netstat -lntp</code></p><ul><li><code>n</code> 参数表示数字，它可以让netstat以数字形式显示地址和端口号，而不是以名称的形式显示。</li><li><code>l</code> 参数表示监听，所以 <code>netstat -l</code> 会显示所有监听的socket。</li><li><code>t</code> 参数表示TCP协议，所以 <code>netstat -t</code> 只会显示TCP协议的socket。</li><li><code>p</code> 参数表示程序，所以 <code>netstat -p</code> 会显示每个socket对应的程序的信息。</li></ul><p>该指令会列出所有在监听状态的socket，并以数字形式显示地址和端口号，同时还会显示与这些socket相关的程序的信息（关注PID号）。一般用来检查主机对外开放的端口。</p><blockquote><p>Mac 系统下的该命令的 p 参数不支持不带参数</p></blockquote><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_9.png"></p><p>图中形如 10.161.102.54.56438 这样的信息表示 ip 地址是10.161.102.54，使用的端口是 56438。</p><h4 id="列出本机所有正在监听与没有监听的的-TCP-端口，并显示对应的进程信息"><a href="#列出本机所有正在监听与没有监听的的-TCP-端口，并显示对应的进程信息" class="headerlink" title="列出本机所有正在监听与没有监听的的 TCP 端口，并显示对应的进程信息"></a>列出本机所有正在监听与没有监听的的 TCP 端口，并显示对应的进程信息</h4><p><code>netstat -latp</code></p><ul><li><code>l</code> 参数表示监听，所以 <code>netstat -l</code> 会显示所有监听的socket。</li><li><code>a</code> 参数表示所有，所以 <code>netstat -a</code> 会显示所有的socket（监听的与非监听的）。</li><li><code>t</code> 参数表示TCP协议，所以 <code>netstat -t</code> 只会显示TCP协议的socket。</li><li><code>p</code> 参数表示程序，所以 <code>netstat -p</code> 会显示每个socket对应的程序的信息。</li></ul><p>因此，<code>netstat -latp</code> 会列出所有使用TCP协议的socket，无论是正在监听的还是非监听的，同时还会显示与这些socket相关的程序的信息。一般用来检查主机的所有连接。</p><blockquote><p>Mac 系统下的该命令的 p 参数不支持不带参数</p></blockquote><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_10.png"></p><h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><p>lsof全称是List Open Files，用来列出系统中被打开的文件。因为Linux中一切皆文件，所以这个命令可以查看很多信息，比如进程打开的普通文件、目录、网络连接、设备等。</p><h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><h5 id="u-查看指定用户打开的文件"><a href="#u-查看指定用户打开的文件" class="headerlink" title="-u 查看指定用户打开的文件"></a>-u 查看指定用户打开的文件</h5><p><code>lsof -u root</code></p><h5 id="p-查看指定进程打开的文件"><a href="#p-查看指定进程打开的文件" class="headerlink" title="-p 查看指定进程打开的文件"></a>-p 查看指定进程打开的文件</h5><p><code>lsof -p 1234</code></p><h5 id="i-查看指定端口的占用"><a href="#i-查看指定端口的占用" class="headerlink" title="-i 查看指定端口的占用"></a>-i 查看指定端口的占用</h5><p><code>lsof -i 8080</code></p><p>查看占用 80 端口的进程</p><h5 id="c-按进程名过滤"><a href="#c-按进程名过滤" class="headerlink" title="-c 按进程名过滤"></a>-c 按进程名过滤</h5><p><code>lsof -c nginx</code></p><p>查看进程名包含 “nginx” 的文件</p><h4 id="其它用法"><a href="#其它用法" class="headerlink" title="其它用法"></a>其它用法</h4><h5 id="查看指定文件或目录的占用"><a href="#查看指定文件或目录的占用" class="headerlink" title="查看指定文件或目录的占用"></a>查看指定文件或目录的占用</h5><p>查看正在读写 syslog 的进程</p><p><code>lsof /var/log/syslog</code></p><h2 id="ps-top-df-systemctl-系统"><a href="#ps-top-df-systemctl-系统" class="headerlink" title="ps &amp; top &amp; df &amp; systemctl 系统"></a>ps &amp; top &amp; df &amp; systemctl 系统</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p><code>ps</code>（Process Status）用于查看当前系统中的进程状态，可显示进程 ID（PID）、资源占用、运行状态等信息</p><h4 id="查看当前终端的进程："><a href="#查看当前终端的进程：" class="headerlink" title="查看当前终端的进程："></a>查看当前终端的进程：</h4><p><code>ps</code></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_11.png"></p><h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><h5 id="e-选择所有进程"><a href="#e-选择所有进程" class="headerlink" title="-e  选择所有进程"></a><code>-e</code>  选择所有进程</h5><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_12.png"></p><h5 id="f-全格式列表"><a href="#f-全格式列表" class="headerlink" title="-f  全格式列表"></a><code>-f</code>  全格式列表</h5><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_13.png"></p><h5 id="p-xxx-显示指定进程的信息"><a href="#p-xxx-显示指定进程的信息" class="headerlink" title="-p xxx  显示指定进程的信息"></a><code>-p xxx</code>  显示指定进程的信息</h5><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_14.png"></p><h5 id="o-xxx-允许用户指定想要查看的进程信息字段"><a href="#o-xxx-允许用户指定想要查看的进程信息字段" class="headerlink" title="-o xxx 允许用户指定想要查看的进程信息字段"></a><code>-o xxx</code> 允许用户指定想要查看的进程信息字段</h5><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_15.png"></p><h4 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h4><h5 id="ps-ef"><a href="#ps-ef" class="headerlink" title="ps -ef"></a><code>ps -ef</code></h5><p><code>ps -ef</code> 命令以全格式显示所有进程的状态信息，这将包括每个进程的id，父进程的id，CPU和内存的使用情况，开始时间，运行时间，所属用户，命令行等信息。再使用grep来筛选我们该兴趣的东西。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_16.png"></p><h5 id="ps-fp-xxx"><a href="#ps-fp-xxx" class="headerlink" title="ps -fp xxx"></a><code>ps -fp xxx</code></h5><p><code>ps -fp xxx</code>该命令会列出 pid 为 xxx 的进程的详细信息：</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_17.png"></p><h5 id="ps-fp-xxx-o-yyyy-zzz"><a href="#ps-fp-xxx-o-yyyy-zzz" class="headerlink" title="ps -fp xxx -o yyyy=zzz"></a><code>ps -fp xxx -o yyyy=zzz</code></h5><p><code>ps -fp xxx -o yyyy=zzz</code> 输出 pid 为 xxx 的进程的 yyyy 字段信息，命名为 zzz</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_18.png"></p><p>都是用来查看系统资源占用的指令，top指令主要用来查看系统CPU占用、内存占用和负载。df指令只要用来查看系统磁盘占用。</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>直接输入，就会实时刷新当前系统的CPU、内存、负载占用情况。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_19.png"></p><h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><h5 id="p-显示指定进程的资源占用情况"><a href="#p-显示指定进程的资源占用情况" class="headerlink" title="-p 显示指定进程的资源占用情况"></a>-p 显示指定进程的资源占用情况</h5><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_20.png"></p><blockquote><p>Mac 系统中 p 参数叫 pid</p></blockquote><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_21.png"></p><h5 id="o-xxx-按指定字段降序排序"><a href="#o-xxx-按指定字段降序排序" class="headerlink" title="-o xxx 按指定字段降序排序"></a>-o xxx 按指定字段降序排序</h5><p><code>top -o MEM</code></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_22.png"></p><h3 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h3><p>以更直观的方式显示进程占用资源情况。其gui 界面支持通过点击实现排序、搜索等功能。</p><p>这个命令 Mac 默认不支持，需要通过 <code>brew install htop</code>安装。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_23.png"></p><h3 id="df-h"><a href="#df-h" class="headerlink" title="df -h"></a>df -h</h3><p>以人类可读的方式打印机器磁盘占用情况。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_24.png"></p><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>看、控制系统服务的运行情况</p><p>如：<code>systemctl restart nginx</code> <code>systemctl stop nginx</code> <code>systemctl start nginx</code></p><h2 id="重定向操作符"><a href="#重定向操作符" class="headerlink" title="重定向操作符 &gt; &amp; &gt;&gt;"></a>重定向操作符 &gt; &amp; &gt;&gt;</h2><p>两个重定向操作符，不同的是 &gt; 会覆盖源文件，&gt;&gt; 会追加到源文件尾部。</p><h3 id="bash-xx-sh-xxx-log"><a href="#bash-xx-sh-xxx-log" class="headerlink" title="bash xx.sh &gt; xxx.log"></a>bash xx.sh &gt; xxx.log</h3><p>运行名为 <code>xx.sh</code> 的 shell 脚本，并将该脚本的输出以覆盖写的方式输出到 <code>xxx.log</code> 文件中。</p><h3 id="bash-xx-sh-xxx-log-1"><a href="#bash-xx-sh-xxx-log-1" class="headerlink" title="bash xx.sh &gt;&gt; xxx.log"></a>bash xx.sh &gt;&gt; xxx.log</h3><p>运行名为 <code>xx.sh</code> 的 shell 脚本，并将该脚本的输出以追加写的方式输出到 <code>xxx.log</code> 文件中。</p><h2 id="其它工具命令"><a href="#其它工具命令" class="headerlink" title="其它工具命令"></a>其它工具命令</h2><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>用于处理结构化文本数据（如按列分隔的文本）。</p><p>这个命令有点复杂，模板大概是：</p><p><code>awk [参数] &#39;条件 &#123;动作&#125;&#39; 文件名</code></p><h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><h5 id="F-指定字段分隔符"><a href="#F-指定字段分隔符" class="headerlink" title="-F 指定字段分隔符"></a>-F 指定字段分隔符</h5><p><code>awk -F &#39;,&#39; &#39;&#123;print $1&#125;&#39; data.csv</code>（按逗号分隔）</p><h5 id="v-定义变量"><a href="#v-定义变量" class="headerlink" title="-v 定义变量"></a>-v 定义变量</h5><p><code>awk -v name=John &#39;&#123;print name, $1&#125;&#39; file.txt</code></p><h5 id="f-用指定脚本处理文件"><a href="#f-用指定脚本处理文件" class="headerlink" title="-f 用指定脚本处理文件"></a>-f 用指定脚本处理文件</h5><p><code>awk -f script.awk data.txt</code></p><p>用<code>script.awk</code> 中定义的规则来处理文件 <code>data.txt</code></p><h4 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h4><ul><li>NR：当前处理的行号,多个文件会累积。如file1.txt 有 8 行，file2.txt 的第 2 行对应全局的第 10 行</li><li>FNR：当前处理的某文件的行号，每个文件单独计数</li><li>NF：当前行的字段数量</li><li>FS：输入字段分隔符（默认空格）</li><li>OFS：输出字段分隔符（默认空格）</li><li>FILENAME：当前处理的文件名</li></ul><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><h5 id="提取字段"><a href="#提取字段" class="headerlink" title="提取字段"></a>提取字段</h5><h6 id="打印第一列"><a href="#打印第一列" class="headerlink" title="打印第一列"></a>打印第一列</h6><p><code>awk &#39;&#123;print $1&#125;&#39; file.txt</code></p><h6 id="打印最后一列"><a href="#打印最后一列" class="headerlink" title="打印最后一列"></a>打印最后一列</h6><p><code>awk &#39;&#123;print $NF&#125;&#39; file.txt</code></p><h5 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h5><h6 id="打印第三列大于-100-的行"><a href="#打印第三列大于-100-的行" class="headerlink" title="打印第三列大于 100 的行"></a>打印第三列大于 100 的行</h6><p><code>awk &#39;$3 &gt; 100 &#123;print $0&#125;&#39; data.txt</code></p><h6 id="匹配包含关键词的行："><a href="#匹配包含关键词的行：" class="headerlink" title="匹配包含关键词的行："></a>匹配包含关键词的行：</h6><p><code>awk &#39;/error/ &#123;print $0&#125;&#39; log.txt</code></p><h5 id="计算与统计"><a href="#计算与统计" class="headerlink" title="计算与统计"></a>计算与统计</h5><h6 id="计算第一列的总和："><a href="#计算第一列的总和：" class="headerlink" title="计算第一列的总和："></a>计算第一列的总和：</h6><p><code>awk &#39;&#123;sum += $1&#125; END &#123;print sum&#125;&#39; data.txt</code></p><h6 id="统计行数："><a href="#统计行数：" class="headerlink" title="统计行数："></a>统计行数：</h6><p><code>awk &#39;END &#123;print NR&#125;&#39; file.txt</code></p><h5 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h5><h6 id="调整列顺序并添加分隔符"><a href="#调整列顺序并添加分隔符" class="headerlink" title="调整列顺序并添加分隔符"></a>调整列顺序并添加分隔符</h6><p><code>awk &#39;&#123;print $2 &quot; : &quot; $1&#125;&#39; file.txt</code></p><h6 id="输出表头"><a href="#输出表头" class="headerlink" title="输出表头"></a>输出表头</h6><p><code>awk &#39;&#123;print $2 &quot; : &quot; $1&#125;&#39; file.txt</code></p><h6 id="管道格式化输出"><a href="#管道格式化输出" class="headerlink" title="管道格式化输出"></a>管道格式化输出</h6><p><code>ps -p 40808 -o rss= | awk &#39;&#123;printf&quot;%.2f MB \n&quot; , $1 / 1024&#125;&#39;</code></p><p>将 rss 字段的数值传递给 awk 命令，在 awk 中使用$1 捕获第一个数，因为管道只传递了一个数过来，所以$1捕获的数一定是 rss 字段的值。</p><p>将 rss 字段的值除以 1024 后作为 printf 的参数去打印。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_25.png"></p><p>注意，printf 中如果不换行会莫名奇妙打印一个百分号%。</p><h6 id="打印文件的第十行"><a href="#打印文件的第十行" class="headerlink" title="打印文件的第十行"></a>打印文件的第十行</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;FNR == 10 &#123;print &#125;&#x27;  file.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">awk “用于逐行读取文件”</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">FNR == 10 “FNR 表示当前文件的行号（针对每个文件单独计数）。FNR == 10 意味着当当前行号是第 10 行”</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&#123;<span class="built_in">print</span>&#125; “打印当前行内容”</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file.txt “输入文件，awk 将逐行读取该文件的内容”</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">FNR 与 NR 的区别，如下面shell：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">awk <span class="string">&#x27;FNR == 10 &#123;print &#125;&#x27;</span> file1.txt file2.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">FNR 是针对每个文件单独计数，因此会打印每个文件的第 10 行。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果改用 NR，则 NR 是全局行号，会根据所有文件的行数累计。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如，file1.txt 有 8 行，file2.txt 的第 2 行对应全局的第 10 行。</span></span><br><span class="line"></span><br><span class="line">作者：疯子</span><br><span class="line">链接：https://leetcode.cn/problems/tenth-line/solutions/2996353/195-xiang-jie-4fen-shell-by-fengzil-brw0/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>也可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | awk -F &#x27;\n&#x27; &#x27;&#123;</span><br><span class="line">    if(NR == 10) &#123;</span><br><span class="line">        print $1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure><p>将每一行的内容作为一个整体，如果当前处理的行数等于10就打印</p><h6 id="转置文件"><a href="#转置文件" class="headerlink" title="转置文件"></a>转置文件</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123; #这个大括号里的代码是 对正文的处理</span><br><span class="line">    # NF表示列数，NR表示已读的行数</span><br><span class="line">    # 注意for中的i从1开始，i前没有类型</span><br><span class="line">    for (i=1; i&lt;=NF; i++)&#123;#对每一列</span><br><span class="line">        if(NR==1)&#123;       #如果是第一行</span><br><span class="line">            #将第i列的值存入res[i],$i表示第i列的值，i为数组的下标，以列序号为下标，</span><br><span class="line">            #数组不用定义可以直接使用</span><br><span class="line">            res[i]=$i;   </span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            #不是第一行时，将该行对应i列的值拼接到res[i]</span><br><span class="line">            res[i]=res[i] &quot; &quot; $i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BEGIN&#123;&#125; 文件进行扫描前要执行的操作；END&#123;&#125; 文件扫描结束后要执行的操作。</span></span><br><span class="line">END&#123;</span><br><span class="line">    #输出数组</span><br><span class="line">for (i=1; i&lt;=NF; i++)&#123;</span><br><span class="line">print res[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><h4 id="1-简单关键字搜索"><a href="#1-简单关键字搜索" class="headerlink" title="1. 简单关键字搜索"></a>1. 简单关键字搜索</h4><p>在 file.txt 中搜索 “keyword”</p><p><code>grep &quot;keyword&quot; file.txt</code> </p><p>在多个文件中搜索 keyword</p><p><code>grep &quot;keyword&quot; file1 file2</code> </p><h4 id="2-忽略大小写（-i）"><a href="#2-忽略大小写（-i）" class="headerlink" title="2. 忽略大小写（-i）"></a>2. 忽略大小写（<code>-i</code>）</h4><p><code>grep -i &quot;error&quot; app.log</code></p><h4 id="3-反向匹配（-v）"><a href="#3-反向匹配（-v）" class="headerlink" title="3. 反向匹配（-v）"></a>3. 反向匹配（<code>-v</code>）</h4><p>输出不包含 “success” 的行</p><p><code>grep -v &quot;success&quot; data.csv </code></p><h4 id="4-统计匹配次数（-c）"><a href="#4-统计匹配次数（-c）" class="headerlink" title="4. 统计匹配次数（-c）"></a>4. 统计匹配次数（<code>-c</code>）</h4><p>输出包含 “warning” 的行数</p><p><code>grep -c &quot;warning&quot; app.log</code></p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>进入某目录</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>列出当前目录下的文件夹和文件</p><p><code>ls -a</code>可以显示隐藏的文件</p><p><code>ls -l</code>可以显示包括文件权限、所有者、修改时间等更多隐藏信息</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-03-21-%E5%B8%B8%E7%94%A8%E7%9A%84linux%E5%91%BD%E4%BB%A4/img_26.png"></p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除某目录或某文件</p><p>加上-f 参数可强制删除</p><p>加上-r 参数可以递归删除某目录下的所有文件</p><blockquote><p>快进到 <code>rm -rf /*</code> 跑路</p></blockquote><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>移动文件或目录到指定目录</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>修改某文件或某目录的权限</p><p><code>chmod 755 script.sh</code>   # 用户：rwx，组和其他：r-x</p><blockquote><p>linux 系统中用八进制表示权限。</p><p>权限共有三种，r(读),w(写),x(执行)</p><p>对应的值分别是 4,2,1。</p><p>如某用户对 script.sh 的权限是 6，即该用户对 script.sh 拥有读写权限（4 + 2 &#x3D; 6），但不拥有执行权限。</p><p>chmod 命令中包含一个三位数，从高位到低位分别表示用户、文件所属用户组、其它用户三类账户对 script.sh 文件拥有的权限。</p><p>chmod 755 script.sh 表示让</p><p>用户拥有读写以及执行权限，</p><p>文件所属用户组拥有读和执行权限，</p><p>其它用户拥有读和执行权限。</p></blockquote><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建名为 qwer 的目录</p><p><code>mkdir qwer</code></p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>创建名为 qwer.txt 的空文件</p><p><code>touch qwer.txt</code></p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p><code>kill -9 30987</code> 强制终止 pid &#x3D; 30987 的进程</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell的一些简单语法</title>
      <link href="/2025/03/20/2025-03-20-shell%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/20/2025-03-20-shell%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/zsh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">函数</span></span><br><span class="line">is_prime() &#123;</span><br><span class="line">    local num=$1</span><br><span class="line">    if [ $num -lt 2 ]; then</span><br><span class="line">        return 1 # 返回false</span><br><span class="line">    fi # 表示if代码块的结束</span><br><span class="line">    for ((i=2; i*i&lt;=num; i++)); do</span><br><span class="line">        if [ $((num % i)) -eq 0 ]; then</span><br><span class="line">            return 1 # 返回false</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">    return 0 # # 返回true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;请输入一个正整数：&quot; number</span><br><span class="line"></span><br><span class="line">if is_prime $number; then</span><br><span class="line">    echo &quot;$number 是素数。&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;$number 不是素数。&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="1-Shebang-bin-zsh"><a href="#1-Shebang-bin-zsh" class="headerlink" title="1. Shebang (#!/bin/zsh)"></a>1. Shebang (<code>#!/bin/zsh</code>)</h3><ul><li><code>#!/bin/zsh</code> 是脚本的第一行，称为 Shebang。</li><li>它指定了脚本使用的解释器，这里是 <code>zsh</code>。</li><li>当脚本运行时，操作系统会使用 <code>/bin/zsh</code> 来执行脚本。</li></ul><hr><h3 id="2-函数定义-is-prime"><a href="#2-函数定义-is-prime" class="headerlink" title="2. 函数定义 (is_prime)"></a>2. 函数定义 (<code>is_prime</code>)</h3><ul><li>使用 <code>function_name() &#123; ... &#125;</code> 的语法定义了一个函数。</li><li>函数名是 <code>is_prime</code>，它接受一个参数 <code>$1</code>（即传递给函数的第一个参数）。</li><li>函数体用 <code>&#123; ... &#125;</code> 包裹。</li></ul><hr><h3 id="3-局部变量-local-num-1"><a href="#3-局部变量-local-num-1" class="headerlink" title="3. 局部变量 (local num=$1)"></a>3. 局部变量 (<code>local num=$1</code>)</h3><ul><li><code>local</code> 关键字用于声明局部变量，变量的作用域仅限于函数内部。shell 的变量默认在脚本内是全局的</li><li><code>num=$1</code> 将函数的第一个参数赋值给变量 <code>num</code>。</li><li>注意在shell中，等号’&#x3D;’的两边不能有空格</li></ul><hr><h3 id="4-条件判断-if-num-lt-2-then"><a href="#4-条件判断-if-num-lt-2-then" class="headerlink" title="4. 条件判断 (if [ $num -lt 2 ]; then)"></a>4. 条件判断 (<code>if [ $num -lt 2 ]; then</code>)</h3><ul><li><code>if</code> 是条件判断语句，用于检查条件是否为真。</li><li><code>[ ... ]</code> 是 Shell 中的条件测试语法（等同于 <code>test</code> 命令）。</li><li><code>-lt</code> 是数值比较运算符，表示“小于”（less than）。类似的比较符还有-gt,-eq,-ge等等，和mybatisPlus很像</li><li><code>if [ $num -lt 2 ]; then</code> 的意思是“如果 <code>$num</code> 的值小于 2”。</li><li>注意 []两边必须留出一个空格</li></ul><h4 id="1-if-的语法"><a href="#1-if-的语法" class="headerlink" title="1. if [ ... ] 的语法"></a>1. <code>if [ ... ]</code> 的语法</h4><ul><li><code>[ ... ]</code> 是 Shell 中的条件测试语法（等同于 <code>test</code> 命令）。</li><li>在 <code>[ ... ]</code> 中，变量需要加上 <code>$</code> 符号来引用其值。</li><li>注意两边必须留出一个空格</li></ul><h4 id="2-if-的语法"><a href="#2-if-的语法" class="headerlink" title="2. if (( ... )) 的语法"></a>2. <code>if (( ... ))</code> 的语法</h4><ul><li><code>(( ... ))</code> 是 Shell 中的算术运算语法。</li><li>在 <code>(( ... ))</code> 中，变量名可以直接使用，不需要加 <code>$</code> 符号。</li></ul><hr><h3 id="5-返回值-return-1-和-return-0"><a href="#5-返回值-return-1-和-return-0" class="headerlink" title="5. 返回值 (return 1 和 return 0)"></a>5. 返回值 (<code>return 1</code> 和 <code>return 0</code>)</h3><ul><li><code>return</code> 用于从函数中返回值。</li><li>在 Shell 中，<code>0</code> 表示成功（真），非 <code>0</code> 值表示失败（假）。</li><li><code>return 1</code> 表示函数返回“不是素数”，<code>return 0</code> 表示函数返回“是素数”。</li></ul><blockquote><p>shell 的函数不能 return true 或者 false。只能用数字来表示 true&#x2F;false。</p><ul><li><code>0</code> 表示 true。</li><li>非 <code>0</code> 值表示 false。</li></ul></blockquote><hr><h3 id="6-循环-for-i-2-i-i"><a href="#6-循环-for-i-2-i-i" class="headerlink" title="6. 循环 (for ((i=2; i*i&lt;=num; i++)); do)"></a>6. 循环 (<code>for ((i=2; i*i&lt;=num; i++)); do</code>)</h3><ul><li><code>for (( ... ))</code> 是 C 风格的 <code>for</code> 循环语法，就不过多解释了。</li><li><code>do</code> 和 <code>done</code> 之间的代码是循环体。</li></ul><hr><h3 id="7-算术运算-num-i"><a href="#7-算术运算-num-i" class="headerlink" title="7. 算术运算 ($((num % i)))"></a>7. 算术运算 (<code>$((num % i))</code>)</h3><ul><li><code>$(( ... ))</code> 是 Shell 中的算术运算语法。</li><li><code>num % i</code> 计算 <code>num</code> 除以 <code>i</code> 的余数。</li><li><code>-eq 0</code> 是条件测试，检查余数是否等于 0。</li><li>也可以改为 <code>if((num % i == 0))</code></li></ul><hr><h3 id="8-用户输入-read-p-请输入一个正整数：-number"><a href="#8-用户输入-read-p-请输入一个正整数：-number" class="headerlink" title="8. 用户输入 (read -p &quot;请输入一个正整数：&quot; number)"></a>8. 用户输入 (<code>read -p &quot;请输入一个正整数：&quot; number</code>)</h3><ul><li><code>read</code> 命令用于从标准输入读取用户输入。</li><li><code>-p</code> 选项用于显示提示信息（<code>&quot;请输入一个正整数：&quot;</code>）。</li><li>用户输入的值会被存储在变量 <code>number</code> 中。</li></ul><hr><h3 id="9-函数调用-if-is-prime-number-then"><a href="#9-函数调用-if-is-prime-number-then" class="headerlink" title="9. 函数调用 (if is_prime $number; then)"></a>9. 函数调用 (<code>if is_prime $number; then</code>)</h3><ul><li><code>is_prime $number</code> 调用 <code>is_prime</code> 函数，并将 <code>number</code> 作为参数传递。</li><li>函数的返回值决定了 <code>if</code> 语句的执行逻辑。</li></ul><hr><h3 id="10-条件分支-if-then-else-fi"><a href="#10-条件分支-if-then-else-fi" class="headerlink" title="10. 条件分支 (if ... then ... else ... fi)"></a>10. 条件分支 (<code>if ... then ... else ... fi</code>)</h3><ul><li><code>if ... then ... else ... fi</code> 是 Shell 中的条件分支语句。</li><li>如果 <code>if</code> 条件为真，执行 <code>then</code> 后面的代码块。</li><li>如果 <code>if</code> 条件为假，执行 <code>else</code> 后面的代码块。</li><li><code>fi</code> 表示 <code>if</code> 语句的结束。</li></ul><hr><h3 id="11-输出-echo-number-是素数。"><a href="#11-输出-echo-number-是素数。" class="headerlink" title="11. 输出 (echo &quot;$number 是素数。&quot;)"></a>11. 输出 (<code>echo &quot;$number 是素数。&quot;</code>)</h3><ul><li><code>echo</code> 命令用于输出文本到标准输出。</li><li><code>&quot;$number 是素数。&quot;</code> 是输出的字符串，<code>$number</code> 会被替换为变量的值。</li></ul><hr><h3 id="12-全局变量"><a href="#12-全局变量" class="headerlink" title="12. 全局变量"></a>12. 全局变量</h3><p>shell 中使用 $来引用全局变量，如 zsh 中的配置文件.zshrc 会配置很多全局变量，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/Users/xyhao/Library/Java/JavaVirtualMachines/corretto-11.0.26/Contents/Home</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.</span><br></pre></td></tr></table></figure><p>那么在 shell 脚本中就能直接用$JAVA_HOME 来得到&#x2F;Users&#x2F;xyhao&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;corretto-11.0.26&#x2F;Contents&#x2F;Home这个字符串。</p><p>这也可以解释为什么配置好了 Java 环境后，在任何一个目录的命令行里输入 <code>java -v</code>就可以打印出 Java 的版本，因为JAVA_HOME 被注册为了全局变量</p>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaDoc</title>
      <link href="/2025/02/17/2025-02-17-JavaDoc/"/>
      <url>/2025/02/17/2025-02-17-JavaDoc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以前实习的时候，组里的代码很少有注释，理解起来着实难受。mentor 可能会说：”不懂的问我，随便问”，但人家只是客气，你要是真随便问就输了。</p><p>因此，我写代码尽量带有完整的 <code>JavaDoc</code> 注释。</p><p>如果不做二次开发，个人觉得其实没必要理解一部分代码的实现逻辑。通过完整的 JavaDoc 了解每个方法在做什么，结合调用链路梳理逻辑，就差不多理解业务了。</p><p>有人可能会说：良好的代码本身就是一种注释。可是大部分人的代码命名水平实在不怎么高(包括我)，变量名中混入拼音首字母缩写的大有人在，有一种 yyds 的美。</p><p>而且不是每个人的代码都优雅、简洁的能让大一新生看懂。如果做不到，还是好好写注释吧。</p><p>但是话又说回来，如果你的目的是防御性编程，增强自己不可替代的地位，那确实没必要写 JavaDoc。</p></blockquote><h2 id="类名-JavaDoc"><a href="#类名-JavaDoc" class="headerlink" title="类名 JavaDoc"></a>类名 JavaDoc</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个展示如何使用详细JavaDoc注释的示例类。</span></span><br><span class="line"><span class="comment"> * 此类提供文件读取功能以及一些辅助方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xyhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #readFileContent(String)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #printMessage(String</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span> 使用 &#123;<span class="doctag">@link</span> String&#125;代替，因为它·······</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleClass</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@author</code> 作者是谁</li><li><code>@since</code> 从项目的哪个版本引入的</li><li><code>@version</code>  该类迭代了几个版本</li><li><code>@see</code> 与该类相关联的类、方法、或者 URL</li><li><code>@deprecated</code> 该类若准备删除，可以用这个标签表示。但是要给出删除之后的替代方案。</li></ul><p>但其实这只对完美的、非常规范的开发流程生效，一般而言，用 <code>@author</code> 标签记录负责人就足够了。</p><h2 id="方法名-JavaDoc"><a href="#方法名-JavaDoc" class="headerlink" title="方法名 JavaDoc"></a>方法名 JavaDoc</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取指定文件的内容并返回其内容作为一个字符串。</span></span><br><span class="line"><span class="comment"> * 如果在读取过程中发生I/O错误，则会抛出IOException。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encoding 文件编码格式。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;  返回文件的内容作为字符串。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.nio.file.Files#readAllBytes(java.nio.file.Path)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 如果发生输入输出错误（如文件未找到或无法读取）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readFileContent</span><span class="params">(String encoding)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 示例代码，实际实现被省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@param</code> 表示方法参数的含义</li><li><code>@return</code> 返回值的含义</li><li><code>@since</code> 从项目的哪个版本开始引入</li><li><code>@see</code> 标记与该方法相关的类、方法、URL 等</li><li><code>@throws</code> 如果该方法有抛出异常的可能，用该标签标记异常类型（引申：什么时候抛出异常，什么时候捕获异常？）</li></ul><p>方法返回类型一眼就可以看到， 真的需要<code>return</code> 标签吗？</p><p>假设你对这个方法一点也不了解，当然也不了解这个方法返回值的具体含义，如果有个 <code>return</code> 标签解释了返回值的具体含义，这不是一件很好的事吗？</p><h2 id="成员变量-JavaDoc"><a href="#成员变量-JavaDoc" class="headerlink" title="成员变量 JavaDoc"></a>成员变量 JavaDoc</h2><p>通常对于成员变量而言，只需使用无标签的文本描述即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储用于加密用户密码的盐值。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 盐值是一个随机生成的字符串，它被添加到原始密码中以增加哈希算法的安全性。</span></span><br><span class="line"><span class="comment"> * 通过使用不同的盐值，即使两个用户拥有相同的密码，它们的哈希结果也会不同，</span></span><br><span class="line"><span class="comment"> * 这样可以有效防止彩虹表攻击等常见的密码破解技术。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 在创建新账户或更改密码时会生成一个新的盐值，并且该盐值将与加密后的密码一起存储。</span></span><br><span class="line"><span class="comment"> * 当验证用户输入的密码时，需要使用相同的盐值重新计算哈希值并与存储的哈希值进行比较。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String salt;</span><br></pre></td></tr></table></figure><p>但为了便于后来者理解，用 <code>@see</code> 标签关联相关信息也可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储用于加密用户密码的盐值。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 盐值是一个随机生成的字符串，它被添加到原始密码中以增加哈希算法的安全性。</span></span><br><span class="line"><span class="comment"> * 通过使用不同的盐值，即使两个用户拥有相同的密码，它们的哈希结果也会不同，</span></span><br><span class="line"><span class="comment"> * 这样可以有效防止彩虹表攻击等常见的密码破解技术。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 在创建新账户或更改密码时会生成一个新的盐值，并且该盐值将与加密后的密码一起存储。</span></span><br><span class="line"><span class="comment"> * 当验证用户输入的密码时，需要使用相同的盐值重新计算哈希值并与存储的哈希值进行比较。</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> &lt;a href=&quot;https://baike.baidu.com/item/salt%E5%80%BC/15931315&quot;&gt;百度百科：盐值是什么？&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String salt;</span><br></pre></td></tr></table></figure><h2 id="如何在-JavaDoc-中引用方法、类、成员变量、URL？"><a href="#如何在-JavaDoc-中引用方法、类、成员变量、URL？" class="headerlink" title="如何在 JavaDoc 中引用方法、类、成员变量、URL？"></a>如何在 JavaDoc 中引用方法、类、成员变量、URL？</h2><p>看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户账户的基本信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该类提供了用户账户的基本功能，包括密码加密和存储安全相关的属性。</span></span><br><span class="line"><span class="comment"> * 加密操作依靠 &#123;<span class="doctag">@link</span> java.security.MessageDigest&#125; 实现</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xyhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025-02-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #hashPasswordWithSalt(String,String)  引用本类的有参方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.util.HashMap#size()  引用别的类的无参方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #salt  引用成员变量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> &lt;a href=&quot;https://baike.baidu.com/item/salt%E5%80%BC/15931315&quot;&gt;百度百科：盐值是什么？&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">hashPasswordWithSalt</span><span class="params">(String password, String salt)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">            <span class="comment">// 将盐值和密码组合起来</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">beforeHash</span> <span class="operator">=</span> salt + password;</span><br><span class="line">            <span class="type">byte</span>[] hashedBytes = md.digest(beforeHash.getBytes());</span><br><span class="line">            <span class="comment">// 将字节数组转换为Base64编码的字符串</span></span><br><span class="line">            passwordHash = Base64.getEncoder().encodeToString(hashedBytes);</span><br><span class="line">            <span class="keyword">return</span> passwordHash;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;无法找到SHA-256算法&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><hr><br><p>上文中所有的 JavaDoc 都遵守着这样的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="comment"> * xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="comment"> * xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="comment"> * xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@xxx</span> xxxxxxxxxxxxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@xxx</span> xxxxxxxxxxxxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@xxx</span> xxxxxxxxxxxxx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@xxx</span> xxxxxxxxxxxxx</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>但其实除了第一行和最后一行的 <code>*</code>外，其他行开头的 <code>*</code>并不是必须的。</p><p>有人说带上 <code>*</code>格式更整洁？可读性更高？</p><p>那是不是觉得多行字符串的这种写法也很整洁，可读性更高呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;    &lt;body&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;        &lt;p&gt;Hello, World!&lt;/p&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;    &lt;/body&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>有下面的整洁吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK15开始引入的多行文本表达式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              &lt;html&gt;</span></span><br><span class="line"><span class="string">                  &lt;body&gt;</span></span><br><span class="line"><span class="string">                      &lt;p&gt;Hello, World!&lt;/p&gt;</span></span><br><span class="line"><span class="string">                  &lt;/body&gt;</span></span><br><span class="line"><span class="string">              &lt;/html&gt;</span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><br><hr><br><p>完整示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 用户账户的基本信息。</span></span><br><span class="line"><span class="comment"> 该类提供了用户账户的基本功能，包括密码加密和存储安全相关的属性。</span></span><br><span class="line"><span class="comment"> 依靠 &#123;<span class="doctag">@link</span> java.security.MessageDigest&#125; 实现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@author</span> xyhao</span></span><br><span class="line"><span class="comment"> <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> <span class="doctag">@since</span> 3.2</span></span><br><span class="line"><span class="comment"> <span class="doctag">@see</span> #hashPasswordWithSalt(String,String)</span></span><br><span class="line"><span class="comment"> <span class="doctag">@see</span> java.util.HashMap#size()</span></span><br><span class="line"><span class="comment"> <span class="doctag">@see</span> #salt</span></span><br><span class="line"><span class="comment"> <span class="doctag">@see</span> &lt;a href=&quot;https://baike.baidu.com/item/salt%E5%80%BC/15931315&quot;&gt;百度百科：盐值是什么？&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     存储用于加密用户密码的盐值。</span></span><br><span class="line"><span class="comment">     &lt;p&gt;</span></span><br><span class="line"><span class="comment">     盐值是一个随机生成的字符串，它被添加到原始密码中以增加哈希算法的安全性。</span></span><br><span class="line"><span class="comment">     通过使用不同的盐值，即使两个用户拥有相同的密码，它们的哈希结果也会不同，</span></span><br><span class="line"><span class="comment">     这样可以有效防止彩虹表攻击等常见的密码破解技术。</span></span><br><span class="line"><span class="comment">     &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     &lt;p&gt;</span></span><br><span class="line"><span class="comment">     在创建新账户或更改密码时会生成一个新的盐值，并且该盐值将与加密后的密码一起存储。</span></span><br><span class="line"><span class="comment">     当验证用户输入的密码时，需要使用相同的盐值重新计算哈希值并与存储的哈希值进行比较。</span></span><br><span class="line"><span class="comment">     &lt;/p&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     <span class="doctag">@see</span> #generateSalt()</span></span><br><span class="line"><span class="comment">     <span class="doctag">@see</span> #encryptPassword(String)</span></span><br><span class="line"><span class="comment">     <span class="doctag">@see</span> &lt;a href=&quot;https://baike.baidu.com/item/salt%E5%80%BC/15931315&quot;&gt;百度百科：盐值是什么？&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     存储加密后的密码哈希值。</span></span><br><span class="line"><span class="comment">     &lt;p&gt;</span></span><br><span class="line"><span class="comment">     密码哈希值是通过对用户提供的原始密码和盐值组合后，使用SHA-256算法计算得出的。</span></span><br><span class="line"><span class="comment">     它用于在登录时验证用户输入的密码是否正确。</span></span><br><span class="line"><span class="comment">     &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String passwordHash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     这个方法的方法名和参数名配合起来非常简洁明了，没啥必要写文本注释</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     <span class="doctag">@param</span> password 用户提供的原始密码。</span></span><br><span class="line"><span class="comment">     <span class="doctag">@return</span> 加密后的密码哈希值。</span></span><br><span class="line"><span class="comment">     <span class="doctag">@see</span> #generateSalt()</span></span><br><span class="line"><span class="comment">     <span class="doctag">@see</span> #hashPasswordWithSalt(String, String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encryptPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有设置盐值，则生成一个新的盐值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.salt == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.salt = generateSalt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashPasswordWithSalt(password, <span class="built_in">this</span>.salt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     这个方法的方法名非常简洁明了，没啥必要写文本注释</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     <span class="doctag">@return</span> Base64编码的盐值字符串。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">generateSalt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="type">byte</span>[] saltBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">        random.nextBytes(saltBytes);</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(saltBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     这个方法的方法名和参数名配合起来非常简洁明了，没啥必要写文本注释</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     <span class="doctag">@param</span> password 用户提供的原始密码。</span></span><br><span class="line"><span class="comment">     <span class="doctag">@param</span> salt 盐值字符串。</span></span><br><span class="line"><span class="comment">     <span class="doctag">@return</span> 基于SHA-256算法的哈希结果。</span></span><br><span class="line"><span class="comment">     <span class="doctag">@throws</span> IllegalStateException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">hashPasswordWithSalt</span><span class="params">(String password, String salt)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">            <span class="comment">// 将盐值和密码组合起来</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">beforeHash</span> <span class="operator">=</span> salt + password;</span><br><span class="line">            <span class="type">byte</span>[] hashedBytes = md.digest(beforeHash.getBytes());</span><br><span class="line">            <span class="comment">// 将字节数组转换为Base64编码的字符串</span></span><br><span class="line">            passwordHash = Base64.getEncoder().encodeToString(hashedBytes);</span><br><span class="line">            <span class="keyword">return</span> passwordHash;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;无法找到SHA-256算法&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">encryptedPassword</span> <span class="operator">=</span> account.encryptPassword(<span class="string">&quot;myPassword123&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Encrypted Password: &quot;</span> + encryptedPassword);</span><br><span class="line">        System.out.println(<span class="string">&quot;Salt: &quot;</span> + account.salt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附录：所有-JavaDoc-标签"><a href="#附录：所有-JavaDoc-标签" class="headerlink" title="附录：所有 JavaDoc 标签"></a>附录：所有 JavaDoc 标签</h2><ol><li><code>@author</code><ul><li>描述类或接口的作者。</li></ul></li><li><code>@version</code><ul><li>指定API版本信息。</li></ul></li><li><code>@since</code><ul><li>标识从哪个版本开始引入了该特性。</li></ul></li><li><code>@param</code><ul><li>描述方法参数的信息。</li></ul></li><li><code>@return</code><ul><li>描述方法返回值的信息。</li></ul></li><li><code>@throws</code> &#x2F; <code>@exception</code><ul><li>描述可能抛出的异常。</li></ul></li><li><code>@deprecated</code><ul><li>表示某个类、方法或字段已被弃用，并提供替代方案。</li></ul></li><li><code>@see</code><ul><li>提供指向其他元素的链接，如类、方法或其他资源。</li></ul></li><li><code>&#123;@link&#125;</code> 和 <code>&#123;@linkplain&#125;</code><ul><li>在文本中创建链接到另一个元素，区别在于字体样式（<code>&#123;@link&#125;</code>使用代码字体，而<code>&#123;@linkplain&#125;</code>使用普通字体）。</li></ul></li><li><code>&#123;@docRoot&#125;</code><ul><li>代表生成的文档根目录的相对路径。</li></ul></li><li><code>&#123;@value&#125;</code><ul><li>显示静态字段的值。</li></ul></li><li><code>@serial</code><ul><li>用于序列化字段的说明。</li></ul></li><li><code>@serialField</code><ul><li>用于描述<code>Serializable</code>类中<code>serialPersistentFields</code>成员变量的具体字段。</li></ul></li><li><code>@serialData</code><ul><li>描述由<code>writeObject</code>或<code>readObject</code>方法写入或读取的数据格式。</li></ul></li><li><code>@code</code><ul><li>将一段文本标记为代码样式。</li></ul></li><li><code>@literal</code><ul><li>类似于<code>@code</code>，但不使用等宽字体显示文本。</li></ul></li><li><code>@inheritDoc</code><ul><li>继承父类或接口的文档注释。</li></ul></li><li><code>@hidden</code><ul><li>隐藏特定的成员，使其不出现在生成的文档中。</li></ul></li><li><code>@review</code><ul><li>标记需要审查的部分。</li></ul></li><li><code>&#123;@index&#125;</code><ul><li>为特定术语创建索引条目。</li></ul></li><li><code>@apiNote</code><ul><li>提供关于API使用的额外信息。</li></ul></li><li><code>@implSpec</code><ul><li>描述实现细节，适用于接口默认方法或抽象类中的具体实现。</li></ul></li><li><code>@implNote</code><ul><li>提供关于实现的额外信息。</li></ul></li><li><code>@param &lt;T&gt;</code><ul><li>描述泛型类型参数。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅浅理解Java中的逆变与协变</title>
      <link href="/2025/02/16/2025-02-16-%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/"/>
      <url>/2025/02/16/2025-02-16-%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h1 id="和"><a href="#和" class="headerlink" title="&lt;? extends T&gt;和&lt;? super T&gt;"></a>&lt;? extends T&gt;和&lt;? super T&gt;</h1><p>先定义如下几个类， 表示继承关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Life</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_">Life</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat,Dog -&gt; Animal -&gt; Life</p><h2 id="协变"><a href="#协变" class="headerlink" title="协变 &lt;? extends T&gt;"></a>协变 &lt;? extends T&gt;</h2><p>表示泛型可以等于任何 T 的子类或者 T 本身。</p><p>上界就是 T 类本身，下界是 T 类最底层的子类。</p><p>以 <code>List&lt;? extends T&gt; list</code>为例：</p><p>该语法规则的意思是： list 可以存储 T 类或者某种 T 的子类的集合。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 下面三行add代码全部会报错。编译器只能确定list中的元素是Animal或者是Animal的子类</span></span><br><span class="line"><span class="comment">     * 但具体是哪一类，并不能确定，可能是Dog,也可能是Cat。那就不能让某一种具体的类被add进去。</span></span><br><span class="line"><span class="comment">     * 所以，以协变作为泛型的集合类，不能写数据，但可以读数据，</span></span><br><span class="line"><span class="comment">     * 可以任意用Animal类或者Animal的父类去接收其中的数据。</span></span><br><span class="line"><span class="comment">     * 毕竟，子类赋值给父类是再自然不过的事情。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 上界是Animal，下界是Cat &amp; Dog</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>()); <span class="comment">// 错误 </span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Cat</span>()); <span class="comment">// 错误</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Animal</span>()); <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 可以读取，因为list里的元素要么是Animal，要么是Animal的子类。</span></span><br><span class="line"><span class="comment">     * 子类赋给父类当然没问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> list.get(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆变"><a href="#逆变" class="headerlink" title="逆变&lt;? super T&gt;"></a>逆变<code>&lt;? super T&gt;</code></h2><p>表示泛型可以等于任何 T 的父类或者 T 本身。</p><p>下界是 T 类最底层的子类（T 的子类也是 T 类，视作 T 类本身），上界是 T 类最高层的父类：<code>Object</code>。</p><p>还是以 <code>List&lt;? extends T&gt; list</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第三行出错的原因在于：list的元素类型可以是Animal,可以是Life,也可以是Object，</span></span><br><span class="line"><span class="comment">     * 编译器又不知道是具体是哪一种。那就不能让某一种具体的类被add进去。</span></span><br><span class="line"><span class="comment">     * 但是Animal及其子类，即是Animal类，也是Life类，更是Object类。那当然可以被add。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;? <span class="built_in">super</span> Animal&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 上界是Object，下界是Cat &amp; Dog</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Animal</span>()); <span class="comment">// 合法，可以添加Animal类型的数据</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>()); <span class="comment">// 合法，可以添加Dog类型的数据</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 编译错误！只能添加Animal或其子类</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 合法，只能读取为Object类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>前两部分中都提到了 <code>编译器又不知道是具体是哪一种。那就当然不能让某一种具体的类被add进去。</code></p><p>可是 Java 里明明有泛型擦除啊，为什么不在擦除泛型确定了具体类型之后再编译后面的代码呢？</p><p>比如这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">func</span><span class="params">(List&lt;? <span class="built_in">super</span> Animal&gt; list)</span>&#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Animal</span>()); </span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Life</span>()); <span class="comment">// 编译错误！只能添加Animal或其子类</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>func</code>方法被编译时，由于泛型擦除，绝对是知道泛型的具体类型的，比如确定为 <code>Life</code> 类。那么第三行就不会报错了。可为什么 <code>JDK</code> 没有这么设计呢？</p><p>我们再看一段代码：</p><p>假设执行这段代码的 JDK 会先执行泛型擦除确定具体类型之后，再编译后面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Life&gt; lifeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    func(lifeList);</span><br><span class="line">    List&lt;Animal&gt; animalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    func(animalList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">func</span><span class="params">(List&lt;? <span class="built_in">super</span> Animal&gt; list)</span>&#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Animal</span>()); </span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Life</span>()); <span class="comment">// 编译错误！只能添加Animal或其子类</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译<code>func(lifeList);</code>时， <code>?</code> 确定为 <code>Life</code> 类，编译 <code>list.add(new Life());</code> 不会报错。</p><p>但是编译 <code>func(animalList)</code>时，<code>?</code> 被确定为 <code>Animal</code> 类，再去编译 <code>list.add(new Life());</code>呢？</p><p><code>Life</code> 类是 <code>Animal</code> 类吗？能 <code>add</code> 吗？肯定不是也不能啊。</p><p>子类可以被赋值给父类，父类不可能被赋值给子类。</p><p>毕竟：</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-02-16-%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/img.png"></p><p>于是编译失败。</p><p>如果再对字节码做出些修改，运行时来个编译期根本无法预料的情况，比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Life&gt; lifeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    func(lifeList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">func</span><span class="params">(List&lt;? <span class="built_in">super</span> Animal&gt; list)</span>&#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Animal</span>()); </span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Life</span>()); <span class="comment">// 编译错误！只能添加Animal或其子类</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译当然没问题，run 起来之后做个热部署，添加新方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ff</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Animal&gt; animalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    func(animalList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完蛋，执行func方法直接抛出 <code>ClassCastException</code>，因为Life类不是Animal类。</p><p>为了避免这种莫名其妙的问题，倒不如一刀切（我猜的）。不管 <code>func</code> 方法中泛型确定为何种类型，方法体里的代码执行写操作(<code>add</code>)时始终把它当做 <code>Animal</code> 类型。</p><p>执行读操作时，管你泛型被擦除为了 <code>Animal</code> 的哪个父类，执行读操作(<code>get</code>)统一返回为 <code>Object</code> 类型。</p><p>只要代码初始编译能过，后面随便怎么热部署搞破坏，都不会抛出 <code>ClassCastException</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>协变 <code>&lt;? extends T&gt;</code>中，<code>add</code> 多个子类对象时，由于不能确定泛型被擦除为哪个子类，99%的概率擦除后的类型和 add 的多个子类对象不兼容。比如 T 是 <code>Life</code> 类，泛型擦除为 <code>Dog</code> 类，<code>add</code> 了 <code>Animal</code> 类对象，必然报错。因为：父类不能当做子类。所以写操作是不可行的。</p><p>但是可以读。不管泛型擦除成了哪个子类，都是 <code>Life</code>或者 <code>Object</code> 类 ，<code>Life life = list.get(0);</code>或者 <code>Object obj = list.get(0);</code>准没问题。</p><p>因为：子类可以当做父类。</p><p>逆变<code>&lt;? super T&gt;</code>中，<code>add</code> 多个父类对象时，由于不能确定泛型被擦除为哪个父类，不加以限制， 99%的概率擦除后的具体类型和 add 的多个 父类对象不兼容。比如 T 是 <code>Dog</code> 类，泛型擦除为 <code>Animal</code> 类，<code>add</code> 了 <code>Life</code> 类对象，必然报错。因为：父类不能当做子类。</p><p>但是，加以限制呢？</p><p>比如：执行 <code>add</code> 操作时人为限制 <code>add</code> 的父类对象必须是 T 类或者其子类。那么不管泛型被擦除为何种父类，<code>add</code>的对象都是它的子类，编译通过。</p><p>读操作呢？</p><p>和协变 <code>&lt;? extends T&gt;</code>一样，不管泛型擦除成了哪个子类，都是 <code>Object</code> 类，<code>Object obj = list.get(0);</code>准没问题。</p><p>因为：子类可以当做父类。</p><table><thead><tr><th>extends</th><th>不能 add</th><th>能 get，但一定得 get T 及其父类的对象</th></tr></thead><tbody><tr><td>super</td><td>能 add，但一定得 add T 及其子类的对象</td><td>不能完全 get(只能 get Object)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Java一些新特性</title>
      <link href="/2025/02/09/2025-02-09-%E6%B5%85%E6%9E%90Java%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2025/02/09/2025-02-09-%E6%B5%85%E6%9E%90Java%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="fY9Fa">project amber 琥珀计划</h2>project amber 是为了改善 Java 复杂语法而创建的，目的是提高 Java 代码简洁性。<h3 id="Pam6u">Var 关键字</h3>该特性在 JDK10 正式引入<p>和 js 中的 var 一样，用于定义一个变量而不需要指定这个变量的类型，由编译器在编译时推断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 使用 var 关键字</span></span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><h3 id="XA9at">简化多行文本String表达式</h3>该特性在 JDK15 正式引入<p>将包含多个换行符的 String 用更自然的方式呈现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;    &lt;body&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;        &lt;p&gt;Hello, World!&lt;/p&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;    &lt;/body&gt;\n&quot;</span> +</span><br><span class="line">              <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line"><span class="comment">// 使用文本块</span></span><br><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              &lt;html&gt;</span></span><br><span class="line"><span class="string">                  &lt;body&gt;</span></span><br><span class="line"><span class="string">                      &lt;p&gt;Hello, World!&lt;/p&gt;</span></span><br><span class="line"><span class="string">                  &lt;/body&gt;</span></span><br><span class="line"><span class="string">              &lt;/html&gt;</span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="uj1eQ">switch 表达式简化</h3>该特性在 JDK14 正式引入<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统 switch 语句</span></span><br><span class="line"><span class="type">int</span> numLetters;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        numLetters = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        numLetters = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">        numLetters = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        numLetters = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid day: &quot;</span> + day);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 简化版的switch 表达式</span></span><br><span class="line"><span class="type">int</span> <span class="variable">numLetters</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="number">9</span>));<span class="comment">//支持表达式</span></span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">                <span class="keyword">yield</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>yield 几乎是为了 switch 表达式存在的。</p><p>switch 从传统的语句演变为表达式后，当 case 或 default 分支需要执行复杂逻辑，而不只是简单的返回一个值时，就需要使用代码块 {} 来包裹这些逻辑。但代码块不能自动将其中的某个值作为返回值给 switch 表达式，这时就需要 yield 关键字来显式指定返回值。</p></blockquote><h3 id="ouKiR">record 类</h3>该特性在 JDK16 正式引入（JDK16 中一同引入的还有用于科学计算的 Vector API，但仍处于孵化阶段。见  <p><a href="https://juziblog.space/2024/08/02/2024-08-02-Vector%20API%E4%BB%8B%E7%BB%8D&%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">Vector API介绍&amp;简单使用</a></p><p>Record 类是一种特殊的类，用于创建所有字段都被 final 修饰的类。它可以自动生成构造方法、<code>toString()</code>、<code>equals()</code> 和 <code>hashCode()</code> 等方法，减少了样板代码。类似于 lombok，但不如 lombok 功能丰富。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式定义不可变类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">        <span class="keyword">return</span> x == point.x &amp;&amp; y == point.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Point[x=&quot;</span> + x + <span class="string">&quot;, y=&quot;</span> + y + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 record 类</span></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="sURGX">密封类和接口</h3>该特性在 JDK16 正式引入。<p>使用 <code>sealed</code> 关键字修饰类或接口，并使用 <code>permits</code> 子句指定特定的类实现它。</p><p>不太明白这个特性有什么用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义完这个接口后，意味着只有Circle或者Rectangle类及其子类可以实现这个接口</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Circle, Rectangle &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现密封接口的具体类</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">double</span> width, <span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kYZyG">instanceof 模式匹配</h3>该特性在 JDK16 正式引入。<p>在 instanceof 表达式内可以隐式赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">    System.out.println(<span class="string">&quot;字符串长度: &quot;</span> + length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 instanceof 模式匹配</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">// 如果obj是String或者是String的子类，则隐式地将obj赋给str</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String str) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">    System.out.println(<span class="string">&quot;字符串长度: &quot;</span> + length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IR2Gy">虚拟线程</h3>该特性在 JDK21 正式引入。<p>是一种轻量级线程，它在很多其他语言中被称为协程、纤程、绿色线程、用户态线程等。</p><p>介绍虚拟线程之前，先回顾一下 Java 线程面临的问题：</p><ol><li>线程状态切换开销大。 Java 线程根据 1 对多，1 对 1 等关系直接映射操作系统线程。Java 线程的创建、调度、销毁都需要操作系统介入，开销较大。多线程执行任务时性能提升还不够。</li><li>线程占据栈空间较大。每个线程要占据一定的栈空间。</li><li>阻塞处理方式不好。遇到 IO 操作时，对应的 Java 线程会进入阻塞态（如果一个操作系统线程对应多个 Java 线程，这也是虚拟线程的模型。操作系统线程也会进入阻塞态吗？）。</li></ol><p>再来看看什么是虚拟线程：</p><h4 id="lxkSc">虚拟线程定义：</h4><blockquote><p>虚拟线程是一种逻辑上的线程，它并不直接对应于操作系统的物理线程。相反，虚拟线程是由JVM在内部管理的，它通过在物理线程上执行来模拟多线程的行为。  </p><p>虚拟线程可以看作是轻量级的线程，由Java虚拟机自己管理和调度，而不需要操作系统的干预。虚拟线程可以在一个物理线程上执行多个虚拟线程，并通过合理的调度算法实现并发执行。  </p><p><a href="https://developer.aliyun.com/article/1316968">Java的虚拟线程到底是什么？解决了什么痛点？-阿里云开发者社区</a>  </p></blockquote><p>总结：一个 Java 线程对应的多个虚拟线程可以理解为单线程执行的多线程模型。当一个虚拟线程遇到 IO 操作时，该虚拟线程进入阻塞态。，但底下那个 Java 线程不受影响还是运行态（咋实现的呢？）。</p><p>回顾上面列举的 Java 线程缺陷，看看虚拟线程是怎么改善的：</p><ol><li>线程状态切换开销大。虚拟线程的创建和销毁由 JVM 在用户态完成，无需操作系统内核的介入，开销极小。JVM 会根据虚拟线程的状态和优先级进行高效调度。</li><li>线程占据栈空间较大。虚拟线程的栈内存是动态分配的，且占用的内存非常小，通常只有几十 KB。</li><li>虚拟线程在遇到IO阻塞操作时，会让出执行权，让其他虚拟线程继续执行。JVM 运行时会将 Java 线程分配给其他可运行的虚拟线程，从而避免了线程资源的浪费。当阻塞操作完成后，由于像 epoll 这样的事件回调机制的 IO 模型，该虚拟线程会被唤醒进入就绪态，再根据一些调度算法如多级反馈调度，进入执行态（是的，虚拟线程也有我们熟知的多种线程状态）。</li></ol><p>因此使用虚拟线程提升性能最大的系统类型是IO密集型。由于多个虚拟线程对应的同一个Java线程，对CPU密集型系统性能无提升。</p><blockquote><p>java线程和操作系统线程是直接对应的，大量创建Java线程不仅会导致操作系统频繁分配栈内存，更有操作系统参与的大量线程上下文切换开销，对CPU造成较大的压力。<br>而虚拟线程和操作系统没啥关系，且它的栈信息保存在堆内存中，大量创建虚拟线程导致的是GC压力。<br>关于虚拟线程与GC的关系可参考<a href="https://www.zhihu.com/question/621251387/answer/3306141440">此文</a></p></blockquote><p>逻辑上代码是由虚拟线程执行，但实际上还是 Java 线程在执行。类似于只有一个核心的 CPU，运行着多线程。CPU(Java 线程)一直在 work，但是线程(虚拟线程)不会一直 work，而是在运行态、就绪态、阻塞态之间切换，甚至是终结态消灭这个线程。</p><p>了解更多关于虚拟线程的信息，参阅<a href="https://mp.weixin.qq.com/s/aoFo74SSXoaEIywu-pX-Ow">JDK21有没有什么稳定、简单又强势的特性？</a></p><h2 id="Kn9vs">native image</h2><blockquote><p>注： native image 是 Java AOT 编译的一种方案</p></blockquote><p>很多人说 Java 程序很臃肿，吃内存。</p><p>我现写一个只有 hello world 功能的 spring 项目，整个项目就两个类。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-02-09-%E6%B5%85%E6%9E%90Java%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/img.png"></p><p>运行看看内存占用：</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-02-09-%E6%B5%85%E6%9E%90Java%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/img_1.png"></p><p>确实占了不少内存。</p><p>接着修改 pom.xml，改为 native image 编译。</p><p>完整的 native image 编译模式的 pom.xml 内容见文章末尾。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-02-09-%E6%B5%85%E6%9E%90Java%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/img_2.png"></p><p>终端执行 <code>mvn native:compile-no-fork</code>。如上图，<strong>编译了02:18min</strong> 后，在 <code>target</code>目录下出现了一个 unix 可执行文件 demo2<sup>[1]</sup>  </p><blockquote><p>静态编译真的很慢，更何况这只是个包含两个类的helloWorld程序。</p></blockquote><p>运行它：</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-02-09-%E6%B5%85%E6%9E%90Java%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/img_3.png" alt="启动仅花了不到0.1秒的时间。而启动jar包则需要1秒左右"></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-02-09-%E6%B5%85%E6%9E%90Java%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/img_4.png"></p><p>内存占用 由 166.2MB 降低到了 48.49MB</p><p><strong><code>有了 native image，怎么好意思说 java 很臃肿、启动很慢?</code></strong> </p><p>但是代价就是没有了 JVM：</p><ol><li>Java 程序的许多动态特性都不直接生效了，例如动态类加载，反射，动态代理等。需要使用 GraalVM 提供的额外配置方式来解决这个问题。</li><li>丧失了 Java 程序多年来引以为傲的平台无关性。</li><li>最重要的是，基于字节码改写实现的 Java Agent 将不再适用，因为没有了字节码概念，所以之前我们通过 Java Agent 做到的各种可观测能力，例如收集 Trace&#x2F;Metrics 等信号这些能力都不能生效了。</li></ol><p>像 Java Agent 的代表之一 ：arthas ，就无法使用在编译后的 unix 可执行文件上。</p><p>arthas 的原理是基于 JVM 实现了插桩、动态代理、和<strong>Instrumentation接口</strong> (skywalking也是通过这个接口实现了修改后字节码的加载)。</p><p>可以试试 arthas 能不能跟踪到 demo2 程序：</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-02-09-%E6%B5%85%E6%9E%90Java%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/img_5.png"></p><p>很明显不能</p><p>改为原来的 jit 编译，arthas 生效</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2025-02-09-%E6%B5%85%E6%9E%90Java%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/img_6.png"></p><p>那么如何在 native image 模式下使 Java-Agent 生效呢?</p><p>阿里那边有一些工作可供参考：</p><p><a href="https://juziblog.space/2024/07/14/2024-07-14-GraalVM%20%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E4%B8%8B%20OTel%20Java%20Agent%20%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%A1%88%E4%B8%8E%E5%AE%9E%E7%8E%B0/">GraalVM 静态编译下 OTel Java Agent 的自动增强方案与实现</a></p><p>但是目前来看，native image并不比JIT更优秀。graalVM毕竟还是比较新的技术，一旦出现什么问题或者编译错误，在google上找不到解决方案就难受了。<br>而且单论性能，预热后的JIT也不输native image。graalVM 的 native image为了提前编译做出了很多取舍，比如G1收集器在以前收费的企业版里才支持，而且吞吐量下降明显。<br>目前来看 graalVM 的 native image最大的优点就是启动快，初始内存占用低。适合Java语言开发的客户端应用，但不适合服务器上长期运行的程序。</p><p>Java这门语言还有很长的路要走。</p><blockquote><p>概念普及：</p><p>动态编译 JIT:</p><p>代码经过编译后得到字节码。<br>如Java代码编译得到字节码，字节码由 JVM 逐行解释，翻译为机器码给 CPU 执行。对于执行频繁的热点字节码，经过 JIT 编译成机器码让 CPU 直接执行。这印证了Java是半编译半解释的语言。</p><p>解释器的优点是：启动速度快，对于那些只执行少量次数的代码，使用解释器执行可以避免 JIT 编译带来的额外开销。例如，一些只在特定条件下才会执行的代码块，或者在程序启动阶段执行一次的初始化代码，使用解释器执行更为合适。</p><p>静态编译：</p><p>将 C++，C 等代码编译为操作系统相关的二进制文件，如 Mac 上的 unix 可执行文件，Windows 的 exe，Linux 上的 deb。</p><p>AOT 编译</p><p>静态编译的一种。 AOT 是将 Java 代码编译后得到的字节码再编译为机器码，得到操作系统相关的二进制文件。上文中反复提到的 native image 就是 AOT 编译的一种。</p><p>这使得运行 Java 程序就像打开 app 一样简单。并且内存占用相较于执行 jar 包而言变得很低。但是 Java 引以为傲的平台无关性消失了。</p><p>由于字节码没有被跳过，Java 程序的动态代理、反射等特性还是可以使用的。</p><p>可以理解为 AOT 是静态编译在 Java 的具体实现。  </p><p><strong>静态编译和动态编译的最大区别就是生成机器码的时机。</strong><br>程序未运行就已经生成了机器码叫静态编译。<br>程序运行时才根据执行情况将一部分代码编译为机器码，叫动态编译。</p></blockquote><h2 id="OFtyL">ZGC & shanendoahGC</h2>待续<h2 id="mw1Q3">叶公好龙</h2>叶公喜欢龙是出了名的，所有人都知道，然后有一天，龙真的来了，叶公躲到床下，浑身哆嗦吓得半死<p>标榜自己爱好技术的人很多，但真正想要解决问题的人很少</p><p>经常看到技术人员各种抱怨，以java为例，无数的人在说java语法繁琐，gc pause，启动慢，ui丑，等等</p><p>不可否认，他们说的都是事实，但问题是，他们只看到了问题，却不去想着怎么解决问题</p><p>不想着解决也无可厚非，又不是从事编译器开发工作或者 jdk 开发者。</p><p>但有意思的是，当你告诉他们，java语法繁琐有project amber在解决，gc有zgc，shanendoah在解决，启动慢有aot，大有native image，当你把这些解决方案罗列到他们面前的时候</p><p>很多人的表现居然是抗拒，而不是尝试</p><p>因为他们突然发现，有新的东西要学了</p><p>这难道不是他们一直以来备受困扰的问题吗？当别人把免费的解决方案放到他手上的时候</p><p>居然不敢用？不敢试？活脱脱的现实版叶公</p><h2 id="nmsAr">附录：pom.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>demo2<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">license</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connection</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developerConnection</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置 GraalVM Native Image 插件版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">native.buildtools.version</span>&gt;</span>0.9.26<span class="tag">&lt;/<span class="name">native.buildtools.version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 启用 Spring AOT 支持 Native Image --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.aot.enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">spring.aot.enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 无需指定版本，会从 parent 继承 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;version&gt;RELEASE&lt;/version&gt; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 添加 Spring AOT 依赖 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;org.springframework&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;spring-aot&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;6.2.2&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;scope&gt;compile&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.graalvm.buildtools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>native-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 指定主类 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.example.demo.Demo2Application<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>pre-process-aot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>process-aot<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><ol><li><a href="https://yujinping.top/post/java/using_-graalvm_build_native_app/">Mac下使用GraalVM和SpringBoot3.1构建本地应用 - Mr.Yu-技术笔记</a></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 静态编译 </tag>
            
            <tag> JIT </tag>
            
            <tag> AOT </tag>
            
            <tag> native image </tag>
            
            <tag> GraalVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深分页问题</title>
      <link href="/2024/12/22/2024-12-22-%E6%B7%B1%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/"/>
      <url>/2024/12/22/2024-12-22-%E6%B7%B1%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="cjVCw">什么是深分页问题</h1>select * from table where uid = {uid} limit 300 30;300 是 offset，30是要返回多少条数据。  <p>也就是查询第十页的内容。每页 30 条。也就是得到第 300 条到第 330 条的数据</p><p>innodb 会做一件很消耗性能的事情：把第 1 条数据到第 330 条数据全部返回到 server 层，然后根据 offset &#x3D; 300将前面的 300<br>条数据抛弃。</p><p>还没完，如果涉及到回表操作，330 条数据全部回表查询后才会把前 300 条数据抛弃。这就更加损耗性能了。</p><blockquote><p>如果你在尝试在一张巨型表中explain如上语句，数据库甚至会在type那一栏中显示“ALL”，也就是<strong>全表扫描</strong>。这是因为<strong>优化器</strong>会在执行器执行sql语句前，判断下哪种执行计划的代价更小。但优化器在看到非主键索引的600w次回表之后，直接摇了摇头，说“还是全表一条条记录去判断吧”，于是选择了全表扫描。</p></blockquote><p>所以，出现深分页时，大概率会导致全表扫描。完完全全的性能杀手。</p><p>这是<a href="https://ramzialqrainy.medium.com/faster-pagination-in-mysql-you-are-probably-doing-it-wrong-d9c9202bbfd8">https://ramzialqrainy.medium.com/faster-pagination-in-mysql-you-are-probably-doing-it-wrong-d9c9202bbfd8</a><br>中的一些数据，可以看到随着分页的深入（offset递增），耗时呈指数型上升。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-22-%E6%B7%B1%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/img.png"></p><h1 id="n8pXR">如何解决深分页问题</h1><h2 id="vdnUn">减少回表损耗</h2><h3 id="TuIWZ">延迟 join</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">inner</span> <span class="keyword">join</span> (</span><br><span class="line">   <span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> uid <span class="operator">=</span> <span class="string">&#x27;&#123;uid&#125;&#x27;</span> limit <span class="number">300</span>，<span class="number">30</span>; </span><br><span class="line">) <span class="keyword">as</span> t2 <span class="keyword">using</span> (id)</span><br></pre></td></tr></table></figure><p>原理在于join的驱动表中只需要返回id，是不需要进行回表的，然后原表中字段的时候只需要查询30行数据（也仅需要回表这30行数据）。</p><h3 id="ONKwX">Seek Method</h3><p>深分页的本质原因是，offset越大，需要扫描的行数越多，然后再丢掉，导致查询性能下降。如果我们可以精确定位到上次查询到哪里，然后直接从那里开始查询，就能省去“回表、丢弃”这两个步骤了。</p><p>我们可以每次记录上一次查询的进度，从该进度接着往查询。例如：</p><p><code>select id from table where uid = &#39;&#123;uid&#125;&#39; and id&gt; &#123;last_id&#125; limit  30;</code></p><p>这也是我们平时最常用的分页方法。但是这个方法有几个弊端，需要我们做一定的取舍：</p><h4 id="UfIZX">Seek Method 局限一：无法支持跳页。</h4>传统分页设计下，需要支持直接跳到第X页，SeekMethod 无法实现。<p>但是目前大部分软件设计都是瀑布流设计，除了一些后台管理、通知公告等业务外，几乎不会支持分页查询。</p><h4 id="hYu0M">Seek Method 局限二：排序场景下有限制</h4><p>但大部分的业务的SQL并没有本文中的例子这么简单，至少会多一个条件：按照创建时间&#x2F;更新时间等排序（大部分情况倒序）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  <span class="keyword">table</span></span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">  uid <span class="operator">=</span> <span class="string">&#x27;&#123;uid&#125;&#x27;</span> </span><br><span class="line">limit </span><br><span class="line">    X, <span class="number">30</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">  create_time <span class="keyword">desc</span>;</span><br><span class="line">注意大数据量下需要先分页再排序。</span><br></pre></td></tr></table></figure><p>如果需要改成瀑布流的话，需要先排序再分页，性能不如上一种。这种情况可以给 time<br>加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  <span class="keyword">table</span> </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">  uid <span class="operator">=</span> <span class="string">&#x27;&#123;uid&#125;&#x27;</span>  <span class="keyword">and</span> create_time <span class="operator">&gt;</span> &#123;last_select_time &#125;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">  create_time <span class="keyword">desc</span> </span><br><span class="line">limit </span><br><span class="line">  <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>这样一眼看去没有什么问题，但是问题是create_time 和<br>id有一个最大的区别在于ID能保证全局唯一，但是create_time 不能。万一全局范围内create_time<br>出现重复，那么这个方法是有可能出现丢数据的。如下图所示，当翻页的时候直接用select_time&gt;200的话，可能会丢失数据。<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-22-%E6%B7%B1%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/img_1.png"></p><p>要解决这个问题也有一些方法，笔者尝试过的有：</p><p>1.主键字段设计上保证和排序字段的单调性一致。怎么说呢？例如我保证create_time越大的，id一定越大（例如使用雪花算法来计算出ID的值）。那么这样就依旧可以使用ID字段作为游标来改写SQL了</p><p>2.把&lt;改成&lt;&#x3D;，这样以后，数据就不会丢了，但是可能会重复。然后让客户端做去重。这样做其实还有一个隐患，就是如果select_time不等于当前时间，而是最大的<br>create_time，而且相同create_time的数据真的太多了，已经超过了一页。那么永远都翻不了页。</p><p>因为 查出来的数据 create_time都是一样的，select_time永远原地踏步。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SkyWalking链路追踪原理概述</title>
      <link href="/2024/12/20/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/12/20/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前博客里发过字节跳动技术团队的一篇文章：<br><a href="https://juziblog.space/2024/10/18/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/">如何优雅地重试</a><br>看完后把他们对超时和重试场景下的优化写进了简历里<br>但准备话术时发现了一个问题：<br>结合全链路超时控制无效重试<br>链路从哪来？<br>网上很多的RPC框架都只是单对单的发RPC，虽然逻辑上存在链路但是这些框架并没有搭建出来<br>于是我找来了链路追踪组件SkyWalking的<a href="https://github.com/apache/skywalking-java">源码</a><br>通过看源码的方式终于知道了链路搭建的原理</p></blockquote><h3 id="HLqgt">skywalking里的插件有什么用？</h3>对某服务的插桩。插桩之后才能实现链路追踪。<p>插桩就是字节码增强，一个意思。</p><h4 id="K1i9R">如何自定义插件？</h4>见官方文档  [插件开发指南](https://skywalking.apache.org/docs/skywalking-java/next/en/setup/service-agent/java-agent/java-plugin-development-guide/)<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>如果看过skywalking的源码就会发现，里面很多类都是通过自定义类加载器加载的。<br>为什么要自定义类加载器呢？  </p><p><strong>为了隔离资源，避免依赖冲突。</strong>   </p><p>每个类加载器都有自己的加载路径。不同路径下的资源不能互相加载。这也是双亲委派机制的由来。<br>对于同一份字节码，由不同的类加载器加载，加载出的两个实例不相同。如果一个项目里引入了不同的组件，比如每个组件都有log4j的库，但是版本不同。使用不同的类加载器就能避免因为类的全限定路径相同而导致不同的组件使用相同的log4j，也就避免了依赖冲突。</p><p>一个自定义类加载器的demo如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classDir)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classDir = classDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> classDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line">             <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化自定义类加载器并指定要加载类的根目录</span></span><br><span class="line">            <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;/path/to/classes/&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 使用自定义类加载器加载该类，将该类的信息加载进JVM的方法区里。</span></span><br><span class="line"><span class="comment">             * 也就是俗称的三步走：加载、链接（验证、准备、解析）、初始化</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Class&lt;?&gt; helloWorldClass = classLoader.loadClass(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建实例并调用方法</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> helloWorldClass.getDeclaredConstructor().newInstance();</span><br><span class="line">            helloWorldClass.getMethod(<span class="string">&quot;sayHello&quot;</span>).invoke(instance);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="k3u2d">插桩，如何实现？</h3>这是SkyWalking实现插桩的核心类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"> * contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"> * this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"> * The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"> * (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"> * the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.skywalking.apm.agent.core.plugin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.description.type.TypeDescription;</span><br><span class="line"><span class="keyword">import</span> net.bytebuddy.dynamic.DynamicType;</span><br><span class="line"><span class="keyword">import</span> org.apache.skywalking.apm.agent.core.logging.api.ILog;</span><br><span class="line"><span class="keyword">import</span> org.apache.skywalking.apm.agent.core.logging.api.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.skywalking.apm.agent.core.plugin.interceptor.ConstructorInterceptPoint;</span><br><span class="line"><span class="keyword">import</span> org.apache.skywalking.apm.agent.core.plugin.interceptor.InstanceMethodsInterceptPoint;</span><br><span class="line"><span class="keyword">import</span> org.apache.skywalking.apm.agent.core.plugin.interceptor.StaticMethodsInterceptPoint;</span><br><span class="line"><span class="keyword">import</span> org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.ClassEnhancePluginDefine;</span><br><span class="line"><span class="keyword">import</span> org.apache.skywalking.apm.agent.core.plugin.interceptor.v2.InstanceMethodsInterceptV2Point;</span><br><span class="line"><span class="keyword">import</span> org.apache.skywalking.apm.agent.core.plugin.interceptor.v2.StaticMethodsInterceptV2Point;</span><br><span class="line"><span class="keyword">import</span> org.apache.skywalking.apm.agent.core.plugin.match.ClassMatch;</span><br><span class="line"><span class="keyword">import</span> org.apache.skywalking.apm.agent.core.util.CollectionUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.skywalking.apm.util.StringUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic abstract class of all sky-walking auto-instrumentation plugins.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * It provides the outline of enhancing the target class. If you want to know more about enhancing, you should go to see</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ClassEnhancePluginDefine&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClassEnhancePluginDefine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ILog</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LogManager.getLogger(AbstractClassEnhancePluginDefine.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * plugin name defined in skywalking-plugin.def</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String pluginName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * New field name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONTEXT_ATTR_NAME</span> <span class="operator">=</span> <span class="string">&quot;_$EnhancedClassField_ws&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Main entrance of enhancing the class.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeDescription target class description.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder         byte-buddy&#x27;s builder to manipulate target class&#x27;s bytecode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader     load the given transformClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new builder, or &lt;code&gt;null&lt;/code&gt; if not be enhanced.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> PluginException when set builder failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DynamicType.Builder&lt;?&gt; define(TypeDescription typeDescription, DynamicType.Builder&lt;?&gt; builder,</span><br><span class="line">        ClassLoader classLoader, EnhanceContext context) <span class="keyword">throws</span> PluginException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">interceptorDefineClassName</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">transformClassName</span> <span class="operator">=</span> typeDescription.getTypeName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isEmpty(transformClassName)) &#123;</span><br><span class="line">            LOGGER.warn(<span class="string">&quot;classname of being intercepted is not defined by &#123;&#125;.&quot;</span>, interceptorDefineClassName);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOGGER.debug(<span class="string">&quot;prepare to enhance class &#123;&#125; by &#123;&#125;.&quot;</span>, transformClassName, interceptorDefineClassName);</span><br><span class="line">        <span class="type">WitnessFinder</span> <span class="variable">finder</span> <span class="operator">=</span> WitnessFinder.INSTANCE;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * find witness classes for enhance class</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] witnessClasses = witnessClasses();</span><br><span class="line">        <span class="keyword">if</span> (witnessClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String witnessClass : witnessClasses) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!finder.exist(witnessClass, classLoader)) &#123;</span><br><span class="line">                    LOGGER.warn(<span class="string">&quot;enhance class &#123;&#125; by plugin &#123;&#125; is not activated. Witness class &#123;&#125; does not exist.&quot;</span>, transformClassName, interceptorDefineClassName, witnessClass);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;WitnessMethod&gt; witnessMethods = witnessMethods();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtil.isEmpty(witnessMethods)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (WitnessMethod witnessMethod : witnessMethods) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!finder.exist(witnessMethod, classLoader)) &#123;</span><br><span class="line">                    LOGGER.warn(<span class="string">&quot;enhance class &#123;&#125; by plugin &#123;&#125; is not activated. Witness method &#123;&#125; does not exist.&quot;</span>, transformClassName, interceptorDefineClassName, witnessMethod);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * find origin class source code for interceptor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DynamicType.Builder&lt;?&gt; newClassBuilder = <span class="built_in">this</span>.enhance(typeDescription, builder, classLoader, context);</span><br><span class="line"></span><br><span class="line">        context.initializationStageCompleted();</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;enhance class &#123;&#125; by &#123;&#125; completely.&quot;</span>, transformClassName, interceptorDefineClassName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newClassBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Begin to define how to enhance class. After invoke this method, only means definition is finished.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeDescription target class description</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newClassBuilder byte-buddy&#x27;s builder to manipulate class bytecode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> new byte-buddy&#x27;s builder for further manipulation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> DynamicType.Builder&lt;?&gt; enhance(TypeDescription typeDescription, DynamicType.Builder&lt;?&gt; newClassBuilder,</span><br><span class="line">                                             ClassLoader classLoader, EnhanceContext context) <span class="keyword">throws</span> PluginException &#123;</span><br><span class="line">        newClassBuilder = <span class="built_in">this</span>.enhanceClass(typeDescription, newClassBuilder, classLoader);</span><br><span class="line"></span><br><span class="line">        newClassBuilder = <span class="built_in">this</span>.enhanceInstance(typeDescription, newClassBuilder, classLoader, context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newClassBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enhance a class to intercept constructors and class instance methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeDescription target class description</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newClassBuilder byte-buddy&#x27;s builder to manipulate class bytecode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> new byte-buddy&#x27;s builder for further manipulation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> DynamicType.Builder&lt;?&gt; enhanceInstance(TypeDescription typeDescription,</span><br><span class="line">                                                     DynamicType.Builder&lt;?&gt; newClassBuilder, ClassLoader classLoader,</span><br><span class="line">                                                     EnhanceContext context) <span class="keyword">throws</span> PluginException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enhance a class to intercept class static methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> typeDescription target class description</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newClassBuilder byte-buddy&#x27;s builder to manipulate class bytecode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> new byte-buddy&#x27;s builder for further manipulation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> DynamicType.Builder&lt;?&gt; enhanceClass(TypeDescription typeDescription, DynamicType.Builder&lt;?&gt; newClassBuilder,</span><br><span class="line">                                                  ClassLoader classLoader) <span class="keyword">throws</span> PluginException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Define the &#123;<span class="doctag">@link</span> ClassMatch&#125; for filtering class.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> ClassMatch&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> ClassMatch <span class="title function_">enhanceClass</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Witness classname list. Why need witness classname? Let&#x27;s see like this: A library existed two released versions</span></span><br><span class="line"><span class="comment">     * (like 1.0, 2.0), which include the same target classes, but because of version iterator, they may have the same</span></span><br><span class="line"><span class="comment">     * name, but different methods, or different method arguments list. So, if I want to target the particular version</span></span><br><span class="line"><span class="comment">     * (let&#x27;s say 1.0 for example), version number is obvious not an option, this is the moment you need &quot;Witness</span></span><br><span class="line"><span class="comment">     * classes&quot;. You can add any classes only in this particular release version ( something like class</span></span><br><span class="line"><span class="comment">     * com.company.1.x.A, only in 1.0 ), and you can achieve the goal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String[] witnessClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;WitnessMethod&gt; <span class="title function_">witnessMethods</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBootstrapInstrumentation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor methods intercept point. See &#123;<span class="doctag">@link</span> ConstructorInterceptPoint&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> collections of &#123;<span class="doctag">@link</span> ConstructorInterceptPoint&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> ConstructorInterceptPoint[] getConstructorsInterceptPoints();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Instance methods intercept point. See &#123;<span class="doctag">@link</span> InstanceMethodsInterceptPoint&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> collections of &#123;<span class="doctag">@link</span> InstanceMethodsInterceptPoint&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> InstanceMethodsInterceptPoint[] getInstanceMethodsInterceptPoints();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Instance methods intercept v2 point. See &#123;<span class="doctag">@link</span> InstanceMethodsInterceptV2Point&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> collections of &#123;<span class="doctag">@link</span> InstanceMethodsInterceptV2Point&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> InstanceMethodsInterceptV2Point[] getInstanceMethodsInterceptV2Points();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Static methods intercept point. See &#123;<span class="doctag">@link</span> StaticMethodsInterceptPoint&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> collections of &#123;<span class="doctag">@link</span> StaticMethodsInterceptPoint&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> StaticMethodsInterceptPoint[] getStaticMethodsInterceptPoints();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Instance methods intercept v2 point. See &#123;<span class="doctag">@link</span> InstanceMethodsInterceptV2Point&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> collections of &#123;<span class="doctag">@link</span> InstanceMethodsInterceptV2Point&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> StaticMethodsInterceptV2Point[] getStaticMethodsInterceptV2Points();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * plugin name should be set after create PluginDefine instance</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pluginName key defined in skywalking-plugin.def</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setPluginName</span><span class="params">(<span class="keyword">final</span> String pluginName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pluginName = pluginName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPluginName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pluginName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类里那些方法都是从64行的define方法开始的。而define方法在<code>org.apache.skywalking.apm.agent.SkyWalkingAgent#premain</code>方法中被间接调用。</p><p>premain，顾名思义，在main方法执行前执行，这印证了SkyWalking是静态启动，而不是像arthas那样动态附加。</p><p>完整的调用链如下：</p><p>-&gt;<code>premain()</code></p><p>-&gt;<code>installClassTransformer()</code>,此方法中,内部类<code>Transformer</code>被注入<code>agentBuilder</code></p><p>-&gt;<code>Transformer.tranform()</code></p><p>-&gt;<code>define()</code></p><blockquote><p><code>AgentBuilder</code> 是 <code>ByteBuddy</code> 提供的用于构建字节码转换操作的核心类之一，它会在后续按照设定的规则和配置来执行字节码增强的流程，而 <code>transform</code> 方法的作用就是指定具体由谁（ <code>Transformer</code> 实例）来对匹配到的目标类进行字节码的转换操作</p></blockquote><p>define方法开始的调用链的具体流程如下：</p><ol><li>准备工作。验证各个参数合法性</li><li>见证类验证。确定中间件的版本。因为没有任何方法可以百分百获取系统中某个中间件的版本号。但是每个版本都会有一些独特的类。通过排列组合可以间接确定版本号。</li><li>增强静态和实例方法。在enhance方法中调了两个抽象方法。一个负责增强目标类的静态方法，另一个负责实例方法。具体的增强逻辑由子类使用<code>DynamicType.Builder&lt;?&gt;</code>（<code>Byte Buddy</code> 提供的用于构建和修改字节码的工具类）去实现。其实就是子类把要增加的代码写在beforeMethod和afterMethod方法里。这两个方法后文的代码截图会提到。</li><li>通过<code>ByteBuddy</code>API在字节码加载时修改字节码，实现增强字节码。具体增强代码见<code>org.apache.skywalking.apm.agent.core.plugin.interceptor.enhance.v2.ClassEnhancePluginDefineV2#enhanceClass</code>方法。</li></ol><p>为什么字节码加载时能修改？谁通知<code>ByteBuddy</code>修改？</p><p>这个功能由<code>JVM</code>提供的<code>Instrumentation</code>接口实现<br>这个接口是用于类加载时对其字节码进行修改。修改的内容就是增加我们定义的BeforeMethod方法和AfterMethod方法，如图4中展示的BeforeMethod方法<br>从Java 7开始，这个接口可以在运行时重新定义已加载的类（如果字节码已经加载过了，那么就不能改变其结构，如添加或移除字段或方法）。这样可以在不重启应用的情况下更新某些行为，对于调试和热修复非常有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">agentBuilder.type(pluginFinder.buildMatch())</span><br><span class="line">                    .transform(<span class="keyword">new</span> <span class="title class_">Transformer</span>(pluginFinder))</span><br><span class="line">                    .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)</span><br><span class="line">                    .with(<span class="keyword">new</span> <span class="title class_">RedefinitionListener</span>())</span><br><span class="line">                    .with(<span class="keyword">new</span> <span class="title class_">Listener</span>())</span><br><span class="line">                    .installOn(instrumentation);<span class="comment">//注册instrumentation接口</span></span><br></pre></td></tr></table></figure><h3 id="gAxNk">链路追踪，如何实现？</h3>一个segment里面有多个span。每个span代表一个操作。<p>span分为entryspan,localspan,exitspan。entryspan只能有一个。</p><p>每个RPC操作（或其它服务）创建span时都会默认创建entryspan。同时用一个栈维护这些span。此外还有两个字段记录当前栈深和历史最大栈深。如果历史最大栈深大于1，说明entryspan已经被创建了，那么就创建localspan。</p><h4 id="MG5oe">同步</h4>记录当前节点里的链路的TracingContext类里有一个栈，保存在该节点一次请求中发生的span。tracingcontext对象被放进了ThreadLocal。每次创建span时需要通过getOrCreate方法获取tracingcontext对象，然后将生成的span放进这个对象保存span的栈里面（通过LinkedList模拟栈）。<p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img.png" alt="图1，TraceContext是ThreadLocal类型"></p><p>当前节点的流程结束后，即栈的深度为 0，会调用ThreadLocal的remove方法把本次流程的span数据全部清空</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_1.png" alt="图2，将 span 弹出栈。如果栈的深度为 0，isEmpty，返回 true"></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_2.png" alt="图3，若图2方法返回 true，则清空本线程的ThreadLocal类型的Context"></p><h5 id="l3PGB">举例，对Dubbo类型的 span 出入栈</h5><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_3.png" alt="图4，对Dubbo的插桩实现"></p><p>上图中的beforeMethod方法就是对dubbo插桩的代码。不同的中间件有不同的插桩实现。</p><p>上图中line76调用下图中的createExitSpan方法。return push方法的返回值。push方法正是将生成的span压入栈内。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_4.png" alt="图5，将生成的span压入栈内"></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_5.png" alt="图6，在afterMehtod插桩方法内，调用图二的 stopSpan 方法，将span弹出栈"></p><p>一个问题：像下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dubbo</span></span><br><span class="line">RPCService rpcService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Res <span class="title function_">rpcFunc</span><span class="params">(<span class="type">int</span> sign)</span> &#123;</span><br><span class="line">    <span class="type">Res</span> <span class="variable">result1</span> <span class="operator">=</span> rpcService.rpcFunc1(sign);</span><br><span class="line">    <span class="type">Res</span> <span class="variable">result2</span> <span class="operator">=</span> rpcService.rpcFunc2(sign);</span><br><span class="line">    <span class="keyword">return</span> result1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>rpcFunc</code>方法时创建了一个<code>TracingContext</code>。怎么保证执行<code>rpcFunc1</code>和<code>rpcFunc2</code>方法不会再次创建一个新的<code>TracingContext</code>呢？</p><p>由<code>ThreadLocal</code>解决。</p><p>只要执行<code>rpcFunc1</code>和<code>rpcFunc2</code>的方法和执行<code>rpcFunc</code>的方法在一个线程里，它们关联到的<code>TracingContext</code>就是同一个。</p><p>但是异步调用怎么办？</p><h4 id="eOPk3">异步</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dubbo</span></span><br><span class="line">RPCService rpcService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Res <span class="title function_">rpcFunc</span><span class="params">(<span class="type">int</span> sign)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">rpcTask</span> <span class="operator">=</span> () -&gt; rpcService.rpcFunc1(sign);</span><br><span class="line">    CompletableFuture&lt;Res&gt; future = CompletableFuture.supplyAsync(rpcTask1);</span><br><span class="line">    <span class="keyword">return</span> future.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别的线程怎么能知道它有没有链路上文呢？</p><p>把Trace 数据发给中间人，新线程从中间人获取。</p><p>再怎么跨线程也是在JVM内，也是通过创建Thread来跨线程。那就对JDK里面的Thread库也插桩，拦截Thread的构造方法，把数据打成快照发给中间人。创建线程后从中间人拿快照数据。这样就实现了跨线程的传递数据。</p><p>至于如何保证传递数据的准确性，就是另一回事了。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_6.png" alt="图7，拦截线程的构造方法"></p><p>ContextManager.capture()方法就是专门用于跨线程传递数据，将TraceID等数据打成快照，通过objInst.setSkyWalkingDynamicField方法传递给下一个线程。</p><p>从这个方法的实现来看，是把快照发给Kafka或者ES。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_7.png" alt="图8，EnhanceInstance接口的实现类"></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_8.png" alt="图9，老线程创建快照"></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_9.png" alt="图10，新线程获取快照"></p><p>这是JDK插件模块里的ThreadingMethodInterceptor类，顾名思义，对线程方法的拦截。拦截点是<code>org.apache.skywalking.apm.plugin.jdk.threading.ThreadingConstructorInterceptor</code> </p><p>在该方法执行前，通过getSkyWalkingDynamicField方法拿到Trace数据的快照（实现类只有kafka插件模块和ES插件模块里有）</p><p>再通过ContextManager.continued方法把快照恢复到ThreadLocal类型的Context变量里。</p><p>完了吗？</p><p>一个很重要的细节还没提到。</p><p>上文提到的线程拦截会拦截实现了 Callable 和 Runable 接口的任何线程</p><p>假设一个场景：</p><p>A线程接收到RPC请求，创建B线程异步调用别的服务。与此同时，A线程所在的节点还创建了一批线程处理别的非链路任务。难道这些链路无关的线程也要被拦截去执行BeforeMethod方法？这显然是不合理的。</p><p>怎么判断一个线程是否由链路上的线程创建？或者说：SkyWalking怎么控制线程插桩的粒度？</p><h4 id="Wo0oP">控制对线程/线程池插桩的粒度</h4>待续，本文会持续更新。<p>具体代码在<code>apm-sniffer/bootstrap-plugins/jdk-threading-plugin</code>和<code>apm-sniffer/bootstrap-plugins/jdk-threadpool-plugin</code>模块里。这是对线程和线程池插桩的实现。</p><h4 id="itPj1">跨进程时Trace数据怎么传递？</h4>skywalking将span分为了三种类型。EntrySpan/LocalSpan/ExitSpan。任何跨进程的操作都会生成ExitSpan。<p>创建ExitSpan时调用inject 方法</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_10.png" alt="图11，跨进程，发送carrier"></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_11.png" alt="图12，将Trace数据包装成ContextCarrier对象，通过DataCarrier发给下一个节点"></p><p>至于链路数据的存储和发送，则是通过<code>org/apache/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java</code>类实现存储， DataCarrier 模块实现发送</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-20-SkyWalking%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/img_12.png" alt="图13，DataCarrier模块"></p><p>这是 SkyWalking 自己实现的数据发送方式</p><p>默认通过 GRPC 向它自己的后端 OAP发送</p><p>从6.1.0 版本开始，也支持通过 Kafka 发送</p><h3 id="EF4c4">如何在 RPC 框架内部实现RPC链路追踪？</h3><p><strong>对于同步调用</strong>  </p><p>在RPC报文字段里添加traceID和SegmentID等字段，B服务的 X 方法收到A服务的调用时，解析出TraceID和SegmentID，将TraceID放在ThreadLocal里面的TraceContext里，SegmentID赋值给parentID。</p><p>执行过程中如果<strong>同步调用</strong>了其它RPC请求，那么这些请求都去ThreadLocal里拿到TraceID，如果拿不到说明它是本段链路的起点。同时记录本次RPC调用的信息（TraceID，OperationName，SegmentID，SpanID，CreateTime，ParentID等等。</p><p>同时用一个队列记录本节点 RPC 调用情况。B服务收到A服务的调用时，入队列。</p><p>队列也要保存在 ThreadLocal 里。通过 Netty 发起 RPC 时入队列。</p><p>Method.invoke 方法执行 X 方法结束后，本节点的 Trace 结束， 将队列元素全部弹出至 MySQL。</p><p>后续查看链路信息从MySQL中统计即可。</p><p><strong>如何感知本节点内的链路结束并清除ThreadLocal呢？</strong><br>执行RPC方法用的是Method类的invoke方法，在invoke方法结束后清除threadlocal即可。不用担心这两个步骤不是原子执行会导致下一次RPC链路使用本线程上一个链路的ThreadLocal</p><p><strong>对于异步调用</strong></p><p>实现起来比同步调用更难一些，除了显式地在形参里添加 Trace 参数，我能想到的唯一办法就是像 SkyWalking 一样对 Thread 库插桩。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 链路追踪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
            <tag> 链路追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dapper链路追踪论文翻译</title>
      <link href="/2024/12/09/2024-12-09-Dapper,%20a%20Large-Scale%20Distributed%20Systems%20Tracing%20Infrastructure/"/>
      <url>/2024/12/09/2024-12-09-Dapper,%20a%20Large-Scale%20Distributed%20Systems%20Tracing%20Infrastructure/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在研究如何在RPC框架内部实现RPC链路追踪，中途发现了Google的这篇论文。于是找了翻译版本放在博客上</p><p>原文：<a href="https://ai.google/research/pubs/pub36356">https://ai.google/research/pubs/pub36356</a></p><p>译文：<a href="http://alphawang.com/blog/google-dapper-translation">http://alphawang.com/blog/google-dapper-translation</a></p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>现代互联网服务通常都是复杂的大规模分布式系统。这些系统由多个软件模块构成，而这些软件模块可能由不同的团队开发、使用不同的编程语言实现、部署在横跨多个数据中心的几千台服务器上。这种环境下就急需一种能帮助理解系统行为、分析性能问题的工具。</p><p>本文将介绍 Dapper 这个在 Google 生产环境下的分布式系统跟踪服务的设计，并阐述它是如何满足在一个超大规模系统上达到<strong>低损耗</strong>（low overhead）、<strong>应用级透明</strong>（application-level transparency）、<strong>大范围部署</strong>（ubiquitous deployment）这三个需求的。Dapper 与其他一些跟踪系统的概念类似，尤其是 Magpie<sup>[3]</sup> 和X-Trace<sup>[12]</sup>，但是我们进行了一些特定的设计，使得 Dapper 能成功应用在我们的环境上，例如我们使用了采样并将性能测量（instrumentation）限制在很小一部分公用库里。</p><span id="more"></span><p>本文的主要目的是汇报两年多以来我们构建、部署并应用 Dapper 的经历，这两年多里 Dapper 对开发和运维团队非常有用，取得了显著的成功。最初 Dapper 只是一个自包含（self-contained）的跟踪工具，后来演化成了一个监控平台并促生出许多不同的工具，有些工具甚至 Dapper 的设计者都未曾预期到。我们将介绍一些基于 Dapper 构造的分析工具，分享这些工具在 Google 内部使用的统计数据，展示一些使用场景的例子，并讨论我们学习到的经验教训。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>Dapper 的目的是为了将复杂分布式系统的更多行为信息提供给 Google 开发者。这种分布式系统利用大规模的小服务器，通常对于互联网服务是一个非常经济的平台，所以很受关注。要理解在这种上下文中要的系统行为的话，就需要观察横跨不同程序和不同机器的关联行为。</p><p>下面基于一个 web 搜索的例子来说明这种系统需要应对的挑战。前端服务器将一个 web 查询分发给上百台搜索服务器，每个搜索服务器在自己的 index 中完成搜索。同时这个 web 查询可能还会被发送给多个其他子系统，进行广告处理、拼写检查、查找相关的图片&#x2F;视频&#x2F;新闻等。所有这些服务的结果会被有选择地合并成结果页面；我们把这种模型称之为<code>全局搜索 (universal search)</code>。处理一次全局搜索查询，总计需要上千台机器，涉及多种服务。而且 web 搜索的用户对延时很敏感，而任何一个子系统的性能差了都可能导致延时。工程师如果只看总体耗时的话，他能知道出问题了，但是他猜不到是哪个系统出问题、为什么出问题。<strong>首先，工程师可能无法准确知道到底调用了哪些服务</strong>；每周我们都会添加新的服务，用于实现用户需求、提升性能或安全性。<strong>其次，工程师不可能对每个服务的内部都了如指掌</strong>；每个服务都是由不同的团队开发维护的。<strong>第三，服务和服务器可能被许多不同的客户端调用</strong>，所以性能问题有可能是其他应用造成的。举例来说，前端服务器可能要处理多个不同的请求类型，或者类似 Bigtable 这种存储系统在被多个应用共享时效率最高。</p><p>上面描述的场景就对 Dapper 提出了两条最基本的要求：**大范围部署 (uniquitous deployment)、持续监控 (continuous monitoring)**。即便只有很小一部分系统没有被监控到，跟踪系统的作用也会大打折扣，所以大范围部署非常重要。另外，应该始终开启监控，因为通常来说异常系统行为很难重现，甚至根本无法重现。这两条基本要求提出了三个具体的设计目标：</p><ul><li>**低消耗 (Low overhead)**：跟踪系统对在线服务的性能影响应该做到可忽略不计。对于一些高度优化过的服务，监控系统的一点小消耗都会很显眼，都可能迫使部署团队不得不关停跟踪系统。</li><li>**应用级透明 (Application-level transparency)**：程序员应该不需要感知到跟踪系统。如果跟踪系统要求应用开发者的配合才能生效，那么这个跟踪系统就太脆弱了，经常会由于应用侵入代码的 bug 或者疏忽导致无法正常工作，这就违反了”大范围部署”的要求。这在我们这种快速开发的环境下尤为重要。</li><li>**可扩展性 (Scalability)**：需要能处理 Google 在未来几年的服务和集群规模。</li></ul><p>另外一个设计目标是生成跟踪数据后要很快可用于分析：最好是在一分钟内。尽管一个能处理几小时前数据的跟踪分析系统已经很有用了，但是能分析最新数据的话会让我们能对生产环境的异常情况作出快速反应。</p><p>我们通过把 Dapper 跟踪植入的核心代码限制在线程调用、控制流以及 RPC 等库代码中，实现了真正的应用透明这个最具挑战性的目标。使用自适应的采样（见4.4节），我们做到了可扩展性、降低性能损耗。最终的系统还包括收集跟踪数据的代码、可视化数据的工具、用于分析大规模跟踪数据的库和 API。尽管开发人员有时通过 Dapper 就足以找出性能问题的根源，但 Dapper 并不会替代所有其他的工具。我们发现 Dapper 的数据往往侧重于性能排查，所以其他工具也有自己的用处。</p><h3 id="1-1-贡献总结"><a href="#1-1-贡献总结" class="headerlink" title="1.1 贡献总结"></a>1.1 贡献总结</h3><p>之前已有一些优秀的文章探讨了分布式系统跟踪工具的设计空间，其中 Pinpoint<sup>[9]</sup>、Magpie<sup>[3]</sup> 和 X-Trace<sup>[12]</sup>  与 Dapper 最为相关。这些系统倾向于在开发过程早期就写成研究报告，而此时还没有机会明确地评估重要的设计选型。Dapper 已经在生产环境中被大型系统应用好几年了，我们认为本文最适合的侧重点是讨论我们在 Dapper 开发过程中有哪些收获、我们的设计决策是如何制定的、它在哪些方面最有用。Dapper 作为一个开发性能分析工具的平台以及作为一个监控工具，其价值是我们可以在回顾评估中找到一些意想不到的产出。</p><p>虽然 Dapper 的许多高层理念和 Pinpoint、Magpie 等其他系统是共通的，但是我们的实现包含了一系列新的贡献。举个例子，我们发现要想降低消耗的话采样就必不可少，尤其是在高度优化后的对延迟非常敏感的 web 服务中。或许最令人惊讶的是，我们发现即便只使用 1&#x2F;1000 的采样率，已经能为跟踪数据的通用用例提供足够多的信息了。</p><p>Dapper 的另一个重要特征是我们实现的应用透明程度非常高。我们将性能测量限制在足够底层，所以即便是像 Google web 搜索这样的大型分布式系统也能进行跟踪，而无需额外的注解。虽然由于我们的部署环境具有一定的同质性，所以更容易实现应用透明这个目标，但是我们的结果也论证了实现透明性的充分条件。</p><h2 id="2-Dapper-的分布式跟踪"><a href="#2-Dapper-的分布式跟踪" class="headerlink" title="2 Dapper 的分布式跟踪"></a>2 Dapper 的分布式跟踪</h2><p>分布式服务的跟踪系统需要记录在一次请求后系统完成的所有工作的信息。举个例子，图-1展示了拥有 5 台服务器的服务：一个前端服务器 A，两个中间层 B 和 C，两个后端服务器 D 和 E。当用户发起请求到前端服务器 A 之后，会发送两个 RPC 调用到 B 和 C。B 马上会返回结果，但是 C 还需要继续调用后端服务器 D 和 E，然后返回结果给 A，A 再响应最初的请求。对这个请求来说，一个简单的分布式跟踪系统需要记录每台机器上的每次信息发送和接收的信息标识符和时间戳。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-09-Dapper/img.png" alt="dapper-1_tree"></p><p><em>(图-1. 由用户请求X 发起的穿过一个简单服务系统的请求路径。字母标识的节点表示分布式系统中的处理过程)</em></p><p>为了能将信息聚合到一起以便人们能将所有记录信息关联到一个初始请求（如图1中的请求 X），我们提出了两种解决方案：<code>黑盒监控模式</code> 和 <code>基于标注的监控模式</code>。<strong>黑盒模式</strong><sup>[1, 15, 2] </sup>假定除了上面描述的信息记录之外无需任何额外的信息，而使用统计回归技术来推断关联关系。<strong>基于标注的模式</strong><sup>[3, 12, 9, 16]</sup> 则要求应用程序或中间件显式地将每个记录关联到一个全局 ID，从而将这些信息记录关联回初始请求。黑盒模式比基于标注的模式更加轻便，但是它依赖统计推断，所以需要更多的数据以便获取足够的准确性。很明显，基于标注的模式关键缺点是需要有代码侵入。在我们的环境中，由于所有应用系统都使用相同的线程模型、控制流和 RPC 系统，所以我们可以将性能测量限制在小规模的公用库中，以此实现对开发人员有效透明的监控系统。</p><p>我们倾向于认为 Dapper 的跟踪是一个嵌入式的 RPC 树。然而，我们的核心数据模型并不局限于特定的RPC 框架；我们也能跟踪例如 Gmail SMTP 会话、来自外界的 HTTP 请求、对 SQL 服务器的查询等行为。正式一点说，Dapper 跟踪模型使用了<code>树</code>、<code>span </code>和 <code>标注</code>。</p><h3 id="2-1-跟踪树与span"><a href="#2-1-跟踪树与span" class="headerlink" title="2.1 跟踪树与span"></a>2.1 跟踪树与span</h3><p>在 Dapper 跟踪树中，树节点是基本单元，我们称之为 <code>span</code>。节点之间的连线表示 span 与其<code>父span</code> 之间的关系。虽然节点在整个跟踪树中的位置是独立的，但 span 也是一个简单的时间戳日志，其中编码了这个 span 的开始时间、结束时间、RPC 时间数据、以及 0 或多个应用程序相关的标注，我们将在 2.3 节讨论这些内容。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-09-Dapper/img_1.png" alt="dapper-2_span"></p><p><em>(图-2. Dapper 跟踪树中5个 span 的因果和实时关系)</em></p><p>图2 阐释了 span 是如何构造成更大的跟踪结构的。Dapper 为每个 span 记录了一个可读的<code>span name</code>、<code>span id </code>和 <code>parent id</code>，这样就能重建出一次分布式跟踪过程中不同 span 之间的关系。没有parent id 的 span被称为 <code>根span</code>。一次特定跟踪的所有相关 span 会共享同一个通用的<code>trace id</code> （trace id在图中没有绘出）。所有这些 ID 可能是唯一的 64 位整数。在一个典型的 Dapper 跟踪中，我们希望每个 RPC 对应一个 span，每一个组件层对应跟踪树上的一个层级。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-09-Dapper/img_2.png" alt="dapper-3_span_detail"></p><p><em>(图-3. span 的详细视图)</em></p><p>图3 给出了 Dapper 跟踪 span 中记录的事件的更详细视图。这个 span 标示图 2 中更长的那次 <code>Helper.Call</code> RPC 调用。Dapper 的 RPC 库记录下了 span 的开始时间和结束时间、RPC 的计时信息。如果应用程序负责人选择用他们自己的标注来注释这次跟踪（例如图中的<code>foo</code>），那么这些信息也会跟随 span 的其他信息一起记录下来。</p><p>要着重强调的是，一个 span 中的信息可能来自多个不同的主机；实际上，每个 RPC span 都包含 client和 server 端的标注，这使得<code>二主机span (two host span)</code>是最常见的情况。由于 client 和 server 的时间戳来自不同的主机，所以我们需要注意时钟偏差。在我们的分析工具中，我们利用了如下事实：RPC client 发送请求总是会先于 server 接受到请求，对于 server 响应也是如此。这样一来，RPC server 端的 span 时间戳就有了下限和上限。</p><h3 id="2-2-植入点-Instrumention-points"><a href="#2-2-植入点-Instrumention-points" class="headerlink" title="2.2 植入点 Instrumention points"></a>2.2 植入点 Instrumention points</h3><p>通过对部分通用库进行植入，Dapper 能够做到在对应用程序开发者零干扰的情况下进行分布式路径跟踪：</p><ul><li>当一个线程处理被跟踪的控制路径时，Dapper 会把一个<code>跟踪上下文（trace context）</code>存储到ThreadLocal 中。跟踪上下文是一个小而容易复制的容器，里面包含了 trace id 和 span id 等 span 属性。</li><li>当计算过程是延迟调用或异步执行时，多数 Google 开发者会使用一个通用的控制流程库来构造回调函数，并用线程池或其他 executor 来执行回调。Dapper 确保所有的回调都会存储其创建者的跟踪上下文，而当执行回调时这个跟踪上下文会关联到合适的线程上。通过这种方式，Dapper 用于重建跟踪的 ID 也能透明地用于异步控制流程。</li><li>Google 进程间的通讯几乎都是建立在一个用 C++ 和 Java 开发的 RPC 框架上。我们在这个框架上进行性能测量，定义了所有 RPC 调用相关的 span。被跟踪的 RPC 调用的 span id 和 trace id 会从客户端传送到服务端。对于这种在Google内广泛使用的基于RPC的系统来说，这是一个非常必要的性能测量点。我们计划当非 RPC 通讯框架发展成熟并找到其用户群后，再对非 RPC 通信框架进行性能测量。</li></ul><p>Dapper 的跟踪数据是语言无关的，生产环境中的许多跟踪结合了 C++ 和 Java 进程中的数据。在 3.2 节我们将讨论我们在实践中达到了何种程度的应用程序透明。</p><h3 id="2-3-标注-Annotation"><a href="#2-3-标注-Annotation" class="headerlink" title="2.3 标注 Annotation"></a>2.3 标注 Annotation</h3><p>上述性能测量点足够推导出复杂分布式系统的跟踪细节，这使得 Dapper 的核心功能也适用于那些不可修改的 Google 应用程序。然而，Dapper 也允许应用程序开发者添加额外的信息，以丰富 Dapper 的跟踪数据，从而帮助监控更高级别的系统行为，或者帮助调试问题。我们允许用户通过一个简单的 API 来定义带时间戳的标注，其核心代码如图4 所示。这些标注支持任意内容。为了保护 Dapper 用户不至于意外加入太多日志，每个跟踪 span 都可配置一个标注量的上限。应用程序级别的标注是不能替代结构化的 span 信息以及 RPC 信息的。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-09-Dapper/img_3.png" alt="dapper-4_annotation"></p><p><em>(图-4. Dapper 标注 API 在 C++ 和 Java 中的通用使用模式)</em></p><p>除了简单的文本标注，Dapper 也支持 key-value map 的标注，给开发者提供更强的跟踪能力，例如维护计数器、记录二进制消息、传输任意用户自定义的数据。这些 key-value 标注可用于在分布式跟踪上下文中定义应用程序相关的对等类（equivalence classes）。</p><h3 id="2-4-采样-Sampling"><a href="#2-4-采样-Sampling" class="headerlink" title="2.4 采样 Sampling"></a>2.4 采样 Sampling</h3><p>Dapper 的一个关键设计目标是低损耗，因为如果一个新工具的价值还未证实，而对性能有影响的话，服务运维人员是不会愿意去部署这个工具的。而且，我们还想要允许开发人员使用标注 API，而无需担心额外的损耗。我们同时也发现 web 服务确实对性能测量的损耗很敏感。所以，除了把 Dapper 的基本性能测量损耗限制得尽可能小，我们还通过仅记录一部分跟踪信息，来进一步降低损耗。我们将在 4.4 节详细讨论这种跟踪采样模式。</p><h3 id="2-5-跟踪收集"><a href="#2-5-跟踪收集" class="headerlink" title="2.5 跟踪收集"></a>2.5 跟踪收集</h3><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-09-Dapper/img_4.png" alt="dapper-5_collection"></p><p><em>(图-5. Dapper 收集管道概览)</em></p><p>Dapper 的跟踪记录和收集管道分为三个阶段（如图5）。首先，把 span 数据写入(1) 到本地日志文件。然后 Dapper 守护进程从所有生产主机中将他们拉取出来(2)，最终写入(3) 到 Dapper 的 Bigtable 仓库中。Bigtable 中的行表示一次跟踪，列表示一个 span。Bigtable 对稀疏表格布局的支持正适合这种情况，因为每个跟踪都可能有任意多个 span。跟踪数据收集即将应用程序二进制数据传输到中央仓库，其延迟中位数小于 15 秒。98 分位延迟呈现双峰形；大约 75% 时间里，98 分位延迟小于 2 分钟，但是在另外 25% 时间里可能会涨到几小时。</p><p>Dapper 还提供了一个 API 来简化对仓库中跟踪数据的访问。Google 开发者利用这个API来构造通用的或者特定应用程序的分析工具。5.1 节将介绍这个 API 的使用。</p><h4 id="2-5-1-带外？（out-of-band）跟踪收集"><a href="#2-5-1-带外？（out-of-band）跟踪收集" class="headerlink" title="2.5.1 带外？（out-of-band）跟踪收集"></a>2.5.1 带外？（out-of-band）跟踪收集</h4><p>Dapper 系统在请求树 <code>带外(out-of-band)</code> 进行日志跟踪与收集。这样做有两个原因：首先，带内收集模式（in-band collection scheme）通过 RPC 响应头回传跟踪数据，这会影响应用的网络动态。Google 的许多大型系统里，一次跟踪有几千个 span 的情况并不少见。而即便是在大型分布式跟踪的根节点附近，RPC 响应仍然是相当小的：通常小于 10K。在这种情况下，带内跟踪数据会影响应用数据，并且使后续的分析结果产生偏差。其次，带内收集模式假定所有 RPC 调用时完美嵌套的。而我们发现许多中间件系统会在其后端服务返回最终结果前，返回一个结果给其调用者。带内收集系统不能适用于这种非嵌套的分布式执行模式。</p><h3 id="2-6-安全和隐私考虑"><a href="#2-6-安全和隐私考虑" class="headerlink" title="2.6 安全和隐私考虑"></a>2.6 安全和隐私考虑</h3><p>记录 RPC payload 信息会丰富 Dapper 的跟踪能力，因为分析工具可能能从 payload 数据中找到导致性能异常的模式。然而在某些情况下，payload 数据可能会包含一些信息，这些信息不应该暴露给非授权内部用户，包括正在调试性能的工程师。</p><p>由于安全和隐私是不可忽略的问题，所以 Dapper 存储了 RPC 方法名，但不会存储任何 payload 数据。相反，应用级别的标注则提供了一个方便的可选机制：应用开发人员可以选择将那些对以后分析有用的任何数据关联到一个 span 上。</p><p>Dapper 还提供了一些设计者没料到的安全性好处。例如 Dapper 通过跟踪公开的安全协议参数，用来监控应用是否满足认证或加密的安全策略。Dapper 还可以提供信息以确保系统是否执行了预期的基于策略的隔离，例如承载敏感数据的应用不与未授权的系统组件交互。这种方法可比代码审核强多了。</p><h2 id="3-Dapper-的部署状况"><a href="#3-Dapper-的部署状况" class="headerlink" title="3 Dapper 的部署状况"></a>3 Dapper 的部署状况</h2><p>我们把 Dapper 作为生产环境跟踪系统超过两年了。本节我们将汇报 Dapper 系统的状态，着重讲解Dapper 如何很好地满足大范围部署、应用级透明等目标的。</p><h3 id="3-1-Dapper-运行时库"><a href="#3-1-Dapper-运行时库" class="headerlink" title="3.1 Dapper 运行时库"></a>3.1 Dapper 运行时库</h3><p>Dapper 代码中最关键的部分也许就是对基础 RPC、线程、控制流库的性能测量了，包含创建 span、采样以及记录到本地磁盘。我们的代码不仅需要轻量，还需要稳定、健壮，因为它与海量应用连接，维护和 bug 修复是很困难的。我们的C++ 性能测量的核心代码少于 1000 行，而 Java 代码则少于 800 行。key-value 标注的代码实现额外有 500 行代码。</p><h3 id="3-2-生产环境覆盖率"><a href="#3-2-生产环境覆盖率" class="headerlink" title="3.2 生产环境覆盖率"></a>3.2 生产环境覆盖率</h3><p>Dapper 的渗透率可以通过两方面来衡量：其一是可以<strong>产生</strong> Dapper 跟踪的生产环境进程比率（即与 Dapper 性能测量运行时库连接的那些），其二是运行 Dapper 跟踪<strong>收集</strong>守护进程的生产环境机器比率。Dapper 守护进程是我们基本机器镜像的一部分，所以实际上它在 Google 的每台服务器上都有。很难确定 Dapper-ready 进程精确比率，因为那些不产生跟踪信息的进程是对 Dapper 不可见的。尽管如此，因为 Dapper 性能测量库几乎无处不在，我们估么着几乎每一个 Google 生产环境进程都支持跟踪。</p><p>在有些情况下 Dapper 不能正确地跟踪控制流程。这通常是由于使用了非标准的控制流程，或是由于Dapper 错误地将因果关系归到无关的事件上。Dapper 提供了一个简单的库作为一种变通方法，可以帮助开发者手动控制跟踪的传播。目前有 40 个 C++ 应用和 33 个 Java 应用需要手工的跟踪传播，这对总计几千个应用来说只是很小的一部分。还有很小一部分程序使用的是没有性能测量的通讯库（例如通过原生 TCP Socket 或者 SOAP RPC），所以是不支持 Dapper 跟踪的。但如果真的需要的话，这些应用也可以做到支持 Dapper。</p><p>为了生产环境的安全性，Dapper 跟踪是可以被关闭的。实际上在早期它默认是关闭的，直到我们对Dapper 的稳定性和低损耗有信心之后，我们才把它开启了。Dapper 团队偶尔会进行审计检查配置文件的变化，找到那些关闭了跟踪配置的服务。这种变化很少见，并且通常是因为担心监控的消耗。经过对实际消耗的进一步调查和衡量，发现其消耗已经很小了，所以现在这些改动都已经被回退回去了。</p><h3 id="3-3-跟踪标注的使用"><a href="#3-3-跟踪标注的使用" class="headerlink" title="3.3 跟踪标注的使用"></a>3.3 跟踪标注的使用</h3><p>程序员们喜欢用应用程序特定的标注来作为一种分布式调试日志文件，或者通过应用程序的特定功能来对跟踪进行分类。例如所有 Bigtable 的请求都标注了访问的表名。目前 Dapper 中 70% 的 span 和 90% 的 trace 都至少有一个应用指定的标注。</p><p>我们有 41 个 Java 应用和 68 个 C++ 应用添加了自定义的标注以便更好地理解 span 内的行为。值得注意的是 Java 开发者在每个 span 上加的标注比 C++ 开发者更多，这也许是因为 Java 的负载更接近最终用户；这类应用经常处理更广的请求，所以控制路径也相对更复杂。</p><h2 id="4-管理跟踪损耗"><a href="#4-管理跟踪损耗" class="headerlink" title="4 管理跟踪损耗"></a>4 管理跟踪损耗</h2><p>跟踪系统的成本是由于生成追踪和收集数据造成的系统性能下降，以及用来存储和分析跟踪数据的资源量。尽管你可以说一个有价值的跟踪系统即便造成一点性能损耗也是值得的，但是我们相信如果基线损耗达到可以忽略的程度，那么一定会对跟踪系统的最初推广大有裨益。</p><p>本节我们将展示 Dapper 性能测量操作的消耗、跟踪收集的消耗、以及 Dapper 对生产环境负载的影响。同时还会介绍 Dapper 的适应性采样机制是如何帮助我们平衡低损耗的需求与代表性跟踪的需求。</p><h3 id="4-1-跟踪生成的损耗"><a href="#4-1-跟踪生成的损耗" class="headerlink" title="4.1 跟踪生成的损耗"></a>4.1 跟踪生成的损耗</h3><p>跟踪生成的损耗是 Dapper 性能影响中最重要的部分，因为收集和分析可以在紧急情况下关闭掉。Dapper 运行库生成跟踪的消耗最重要的原因是创建销毁 span 和标注、以及记录到本地磁盘以便后续的收集。非根 span 的创建和销毁平均需要 176 纳秒，而根 span 则需要 204 纳秒。这个差别是因为要对根 span 分配全局唯一 trace id 的时间。</p><p>如果一个 span 没有被采样的话，那么额外标注的成本则几乎可以忽略不计，只需 Dapper 运行时在ThreadLocal 中查找，平均花费 9 纳秒。而如果这个 span 被采样的话，对 span 进行字符串标注（见图4）则平均需要花费 40 纳秒。这些数据都是基于 2.2GHz x86 服务器测量得出的。</p><p>Dapper 运行时库最昂贵的操作就是写入本地磁盘了，不过这个损耗可以大大减少，因为每个磁盘都会合并对多个日志文件写入操作，并且相对于被跟踪的应用系统来说是异步执行的。尽管如此，日志写入对高吞吐量系统仍然可能有可见的性能影响，尤其是当所有请求都都被跟踪时。在 4.3 节我们对一次Web 搜索过程中生成跟踪的损耗进行了量化。</p><h3 id="4-2-跟踪收集的损耗"><a href="#4-2-跟踪收集的损耗" class="headerlink" title="4.2 跟踪收集的损耗"></a>4.2 跟踪收集的损耗</h3><p>读出本地的跟踪数据也会对正在监控的系统产生影响。表1 展示了在高于实际负载的测试情况下，Dapper 守护进程 CPU 使用率的最坏情况。</p><table><thead><tr><th align="right">Process Count (per host)</th><th align="right">Data Rate (per process)</th><th align="right">Daemon CPU Usage (single CPU core)</th></tr></thead><tbody><tr><td align="right">25</td><td align="right">10K&#x2F;sec</td><td align="right">0.125%</td></tr><tr><td align="right">10</td><td align="right">200K&#x2F;sec</td><td align="right">0.267%</td></tr><tr><td align="right">50</td><td align="right">2K&#x2F;sec</td><td align="right">0.130%</td></tr></tbody></table><p><em>(表-1. Dapper 守护进程在负载测试中 CPU 资源使用率)</em></p><p>Dapper 守护进程在跟踪收集过程中，对生产环境单核 CPU 的占用率从未超过 0.3%，并且内存占用也很小。同时我们把 Dapper 守护进程在内核 scheduler 中的优先级限制到尽可能最低，以防在高负载机器上出现 CPU 竞争。</p><p>Dapper 对网络资源的消耗也轻量，我们仓库中每个 span 平均只有 426 byte。Dapper 跟踪数据在Google 生产环境中占用的网络流量小于 0.01%。</p><h3 id="4-3-对生产环境负载的影响"><a href="#4-3-对生产环境负载的影响" class="headerlink" title="4.3 对生产环境负载的影响"></a>4.3 对生产环境负载的影响</h3><p>高吞吐量的在线服务处理每个请求都会用到大量的机器，这种在线服务最有需求进行高效的跟踪；他们会生成大量的跟踪数据，同时也对性能影响是最敏感的。在表2 中我们用 web 搜索集群作为例子，通过调整采样率，来测量 Dapper 对平均延迟和吞吐量的性能影响。</p><table><thead><tr><th align="right">Sampling frequency</th><th align="right">Avg. Latency (% change)</th><th align="right">Avg. Throughput (% change)</th></tr></thead><tbody><tr><td align="right">1&#x2F;1</td><td align="right">16.3%</td><td align="right">-1.48%</td></tr><tr><td align="right">1&#x2F;2</td><td align="right">9.40%</td><td align="right">-0.73%</td></tr><tr><td align="right">1&#x2F;4</td><td align="right">6.38%</td><td align="right">-0.30%</td></tr><tr><td align="right">1&#x2F;8</td><td align="right">4.12%</td><td align="right">-0.23%</td></tr><tr><td align="right">1&#x2F;16</td><td align="right">2.12%</td><td align="right">-0.08%</td></tr><tr><td align="right">1&#x2F;1024</td><td align="right">-0.20%</td><td align="right">-0.06%</td></tr></tbody></table><p><em>(表-2. Dapper 采样频率对 Web 搜索集群延迟及吞吐量的影响。延迟及吞吐量的实验误差分别为 2.5% 和 0.15%)</em></p><p>可以看到，虽然对吞吐量的影响不是很明显，但为了避免明显的延迟，跟踪采样还是非常有必要的。然而，当采样率小于 1&#x2F;16 时的延迟和吞吐量损失是在实验误差范围内的。实践中，我们发现对于高容量服务来说，即便把采样率设为 1&#x2F;1024 这样低，仍然能够得到足够多的跟踪数据。保持 Dapper 的性能损耗基线极其低是很重要的，因为这就能为应用程度提供一个宽松的环境来使用完整的标注 API，而无需担心性能损失。使用低采样率还有一个额外的好处，可以让主机磁盘中的数据在被垃圾回收之前能持久化更长的时间，这就让收集组件有了更多的灵活性。</p><h3 id="4-4-适应性采样"><a href="#4-4-适应性采样" class="headerlink" title="4.4 适应性采样"></a>4.4 适应性采样</h3><p>Dapper 对于任何给定进程的损耗是与单位时间内进程跟踪的数目成正比的。Dapper 的第一个生产版本在 Google 的几乎所有进程上使用同一个采样率，每 1024 个候选中平均采样一个。这个简单的方案对高吞吐量在线服务是有效的，因为大多数我们感兴趣的事件仍然会经常出现并被捕捉到。</p><p>然而，低流量的服务在这种低采样率下就可能会错失重要的事件，而更高采样率带来的性能损耗是可接受的。针对这种系统的解决方案是覆盖默认采样率，而这就需要手工干预，我们不想在 Dapper 中出现这种手工干预。</p><p>我们正在部署一种适应性的采样机制，不使用统一的采样率，而使用单位时间内的期望采样率。这样，低流量负载会自动提高采样率，而高流量负载则会自动降低采样率，从而掌控损耗。实际采样率会和跟踪数据一起记录下来；这有利于在基于 Dapper 数据的分析工具中精准使用采样率。</p><h3 id="4-5-应对激进采样"><a href="#4-5-应对激进采样" class="headerlink" title="4.5 应对激进采样"></a>4.5 应对激进采样</h3><p>Dapper 新用户往往觉得低采样率（高流量服务中通常会低于 0.01%）会干扰他们的分析。我们在Google 中应用的经验让我们相信，对于高吞吐量服务来说，激进采样并不会妨碍最重要的那些分析。如果一个重要的执行模式在这种系统中出现过一次，那么就会出现上千次。每秒请求几十次而不是上万次的那些低流量服务则可以承受跟踪每一个请求；这驱动着我们往适应性采样方向前进。</p><h3 id="4-6-收集过程中的额外采样"><a href="#4-6-收集过程中的额外采样" class="headerlink" title="4.6 收集过程中的额外采样"></a>4.6 收集过程中的额外采样</h3><p>上述采样机制用来尽量减少与 Dapper 运行时库协作的应用程序中的性能损耗。Dapper 团队还需要控制写入中央仓库的数据量，为此我们引入了第二轮采样。</p><p>目前我们生产集群每天产生超过 1 TB 的采样跟踪数据。Dapper 用户希望跟踪数据从生产进程中记录下来后最少保留两周时间。逐渐增长的跟踪数据带来了好处，同时 Dapper 仓库的机器和磁盘存储成本也在增加，我们需要作出权衡。对请求的高采样率还会使得 Dapper 收集器接近 Dapper Bigtable 仓库的写入吞吐量极限。</p><p>为了维持物资资源的需求和 Bigtable 的累积写入吞吐量之间的灵活性，我们在收集系统自身上增加了额外的采样。一个特定 trace 中的所有 span 都共享同一个 trace id，即便这些 span 可能横跨数千个不同的主机。<strong>对于在收集系统中的每个 span，我们将其 trace id 哈希成一个标量 z （0&lt;&#x3D;z&lt;&#x3D;1）。如果 z 小于我们的收集采样系数，我们就保留这个 span 并将它写入 Bigtable；否则就丢弃</strong>。在采样决策中通过依靠 trace id，我们要么采样整个 trace，要么抛弃整个 trace，而不会对 trace 中的某些span进行处理。我们发现这种额外配置参数让我们对收集管道的管理变得简单得多，因为可以很容易地调整全局写入率，仅仅修改配置文件中的一个参数即可。</p><p>如果整个跟踪和收集系统都是用同一个采样参数则会更简单，但是那样就无法灵活地快速调整所有部署环境中的运行时采样配置。我们选择的运行时采样率产生的数据会稍微高于我们能写入仓库的数据，而我们可以通过调整收集系统中的二级采样参数对写入速度进行限流。因为我们可以通过对二级采样配置一下就能增加或减少全局覆盖率和写入速率，所以 Dapper 管道的维护工作变得更简单了。</p><h2 id="5-通用-Dapper-工具"><a href="#5-通用-Dapper-工具" class="headerlink" title="5 通用 Dapper 工具"></a>5 通用 Dapper 工具</h2><p>几年前当 Dapper 还是一个原型时，在开发者的耐心支持下才能把 Dapper 用起来。从那时起，我们逐渐建立了收集组件、编程接口、以及基于 web 的用户交互界面，帮助 Dapper 用户独立地解决自己的问题。本节将总结哪些方法有用，哪些没用，并提供这些通用的分析工具的基本使用信息。</p><h3 id="5-1-Dapper-Depot-API"><a href="#5-1-Dapper-Depot-API" class="headerlink" title="5.1 Dapper Depot API"></a>5.1 Dapper Depot API</h3><p>Dapper Deport API 又称 DAPI，通过它可以直接访问 Dapper 区域仓库中的分布式跟踪数据。DAPI 和 Dapper 跟踪仓库是串行设计的，DAPI 意在为 Dapper 仓库中的原始数据提供一个干净而直观的接口。我们的用例推荐如下三种方式来访问跟踪数据：</p><p><strong>通过 trace id 访问（Access by trace id）：</strong>DAPI 可以根据全局唯一的 trace id 来加载任何一次跟踪。</p><p><strong>批量访问（Bulk access）：</strong>DAPI 可通过 MapReduce 来并行访问数亿条 Dapper 跟踪数据。用户重写一个虚拟函数，它的唯一参数接受一个 Dapper 跟踪信息，然后框架将会对用户指定时间窗口内的每一条跟踪信息调用一次该函数。</p><p><strong>索引访问（Indexed access）：</strong>Dapper 仓库支持一个唯一索引，可用于匹配我们通用的访问模式。该索引将通用请求的跟踪特性映射到特定的 Dapper 跟踪。因为 trace id 是伪随机创建的，所以这是快速访问某个特定服务或特定主机追踪信息的最佳方式。</p><p>所有这三种访问方式都将用户引导到特定的 Dapper 追踪记录。正如 2.1 节所述，Dapper 的跟踪信息是由 trace span 组成的树，所以 <code>Trace</code> 数据结构就是一个由不同 <code>Span</code> 结构组成的遍历树。Span 通常对应 RPC 调用，在这种情况下，RPC 的耗时信息是有的。通过 span 结构还可访问基于时间戳的引用标注信息。</p><p>选择合适的用户索引是 DAPI 设计中最具挑战性的部分。索引要求的压缩存储只比实际数据本身小 26%，所以成本是巨大的。最初我们部署了两个索引：<strong>一个是主机索引，另一个是服务名索引</strong>。然而我们发现相对于存储成本来说，用户对主机索引的兴趣尚不足够。当用户对某台机器的跟踪感兴趣的时候，他们也会对特定的服务感兴趣，所以我们最终将这两个索引合并成一个组合索引，允许按服务名、主机、时间戳高效地进行查找。</p><h4 id="5-1-1-DAPI-在-Google-内部的使用"><a href="#5-1-1-DAPI-在-Google-内部的使用" class="headerlink" title="5.1.1 DAPI 在 Google 内部的使用"></a>5.1.1 DAPI 在 Google 内部的使用</h4><p>Dapper 在 Google 的使用有三类：使用 DAPI 的持久在线 web 应用，可在命令行启动的维护良好的基于 DAPI 的工具，以及编写、运行、然后即被遗忘的一次性分析工具。我们知道的有3 个基于 DAPI 的持久性应用、8个基于 DAPI 的分析工具、约15~20个一次性分析工具。在这之后就很难统计这些工具了，因为开发者可以构建、运行、然后丢弃，而不需要让 Dapper 团队知道。</p><h3 id="5-2-Dapper-用户接口"><a href="#5-2-Dapper-用户接口" class="headerlink" title="5.2 Dapper 用户接口"></a>5.2 Dapper 用户接口</h3><p>绝大多数情况下，人们通过基于 web 的用户交互接口来使用 Dapper。篇幅所限我们不能展示每一个特性，不过图6 列出了一个典型的用户工作流。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-09-Dapper/img_5.png" alt="dapper-6_workflow"></p><p><em>(图-6. 通用 Dapper 用户接口中的一个典型用户工作流)</em></p><ol><li>用户输入他们关心的服务名以及时间窗口，再加上任何需要来区分跟踪模式的信息（例如span名称）。同时指定与他们的搜索最相关的成本度量（例如服务响应时间）。</li><li>然后就会出现一个性能概要的大表格，总结了与给定服务相关的所有分布式执行模式。用户可以根据他们的需要对执行模式进行排序，并选择其中一个查看更多细节。</li><li>一旦选中一个分布式执行模式，用户则会看到关于这个执行模式的图形化描述。被选中的服务在图表中央被高亮显示。</li><li>在创建与第 1 步选中的成本度量相关的统计信息后，Dapper 用户界面会展示一个简单的频率直方图。所以在这个例子中，我们能看到选中的执行模式相关的响应时间大概是对数正态分布的。用户还会看到一个特定跟踪样例的列表，这些样例分布在直方图的不同区间。本例中，用户点击第二个跟踪样例，在 Dapper 用户界面打开跟踪详细视图。</li><li>绝大多数 Dapper 用户最终会检查特定的跟踪，希望收集系统行为根本原因的信息。我们没有足够的空间去做跟踪视图的审查，但我们有个全局时间线，并能交互地展开或折叠子树，这是我们的特点。分布式跟踪树的连续层用内嵌的不同颜色的矩形表示。每个 RPC span 分为服务进程处理时间（绿色）和网络消耗时间（蓝色）。用户标注没有显示在这个截图中，不过可以以 span 为基础将他们选择性地包含在全局时间线上。</li></ol><p>对于想查询实时数据的用户，Dapper 用户界面支持直接与每台生产环境服务器上的守护进程通信。在这个模式下，不能像上图那样查看系统级别的图表，不过仍然很容易地基于耗时和网络特性选择一个跟踪。在这个模式下，可在几秒内实时地查到数据。</p><p>根据我们的日志，每个工作日大概有 200 个 Google 工程师使用 Dapper UI；每周大约有 750 到 1000个独立用户访问。忽略掉发布新功能的因素，这个数据每个月都是一致的。用户通常会发送出特定跟踪的链接，这会不可避免地在跟踪查询中产生很多一次性的、短期的流量。</p><h2 id="6-经验"><a href="#6-经验" class="headerlink" title="6 经验"></a>6 经验</h2><p>Dapper 在 Google中被广泛使用，通过 Dapper 用户界面直接访问，或者通过编程 API 以及基于这些API 构建的程序访问。本节我们不打算罗列出每一种已知的 Dapper 的使用方式，而会尝试讲解 Dapper 使用的”基本向量”，阐述何种应用是最成功的。</p><h3 id="6-1-开发过程中使用-Dapper"><a href="#6-1-开发过程中使用-Dapper" class="headerlink" title="6.1 开发过程中使用 Dapper"></a>6.1 开发过程中使用 Dapper</h3><p>Google AdWords 系统建立在关键词定位准则和相关文字广告的大型数据库之上。当新的关键词被插入或修改时，必须对他们进行校验，以遵循服务策略条款（例如检查不恰当的语言）；这个过程使用自动审查系统来做的话会更有效率。</p><p>当从头开始重新设计一个广告审查服务时，团队从第一个系统原型开始，直到最终的系统维护，都使用了 Dapper。他们的服务通过 Dapper 有了以下方面的提高：</p><p><strong>性能（Performance）：</strong>开发人员跟踪请求延迟目标的进度，精确找到可优化的机会。Dapper 还被用来找出关键路径中的不必要请求序列（这种不必要请求通常源于不是开发者自己开发的子系统），然后促使相关团队修复这些问题。</p><p><strong>正确性（Correctness）：</strong>广告审查服务是围绕大型数据库系统的。系统同时具有只读副本服务器（廉价访问），以及可读写的主服务器（昂贵访问）。他们通过 Dapper 找到了好些不必要地访问主服务器而不是访问副本服务器的查询。Dapper 现在可用于解释主服务器被直接访问的原因，确保重要系统的不变式。</p><p><strong>理解性（Understanding）：</strong>广告审查查询跨越多种类型的系统，包括 Bigtable（即前文提到的数据库）、多维索引服务、以及许多其他 C++ 和 Java 后端服务。Dapper 跟踪用来评估总查询成本，促进对业务重新设计，使得系统依赖的负载最小。</p><p><strong>测试（Testing）：</strong>新代码的发布会经过一个 Dapper 跟踪的 QA 过程，验证正确的系统行为和性能。这个过程中发现了很多问题，包括广告审查代码自身的问题，及其依赖包的问题。</p><p>广告审查团队广泛使用了 Dapper 标注 API。Guice<sup>[13]</sup> 开源的 AOP 框架用来在重要的软件组件上标注 <code>@Traced</code>。跟踪信息进一步标注的信息有重要子程序的输入输出大小、状态消息、以及其他调试信息；否则这些信息会被发到日志文件中。</p><p>Dapper 在广告审查团队的应用有一些不足的地方。例如，他们想在交互时间内搜索所有的跟踪标注，然而必须运行自定义的 MapReduce 或者手工检查每个跟踪。另外，Google 内还有其他的系统对通用目的的调试日志进行收集并进行集中化，把这些系统中的海量数据和 Dapper 仓库进行整合是有价值的。</p><p>即便如此，总的来说广告审查团队估计通过 Dapper 跟踪平台的数据分析，他们的延迟数据已经优化了两个数量级。</p><h4 id="6-1-1-与异常监控的集成"><a href="#6-1-1-与异常监控的集成" class="headerlink" title="6.1.1 与异常监控的集成"></a>6.1.1 与异常监控的集成</h4><p>Google 维护了一个从运行进程中不断收集并集中异常报告的服务。如果这些异常发生在被采样的Dapper 跟踪中，则异常报告中会包含相关的 trace id 和 span id。然后异常监控服务前端就会在特定异常报告里提供一个链接，指向相应分布式跟踪。广告审查团队利用这个特性，来了解异常监控服务发现的那些 bug 的更大范围的上下文。Dapper 平台通过导出基于简单唯一 ID 构建的接口，相对容易地集成到其他事件监控系统中。</p><h3 id="6-2-解决长尾延迟"><a href="#6-2-解决长尾延迟" class="headerlink" title="6.2 解决长尾延迟"></a>6.2 解决长尾延迟</h3><p>由于移动部件的数量、代码库及部署的规模，调试一个像全文搜索（universal search）那样的服务是非常有挑战性的。这里我们描述在减轻全文搜索延迟分布的长尾效应上做的努力。Dapper 能够验证端到端延迟的假设，更具体地说，它能够<strong>验证全文搜索请求的关键路径</strong>。当系统不仅涉及多个子系统，还涉及多个开发团队时，即便我们最好最有经验的工程师也经常猜错端到端性能差的根本原因。在这种情况下，Dapper 可以提供必需的事实，可以回答许多重要的性能问题。</p><p>一个工程师在调试长尾延迟的过程中建立了一个小型库，可以根据 DAPI <code>Trace</code>对象推断出层次性的关键路径。这些关键路径结构可用来诊断问题、为全文搜索可预期的性能改进调整优先级。Dapper 的这项工作引出了下列发现：</p><ul><li>关键路径上短暂的网络性能退化不会影响系统吞吐量，但能对延迟异常值产生巨大影响。在图7 中，大多数全文搜索的慢跟踪都在关键路径上有网络退化。<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-12-09-Dapper/img_6.png" alt="dapper-7_network-lag"><br><em>(图-7. 关键路径上遇到非正常网络延迟的全文搜索跟踪，与端到端请求延迟的关系)</em></li><li>许多有问题的昂贵查询模式都源自服务间不经意的交互。一旦发现，他们往往很容易纠正；但是在没有 Dapper 时如何发现他们是很困难的。</li><li>通用查询是从 Dapper 之外的安全日志仓库中获取，并且使用 Dapper 的唯一 trace id，与Dapper 仓库做关联。这种映射随后被用于构建全文搜索每个独立子系统中的慢查询列表。</li></ul><h3 id="6-3-推断服务依赖"><a href="#6-3-推断服务依赖" class="headerlink" title="6.3 推断服务依赖"></a>6.3 推断服务依赖</h3><p>在任意指定时刻，Google 的典型计算集群是成千上万个逻辑”任务”组成；一系列进程执行通用函数。Google 维护着许多这种集群，当然我们发现一个计算集群中的任务往往依赖其他集群中的任务。由于任务间的依赖是动态改变的，所以不可能仅仅从配置信息中推断出所有的服务间依赖。尽管如此，公司内部的许多进程要求知道准确的服务依赖信息，以便找出瓶颈，计划服务的迁移。Google 的”服务依赖”项目通过使用跟踪标注以及 DAPI MapReduce 接口，自动探测服务间的依赖。</p><p>使用 Dapper 核心性能检测以及 Dapper 的跟踪标注，服务依赖项目能够推断出任务之间的依赖关系，还能推断出这些任务所依赖的程序组件。例如，所有 Bigtable 的操作被标记上受影响的表名。通过 Dapper 平台，服务依赖团队就可以自动推断出多种服务粒度的依赖关系。</p><h3 id="6-4-不同服务的网络使用率"><a href="#6-4-不同服务的网络使用率" class="headerlink" title="6.4 不同服务的网络使用率"></a>6.4 不同服务的网络使用率</h3><p>Google 在网络结构上投入了大量的人力物力。毫无疑问，网络运维人员要关注单个硬件的监控信息、自定义工具和 dashboard，来查看全局网络使用情况的鸟瞰图。网络运维人员可以一览整个网络的健康状况，但是当出现问题时，他们却缺少工具找到网络负载问题在应用级别的罪魁祸首。</p><p>虽然 Dapper 并不是设计用来做链路级的监控，但我们发现它非常适合集群之间网络活动应用级别分析的任务。Google 利用 Dapper 平台得以建立不断更新的终端，来显示集群间网络流量中最活跃的那些应用级别端点。此外，通过 Dapper 我们可以找出引起昂贵网络请求的跟踪，而不是面对孤立的机器。在 Dapper API 之上建立 dashboard 花费的时间没超过两周。</p><h3 id="6-5-分层及共享的存储系统"><a href="#6-5-分层及共享的存储系统" class="headerlink" title="6.5 分层及共享的存储系统"></a>6.5 分层及共享的存储系统</h3><p>Google 的许多存储系统都由多个独立的复杂层次的分布式基础设施组成。例如，Google App Engine<sup>[5]</sup> 就是建立在一个可扩展实体存储系统之上。这个实体存储系统基于底层的 BigTable 暴露出一些 RDBMS 功能。Bigtable 则同时使用 Chubby<sup>[7]</sup>（一个分布式锁系统）及 GFS。此外，像 BigTable这类系统会作为共享服务来管理，以简化部署并更好地利用计算资源。</p><p>在这种分层系统中，并不总是很容易发现终端用户的资源消费模式。例如，给定 BigTable 单元对 GFS 的大量请求可能来自一个用户或者许多用户，而在 GFS 层面这两种不同的使用模式的区别是模糊的。而且，如果缺乏像 Dapper 这种工具的话，对这种共享服务的竞争同样是难以调试的。</p><p>5.2节展示的 Dapper 用户界面可以分组聚合共享服务横跨多个客户端的跟踪性能信息。这就使得共享服务的负责人可以容易地根据多个指标对其用户进行排名（例如根据inbound网络负载、outbound网络负载、或者服务请求的总时间）。</p><h3 id="6-6-用-Dapper-来救火"><a href="#6-6-用-Dapper-来救火" class="headerlink" title="6.6 用 Dapper 来救火"></a>6.6 用 Dapper 来救火</h3><p>Dapper 对于某些救火任务是有用的。这里的”救火”指的是对处于危险中的分布式系统进行的操作。典型情况下，Dapper 用户在进行救火时需要访问新鲜数据，并且没有时间写新的 DAPI 代码，也没时间等待周期性的报告运行。</p><p>对于那些正在经历高延迟的服务，或者更糟的在正常负载下都会超时的服务，Dapper 用户界面通常能把这些延迟的瓶颈隔离出来。通过与 Dapper 守护进程直接通信，可以容易地收集特定高延迟跟踪的新鲜数据。在灾难性故障时，通常没必要分析统计数据来确定根本原因，而查看示例跟踪就足够了。</p><p>然而，6.5 节描述的那种共享存储服务则要求当用户活动突然激增时能快速聚合信息。对于事后检验，共享服务仍然可以利用 Dapper 的聚合数据，但是除非可以在十分钟之内完成对 Dapper 数据的批量分析，否则 Dapper 对共享存储服务的救火就不会那么有用了。</p><h2 id="7-其他经验教训"><a href="#7-其他经验教训" class="headerlink" title="7 其他经验教训"></a>7 其他经验教训</h2><p>虽然我们在 Dapper 上的经验已经基本满足我们的预期，但是也有一些积极的方面是我们没有充分预料到的。我们对非计划中的用例数目感到高兴。除了在第6节描述的一些经验外，还包括资源核算系统，用来检查敏感服务是否遵从指定的通讯模式的工具，RPC 压缩策略的分析工具，等等。这些非计划中的用例一定程度上归功于我们通过一个简单的编程接口开放了跟踪数据存储，这就允许我们利用上这个大得多的社区的创造力。Dapper 对旧系统的支持也比预期更简单，只需要基于新版本的库重新编译即可，这个库提供通用线程、控制流和 RPC 框架。</p><p>Dapper 在 Google 内部的广泛使用还为我们提供了关于其局限性的宝贵反馈。下面我们将介绍一些我们已知的最重要的一些不足之处。</p><p><strong>合并的影响（Coalescing effects）：</strong>Dapper 模型隐式地设想不同子系统一次只会处理一个跟踪请求。在某些情况下，在对一组请求执行操作之前缓冲一些请求会更有效率（例如对磁盘写入进行合并）。在这些情况下，一个跟踪请求可以看做是一个大型工作单元(a traced request can be blamed for a deceptively large unit of work)。此外，如果多个跟踪请求被批量执行，那么只会有一个请求被 span使用，这是因为我们我们对每个跟踪只会有一个唯一 trace id（if multiple traced requests are batched together, only one of them will appear responsible for the span due to our reliance on a single unique trace id for each trace）。我们正在考虑解决方案以识别这种情况，并记录最少的信息来区别这些请求。</p><p><strong>跟踪批处理系统（Tracing batch workloads）：</strong>Dapper 的设计是针对在线服务系统，最初的目标是了解 Google 的用户请求引起的系统行为。然而，离线的数据密集型系统也可以从对性能的洞悉中获益，例如适合 MapReduce 模型的系统。在这种情况下，我们需要把 trace id 关联到一些其他的有意义的工作单元，例如输入数据的 key（或key范围），或是一个 MapReduce shard。</p><p><strong>寻找根本原因（Finding a root cause）：</strong>Dapper 可以有效地确定系统中的哪个部分正在经历速度变慢，但并不总是足够找出问题的根本原因。举个例子，一个请求变慢可能并不是因为他自己的行为，而是因为其他请求还排在他前面。程序可以利用应用级别的标注把队列大小和过载情况转播到跟踪系统。同时，如果这种情况很常见，那么在ProfileMe<sup>[11]</sup> 中提出的成对采样技术就很有用了。它对两个时间重叠的请求进行采样、并观察它们在系统中的相对延迟。</p><p><strong>记录内核级别的信息（Logging kernel-level information）：</strong>内核可见事件的详细信息有时对确定问题根本原因很有用。我们有一些工具能够跟踪或者描述内核的执行，但是要想将这些信息绑定到用户级别的跟踪上下文上，用通用或是不那么突兀的方式是很难的。我们正在研究一种可能的妥协方案，对用户层面上的一些内核级别活动参数做快照，将其关联到一个活动 span 上。</p><h2 id="8-相关工作"><a href="#8-相关工作" class="headerlink" title="8 相关工作"></a>8 相关工作</h2><p>在分布式系统跟踪领域，有一套完整的体系，一些系统主要关注定位到故障位置，另一些系统关注性能优化。Dapper 曾被用于故障发现，但它在发现性能问题、提升对大型复杂系统行为的理解方面更有用。</p><p>Dapper 与黑盒监控系统有关，就像 Project5<sup>[1]</sup>、WAP5<sup>[15] </sup>和 Sherlock<sup>[2]</sup>，黑盒监控系统不依赖于运行时库的性能测量，能够实现更高度的应用级透明。黑盒的缺点是有些不精确，并在统计推断因果路径过程中可能损耗更大。</p><p>对分布式系统的监控来说，显式的基于标注的中间件或应用本身的性能测量或许是更受欢迎的方式。Pip<sup>[14] </sup>和 Webmon<sup>[16] </sup>更依赖于应用级的标注，而 X-Trace<sup>[12]</sup>、Pinpoint<sup>[9] </sup>和 Magpie<sup>[3]</sup> 则侧重对库和中间件的修改。Dapper 更接近后者。Dapper 与 Pinpoint、X-Trace 以及最新版本的 Magpie 类似，使用全局 ID 将分布式系统不同部分的相关事件关联起来。同样和这些系统类似，Dapper 把性能测量隐藏在通用软件模块中，尝试避免标注应用程序。Magpie 放弃使用全局 ID，就不用处理正确传播全局 ID 带来的挑战，而是为每个应用写入<code>事件模式（event schema） </code>并显式地描述事件之间的关系。我们不清楚 schema 在实践中实现透明性到底有多有效。X-Trace 的核心标注需求比 Dapper 更有雄心，不仅在节点边界收集跟踪，还在节点内部不同软件层级间收集跟踪。而我们对于性能测量低损耗的要求迫使我们不能采用这种模式，而是朝着把一个请求连接起来完整跟踪所能做到的最小代价而努力。Dapper 跟踪仍然能通过可选的应用标注来扩展。</p><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h2><p>本文介绍了 Google 生产环境下的分布式系统跟踪平台 Dapper，并汇报了我们开发和使用 Dapper 的经验。Dapper 部署在 Google 的几乎所有系统上，使得大型系统得以被跟踪而无需修改应用程序，同时没有明显的性能影响。通过 Dapper 主跟踪用户界面的受欢迎程度可以看出 Dapper 对开发团队和运维团队的实用性，本文通过一些使用场景的例子也阐明了 Dapper 的实用性，甚至有些使用场景 Dapper 的设计者都未曾预料到。</p><p>据我们所知，本文是第一篇汇报一个大型的生产环境下的分布式系统跟踪框架的论文。实际上我们主要的贡献源于这样一个事实：我们汇报回顾的系统已经被使用超过两年了。我们发现，决定结合最小化应用透明的跟踪功能以及对程序员提供简单的 API 来增强跟踪是非常值得的。</p><p>我们相信，Dapper 比之前基于标注的分布式跟踪系统达到了更高的应用级透明性，只需要很少的人工干预。虽然这也归功于我们计算部署的一定程度上的同质性，但仍然是一个重大的挑战。最重要的是，我们的设计提出了一些实现应用级透明的充分条件，我们希望能够对更异质的环境下的解决方案有所帮助。</p><p>最后，通过把 Dapper 跟踪仓库开放给内部开发者，促使了更多分析工具的产生，而仅仅由 Dapper 团队封闭地独自开发肯定产生不了这么多工具，这大大提高了设计和实现的成就。</p><h2 id="Acknowledgments"><a href="#Acknowledgments" class="headerlink" title="Acknowledgments"></a>Acknowledgments</h2><p>We thank Mahesh Palekar, Cliff Biffle, Thomas Kotzmann, Kevin Gibbs, Yonatan Zunger, Michael Kleber, and Toby Smith for their experimental data and feedback about Dapper experiences. We also thank Silvius Rus for his assistance with load testing. Most importantly, though, we thank the outstanding team of engineers who have continued to develop and improve Dapper over the years; in order of appearance, Sharon Perl, Dick Sites, Rob von Behren, Tony DeWitt, Don Pazel, Ofer Zajicek, Anthony Zana, Hyang-Ah Kim, Joshua MacDonald, Dan Sturman, Glenn Willen, Alex Kehlenbeck, Brian McBarron, Michael Kleber, Chris Povirk, Bradley White, Toby Smith, Todd Derr, Michael De Rosa, and Athicha Muthitacharoen. They have all done a tremendous amount of work to make Dapper a day-to-day reality at Google.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1]  M. K. Aguilera, J. C. Mogul, J. L. Wiener, P. Reynolds, and A. Muthitacharoen. Performance Debugging for Dis- tributed Systems of Black Boxes. In <em>Proceedings of the 19th ACM Symposium on Operating Systems Principles</em>, December 2003.</p><p>[2]  P. Bahl, R. Chandra, A. Greenberg, S. Kandula, D. A. Maltz, and M. Zhang. Towards Highly Reliable Enter- prise Network Services Via Inference of Multi-level De- pendencies. In <em>Proceedings of SIGCOMM</em>, 2007.</p><p>[3]  P.Barham,R.Isaacs,R.Mortier,andD.Narayanan.Mag- pie: online modelling and performance-aware systems. In <em>Proceedings of USENIX HotOS IX</em>, 2003.</p><p>[4]  L. A. Barroso, J. Dean, and U. Ho ̈lzle. Web Search for a Planet: The Google Cluster Architecture. <em>IEEE Micro</em>, 23(2):22–28, March&#x2F;April 2003.</p><p>[5]  T. O. G. Blog. Developers, start your engines. <a href="http://googleblog.blogspot.com/2008/04/developers-">http://googleblog.blogspot.com/2008/04/developers-</a> start-your-engines.html, 2007.</p><p>[6]  T. O. G. Blog. Universal search: The best answer is still the best answer. <a href="http://googleblog.blogspot.com/2007/05/universal-">http://googleblog.blogspot.com/2007/05/universal-</a> search-best-answer-is-still.html, 2007.</p><p>[7]  M. Burrows. The Chubby lock service for loosely- coupled distributed systems. In <em>Proceedings of the 7th USENIX Symposium on Operating Systems Design and Implementation</em>, pages 335 – 350, 2006.</p><p>[8]  F. Chang, J. Dean, S. Ghemawat, W. C. Hsieh, D. A. Wal- lach, M. Burrows, T. Chandra, A. Fikes, and R. E. Gru- ber. Bigtable: A Distributed Storage System for Struc- tured Data. In <em>Proceedings of the 7th USENIX Sympo- sium on Operating Systems Design and Implementation (OSDI’06)</em>, November 2006.</p><p>[9]  M. Y. Chen, E. Kiciman, E. Fratkin, A. fox, and E. Brewer. Pinpoint: Problem Determination in Large, Dynamic Internet Services. In <em>Proceedings of ACM In- ternational Conference on Dependable Systems and Net- works</em>, 2002.</p><p>[10]  J. Dean and S. Ghemawat. MapReduce: Simplified Data Processing on Large Clusters. In <em>Proceedings of the 6th USENIX Symposium on Operating Systems Design and Implementation (OSDI’04)</em>, pages 137 – 150, December 2004.</p><p>[11]  J. Dean, J. E. Hicks, C. A. Waldspurger, W. E. Weihl, and G. Chrysos. ProfileMe: Hardware Support for Instruction-Level Profiling on Out-of-Order Processors. In <em>Proceedings of the IEEE&#x2F;ACM International Sympo- sium on Microarchitecture</em>, 1997.</p><p>[12]  R. Fonseca, G. Porter, R. H. Katz, S. Shenker, and I. Sto- ica. X-Trace: A Pervasive Network Tracing Framework. In <em>Proceedings of USENIX NSDI</em>, 2007.</p><p>[13]  B. Lee and K. Bourrillion. The Guice Project Home Page. <a href="http://code.google.com/p/google-guice/">http://code.google.com/p/google-guice/</a>, 2007.</p><p>[14]  P. Reynolds, C. Killian, J. L. Wiener, J. C. Mogul, M. A. Shah, and A. Vahdat. Pip: Detecting the Unexpected in Distributed Systems. In <em>Proceedings of USENIX NSDI</em>, 2006.</p><p>[15]  P. Reynolds, J. L. Wiener, J. C. Mogul, M. K. Aguilera, and A. Vahdat. WAP5: Black Box Performance Debug- ging for Wide-Area Systems. In <em>Proceedings of the 15th International World Wide Web Conference</em>, 2006.</p><p>[16]  P. K. G. T. Gschwind, K. Eshghi and K. Wurster. Web- Mon: A Performance Profiler for Web Transactions. In <em>E-Commerce Workshop</em>, 2002. </p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 链路追踪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
            <tag> 链路追踪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密文章测试</title>
      <link href="/2024/11/23/2024-10-18-%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/11/23/2024-10-18-%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e8b74bfb4bfab58c133826ef3c15eee479d8f770c53aba51af64de6e4bd830ad">81d8b9e839c65ebd196404e380426b3e6b30e111f22f45bbe27d04db1a6189589c644c6bf3ca7a30b3ad22c6d2028772</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我理解的高并发</title>
      <link href="/2024/11/23/2024-11-23-%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
      <url>/2024/11/23/2024-11-23-%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是高并发？"><a href="#什么是高并发？" class="headerlink" title="什么是高并发？"></a>什么是高并发？</h1><p>我认为大流量就是高并发。应用在某时刻有大量请求涌入，就是高并发。至于电商里的超卖问题则是大流量带来的数据同步问题。类似的问题还有接口响应超时、CPU负载升高、GC频繁、死锁、大数据量存储等等。</p><p>每个业务系统都有自己的高并发，有读多写少的信息流场景、有读多写多的交易场景等等。</p><h1 id="为什么要设计高并发应用"><a href="#为什么要设计高并发应用" class="headerlink" title="为什么要设计高并发应用"></a>为什么要设计高并发应用</h1><p>就三点：高性能、高可用，以及高扩展。</p><ol><li>高性能：响应要快</li><li>高可用：应用不能天天宕机</li><li>高扩展：双十一得支持服务扩容</li></ol><h1 id="高并发衡量指标"><a href="#高并发衡量指标" class="headerlink" title="高并发衡量指标"></a>高并发衡量指标</h1><ol><li>平均响应时间：字如其意。</li><li>TP90、TP99等分位值：将响应时间按照从小到大排序，TP90表示排在第90分位的响应时间。</li></ol><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-11-25-%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91/img.png"></p><ol start="3"><li>吞吐量：每秒钟平均处理多少请求。</li><li>n个9:</li></ol><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-11-25-%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91/img_1.png"></p><h1 id="大量连接的接收处理"><a href="#大量连接的接收处理" class="headerlink" title="大量连接的接收处理"></a>大量连接的接收处理</h1><p>单纯的高并发就是应用只有大量连接涌入，类似ddos攻击。就像大量用户打开手机淘宝挂着不操作，服务端需要维护每个连接。因为每个连接可能会有请求事件发生。当然超时连接优化又是另外一件事了。</p><p>一种优化做法就是采用高效的IO模型，不能是BIO导致同步串行处理连接。</p><p>Linux里有select、poll、epoll三种NIO模型，最为高效的当属epoll了。它用红黑树这种高效的查询结构保存所有连接的文件描述符(fd)。并向内核注册回调函数，网卡收到数据包后产生中断通知网络子系统，由网络子系统调用回调函数把数据写入到文件描述符对应的socket缓冲区里。这意味着该连接产生了IO事件，回调函数还会把该连接的文件描述符封装为就绪队列里的一个节点。应用层调用epoll_wait函数就能通过就绪队列获取到所有有IO事件产生的连接。</p><p>既然谈到连接和请求，就顺便写一个以前困挠过我的问题：</p><h2 id="SpringBoot请求和线程一一对应吗？"><a href="#SpringBoot请求和线程一一对应吗？" class="headerlink" title="SpringBoot请求和线程一一对应吗？"></a>SpringBoot请求和线程一一对应吗？</h2><h3 id="主从Reactor模型"><a href="#主从Reactor模型" class="headerlink" title="主从Reactor模型"></a>主从Reactor模型</h3><p>先用netty的连接处理过程引出主从Reactor模型：</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-11-25-%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91/img_2.png"></p><p>主Reactor就是BossEventLoopGroup，负责处理连接。</p><p>从Reactor就是WorkerEventLoopGroup，负责处理有IO事件的连接。</p><p>关于Reactor模型参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/347779760">https://zhuanlan.zhihu.com/p/347779760</a></p><h3 id="知乎的回答"><a href="#知乎的回答" class="headerlink" title="知乎的回答"></a>知乎的回答</h3><blockquote><p>Spring Boot中线程的维护是由servlet容器或Netty负责，所以题主应该问的是servlet容器的线程模型。而Spring Boot是一个自动配置的框架。目前Spring Boot对web开发目前有两种解决方案：1. 传统的web框架基于Spring MVC + Tomcat，2. Spring 5新增的web-reactive框架基于Spring Webflux + Netty。这两个框架都支持大家熟用的注释，比如@Controller。技术栈可以看官网图，</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-11-25-%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91/img_3.png"></p><p>先不谈web-reactive，通过分析Spring MVC和Tomcat的交互，来浅析一下Spring与servlet容器交互的原理——Spring MVC基于Java EE的Servlet API，Servlet API定义了Servlet容器和具体的servlet代码交互的约定，Spring MVC通过注册一个名为DispatcherServlet的servlet到servlet容器中处理请求，并把实际工作交给Spring提供的组件bean执行。</p><h5 id="Spring和servlet容器的交互"><a href="#Spring和servlet容器的交互" class="headerlink" title="Spring和servlet容器的交互"></a>Spring和servlet容器的交互</h5><p>了解了Spring和servlet容器的交互之后再回到问题。</p><h5 id="连接和请求的区别"><a href="#连接和请求的区别" class="headerlink" title="连接和请求的区别"></a>连接和请求的区别</h5><p>首先题主可能对连接和请求的概念混淆了，这里强调一下连接（TCP）是传输层的，请求（HTTP）是应用层的。在像 HTTP 这样的Client-Server协议中，会话分为三个阶段：</p><ol><li>客户端建立一条 TCP 连接（如果传输层不是 TCP，也可以是其他适合的连接）。</li><li>客户端发送请求并等待应答。</li><li>服务器处理请求并送回应答，回应包括一个状态码和对应的数据。</li></ol><p>从 HTTP&#x2F;1.1 开始，连接在完成第三阶段后不再关闭，客户端可以再次发起新的请求。这意味着第二步和第三步可以连续进行数次。</p><h5 id="请求的处理过程"><a href="#请求的处理过程" class="headerlink" title="请求的处理过程"></a>请求的处理过程</h5><p>其次真的是一个线程处理一个HTTP请求吗？我觉得这个说法也不准确。</p><p>Tomcat支持三种运行模式（BIO, NIO, APR），大致流程均是：</p><p>当客户端向服务器建立TCP连接，发送请求，服务器操作系统将该连接放入accept队列，Tomcat在accept队列中接收连接；在连接中获取请求的数据，生成request；调用servlet容器处理请求；返回response，完成一次HTTP会话。在Tomcat 8.0前默认使用BIO，Tomcat在accept队列中接受TCP连接并获得HTTP Request，从线程池中取出空闲的线程来处理请求，如果无空闲线程则阻塞。Tomcat 8.0起默认启用NIO模式，在从accept获得request之后，注册到nio.Selector中后不阻塞继续获取连接，Tomcat遍历找到selector中可用的request，再从线程池中取出空闲的线程来处理请求。Tomcat相关的配置参数有： </p><ol><li>acceptCount，当accept队列中连接的个数达到acceptCount时，队列满，进来的请求一律被拒绝。</li><li>maxConnections，当Tomcat接收的连接数达到maxConnections时，accept队列中的线程会一直阻塞着。</li><li>maxThreads，线程池线程的最大数量。</li></ol><p>所以无论是BIO，还是NIO，当请求数量大于acceptCount，接收的连接数大于maxConnection时，Tomcat都不会分配线程服务。</p><p>作者：ptyin<br>链接：<a href="https://www.zhihu.com/question/502043167/answer/2268721516">https://www.zhihu.com/question/502043167/answer/2268721516</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>通过引用的知乎回答和上文中的epoll机制以及Reactor主从模型，可以猜想：在tomcat8.0作为servlet容器的SpringBoot里，维护一个线程池。一次调用epoll_wait获取的就绪队列，由线程池里的一个线程负责处理。</p><p>再引用我的语雀知识库里关于netty的一段话：</p><blockquote><p>Selector是Java NIO（New I&#x2F;O）库中的一个核心组件，是对Java平台上的IO多路复用机制的封装. 它内部会根据运行的操作系统选择不同的IO多路复用实现（如select、epoll等）</p><p>监听到channel有事件发生后通知netty，netty将该事件封装成高级事件，如read,write,accept事件等</p><p>根据不同的事件类型选择Channelhandle的不同方法，如ChanelRead方法就是用于处理read事件</p><p>netty服务端有两个EventLoopGroup线程池，Boss和Worker</p><p>Boss只负责处理Accept事件，Cilent被accept之后，它对应的channel会被Worker以负载均衡的模式被注册进eventloopgroup里的某个eventloop的任务队列中</p><p>eventloop需要处理对应队列里每个channel的事件，是无锁串行化执行的，使得系统吞吐量最大化，避免了线程不安全和线程创建销毁的开销。也是由于其串行化执行，一旦有耗时较长的IO操作，就会导致队列阻塞</p><p>可以理解为：eventloopgroup是一个线程池，eventloop是一个线程。</p><p>当然确实如此。只是eventloopgroup这个线程池和JUC里的那些线程池不太一样。</p></blockquote><p><strong>所以，假如有两个客户端各发了一个请求到达使用web-reactive框架的SpringBoot后端，并且它们的channel被注册进同一个eventloop，那么这两个请求确实是由同一个线程处理的。</strong></p><h1 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h1><p>直接参考这篇文章吧</p><p><a href="https://developer.aliyun.com/article/1055458">https://developer.aliyun.com/article/1055458</a></p><h1 id="通用的高并发手段"><a href="#通用的高并发手段" class="headerlink" title="通用的高并发手段"></a>通用的高并发手段</h1><blockquote><p>通用的设计方法主要是从「纵向」和「横向」两个维度出发，俗称高并发处理的两板斧：纵向扩展和横向扩展。</p><p>纵向扩展</p><p>它的目标是提升单机的处理能力，方案又包括：</p><ol><li><p>提升单机的硬件性能：通过增加内存、 CPU核数、存储容量、或者将磁盘 升级成SSD 等堆硬件的方式来提升 。</p></li><li><p>提升单机的软件性能：使用缓存减少IO次数，使用并发或者异步的方式增加吞吐量。</p></li></ol><p>横向扩展</p><p>因为单机性能总会存在极限，所以最终还需要引入横向扩展，通过集群部署以进一步提高并发处理能力，又包括以下2个方向：</p><ol><li>做好分层架构：这是横向扩展的提前，因为高并发系统往往业务复杂，通过分层处理可以简化复杂问题，更容易做到横向扩展。</li></ol><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-11-25-%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91/img_4.png"></p><p>上面这种图是互联网最常见的分层架构，当然真实的高并发系统架构会在此基础上进一步完善。比如会做动静分离并引入CDN，反向代理层可以是LVS+Nginx，Web层可以是统一的API网关，业务服务层可进一步按垂直业务做微服务化，存储层可以是各种异构数据库。</p><ol start="2"><li>各层进行水平扩展：无状态水平扩容，有状态做分片路由。业务集群通常能设计成无状态的，而数据库和缓存往往是有状态的，因此需要设计分区键做好存储分片，当然也可以通过主从同步、读写分离的方案提升读性能。</li></ol><h2 id="具体的实践方案"><a href="#具体的实践方案" class="headerlink" title="具体的实践方案"></a>具体的实践方案</h2><p>下面再结合我的个人经验，针对高性能、高可用、高扩展3个方面，总结下可落地的实践方案。</p><p>高性能的实践方案</p><ol><li>集群部署，通过负载均衡减轻单机压力。</li><li>多级缓存，包括静态数据使用CDN、本地缓存、分布式缓存等，以及对缓存场景中的热点key、缓存穿透、缓存并发、数据一致性等问题的处理。</li><li>分库分表和索引优化，以及借助搜索引擎解决复杂查询问题。</li><li>考虑NoSQL数据库的使用，比如HBase、TiDB等，但是团队必须熟悉这些组件，且有较强的运维能力。</li><li>异步化，将次要流程通过多线程、MQ、甚至延时任务进行异步处理。</li><li>限流，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、Nginx接入层的限流、服务端的限流。</li><li>对流量进行削峰填谷 ，通过 MQ承接流量。</li><li>并发处理，通过多线程将串行逻辑并行化。</li><li>预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。</li><li>缓存预热 ，通过异步 任务 提前 预热数据到本地缓存或者分布式缓存中。</li><li>减少IO次数，比如数据库和缓存的批量读写、RPC的批量接口支持、或者通过冗余数据的方式干掉RPC调用。</li><li>减少IO时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存key的大小、压缩缓存value等。</li><li>程序逻辑优化，比如将大概率阻断执行流程的判断逻辑前置、For循环的计算逻辑优化，或者采用更高效的算法。</li><li>各种池化技术的使用和池大小的设置，包括HTTP请求池、线程池（考虑CPU密集型还是IO密集型设置核心参数）、数据库和Redis连接池等。</li><li>JVM优化，包括新生代和老年代的大小、GC算法的选择等，尽可能减少GC频率和耗时。</li><li>锁选择，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突。</li></ol><p>上述方案无外乎从计算和 IO 两个维度考虑所有可能的优化点，需要有配套的监控系统实时了解当前的性能表现，并支撑你进行性能瓶颈分析，然后再遵循二八原则，抓主要矛盾进行优化。</p><h3 id="高可用的实践方案"><a href="#高可用的实践方案" class="headerlink" title="高可用的实践方案"></a><strong>高可用的实践方案</strong></h3><ol><li><p>对等节点的故障转移，Nginx和服务治理框架均支持一个节点失败后访问另一个节点。</p></li><li><p>非对等节点的故障转移，通过心跳检测并实施主备切换（比如redis的哨兵模式或者集群模式、MySQL的主从切换等）。</p></li><li><p>接口层面的超时设置、重试策略和幂等设计。</p></li><li><p>降级处理：保证核心服务，牺牲非核心服务，必要时进行熔断；或者核心链路出问题时，有备选链路。</p></li><li><p>限流处理：对超过系统处理能力的请求直接拒绝或者返回错误码。</p></li><li><p>MQ场景的消息可靠性保证，包括producer端的重试机制、broker侧的持久化、consumer端的ack机制等。</p></li><li><p>灰度发布，能支持按机器维度进行小流量部署，观察系统日志和业务指标，等运行平稳后再推全量。</p></li><li><p>监控报警：全方位的监控体系，包括最基础的CPU、内存、磁盘、网络的监控，以及Web服务器、JVM、数据库、各类中间件的监控和业务指标的监控。</p></li><li><p>灾备演练：类似当前的“混沌工程”，对系统进行一些破坏性手段，观察局部故障是否会引起可用性问题。</p></li></ol><p>高可用的方案主要从冗余、取舍、系统运维3个方向考虑，同时需要有配套的值班机制和故障处理流程，当出现线上问题时，可及时跟进处理。</p><h3 id="高扩展的实践方案"><a href="#高扩展的实践方案" class="headerlink" title="高扩展的实践方案"></a><strong>高扩展的实践方案</strong></h3><ol><li><p>合理的分层架构：比如上面谈到的互联网最常见的分层架构，另外还能进一步按照数据访问层、业务逻辑层对微服务做更细粒度的分层（但是需要评估性能，会存在网络多一跳的情况）。</p></li><li><p>存储层的拆分：按照业务维度做垂直拆分、按照数据特征维度进一步做水平拆分（分库分表）。</p></li><li><p>业务层的拆分：最常见的是按照业务维度拆（比如电商场景的商品服务、订单服务等），也可以按照核心接口和非核心接口拆，还可以按照请求源拆（比如To C和To B，APP和H5 ）。</p></li></ol><p>作者：Lowry<br>链接：<a href="https://zhuanlan.zhihu.com/p/279147404">https://zhuanlan.zhihu.com/p/279147404</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>最后附上携程技术团队的一篇文章：<br><a href="https://mp.weixin.qq.com/s/6Hq4YVy8BftZks7GHChJOA">干货 | 携程门票秒杀系统的设计与实践</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP&amp;HTTPS&amp;edge&amp;chrome</title>
      <link href="/2024/11/06/2024-11-06-HTTP&amp;HTTPS&amp;edge&amp;chrome/"/>
      <url>/2024/11/06/2024-11-06-HTTP&amp;HTTPS&amp;edge&amp;chrome/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>原本博客直接部署在github.io上，并白嫖GitHub的免费图床，但访问需要挂梯子，为了更方便地访问，我注册了一个域名并使用免费的cloudflare做CDN分发。<br>但这样做确实博客里的文字可以被加载出来，但是图床还是GitHub，不挂梯子图片自然还是加载不出来。<br>如图：</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-11-06-edgechrome/img_2.png">  </p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-11-06-edgechrome/img_3.png"></p><p>但还好我还有华为云的个人服务器，于是自己简易搭建了一个图床服务器。相关代码在文末给出。  </p><h2 id="状态码：已屏蔽：mixed-content"><a href="#状态码：已屏蔽：mixed-content" class="headerlink" title="状态码：已屏蔽：mixed-content"></a>状态码：<code>已屏蔽：mixed-content</code></h2><p>图床建好后修改图片链接，重新访问看看  </p><p>发现还是显示上面两张图，图片一张都没加载出来。按理说我的服务器在国内，不可能访问不了，所以我在电脑上打开chrome浏览器开始调试:  </p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-11-06-edgechrome/img_1.png">  </p><p>原本应该显示状态码的地方显示<code>已屏蔽：mixed-content</code> 。<br>好嘛，没见过这玩意的八股战士应声倒地。赶紧问问通义：</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-11-06-edgechrome/img_4.png">   </p><p>原来是这些URL全走HTTP协议，但是网站是以HTTPS协议访问的。HTTPS把HTTP给ban了。<br>问题找出来了，怎么解决呢？</p><ol><li>以后只以HTTP协议访问</li><li>给我的服务器装SSL证书，但这样做需要一个域名，没有域名申请不到证书。我手里唯一的域名juziblog.space已经绑了本站。试试二级域名，发现我为了cloudflare的CDN加速已经修改了DNS解析，如果不改回去二级域名不会生效，改回去cloudflare就不会生效。</li></ol><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-11-06-edgechrome/img_5.png"></p><ol start="3"><li>博客模版把md的图片转换成html语法里的img标签，img除了HTTP&#x2F;HTTPS还支持一些其它协议：<ul><li>base64,把图片写在html里，比起原图片会增加33%左右的大小，会显著降低网站加载速度，服务端大忌，而且也会增加修改博客的时间成本，typora和idea都不会隐藏几万甚至几十万个字符base64，修改md光是上下文翻动就难如登天。</li><li>ftp，会暴露我的服务器密码，且很多浏览器都不支持ftp。</li><li>blob，浏览器动态生成的链接，把本机内存里的图片以链接的形式显示，这还是要先发HTTP请求获取图片才行</li><li>file:&#x2F;&#x2F;,显示本地磁盘图像</li></ul></li></ol><p>所以要么换一个支持https的图床服务器，要么再买一个域名给现在的服务器装证书。</p><p style="font-size: 17px;">我选择GitHub国内平替版的Gitee当免费图床。</p>仓库内图片链接由 <p><code>https://gitee.com/xyhaooo/picrepo/blob/master/assets/home.png</code></p><p>改为</p><p><code>https://gitee.com/xyhaooo/picrepo/raw/master/home.png</code> 即可</p><p>因为gitee加了防盗链，html头部还加入</p><p><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></p><p>之后我鬼使神差地又用edge浏览器调试了一遍，发现edge的调试工具连<code>已屏蔽：mixed-content</code>都不报，状态栏全是空白？<br>还好先用chrome调试，不然这个问题不知道得到什么时候才能发现。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-11-06-edgechrome/img.png">  </p><h2 id="图床简易代码"><a href="#图床简易代码" class="headerlink" title="图床简易代码"></a>图床简易代码</h2><p>将文件写入HTTP的response，记得设置一些HTTP的头部字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController(&quot;fileInfoController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/file&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInfoController</span> <span class="keyword">extends</span> <span class="title class_">CommonFileController</span> &#123;</span><br><span class="line">    <span class="comment">// url举例：http://121.36.193.119/api/file/getBlogImage?imagePath=assets/articleCover/2024-01-31-Hash.png</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getBlogImage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getImage1</span><span class="params">(HttpServletResponse response,</span></span><br><span class="line"><span class="params">                          String imagePath)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(imagePath)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">imageSuffix</span> <span class="operator">=</span> StringTools.getFileSuffix(imagePath);</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> appConfig.getProjectFolder() + Constants.FILE_FOLDER_FILE  + <span class="string">&quot;/&quot;</span> + imagePath;</span><br><span class="line">        imageSuffix = imageSuffix.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> <span class="string">&quot;image/&quot;</span> + imageSuffix;</span><br><span class="line">        response.setContentType(contentType);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;max-age=2592000&quot;</span>);</span><br><span class="line">        readFile(response, filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(HttpServletResponse response, String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringTools.pathIsOk(filePath)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="type">byte</span>[] byteData = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            out = response.getOutputStream();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(byteData)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(byteData, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;读取文件异常&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;IO异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;IO异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其它 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更优雅的PC端微信公众号订阅管理工具</title>
      <link href="/2024/10/23/2024-10-23-PC%E7%AB%AF%E5%85%AC%E4%BC%97%E5%8F%B7%E8%AE%A2%E9%98%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/10/23/2024-10-23-PC%E7%AB%AF%E5%85%AC%E4%BC%97%E5%8F%B7%E8%AE%A2%E9%98%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>先上效果图：</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-23-PC%E7%AB%AF%E5%85%AC%E4%BC%97%E5%8F%B7%E8%AE%A2%E9%98%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/img.png"></p><p>该工具开源地址是：<a href="https://github.com/cooderl/wewe-rss">https://github.com/cooderl/wewe-rss</a></p><p>按readme中的步骤搭建即可</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> PC端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅地重试</title>
      <link href="/2024/10/18/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/"/>
      <url>/2024/10/18/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：赵九文<br>如何解决长链路多RPC调用失败导致重试风暴的问题？<br>原文链接：<a href="https://mp.weixin.qq.com/s/6IkTnUbBlHjM3GM_bT35tA">如何优雅地重试</a></p></blockquote><h2 id="lH7zA">背景</h2>在微服务架构中，一个大系统被拆分成多个小服务，小服务之间大量 RPC 调用，经常可能因为网络抖动等原因导致 RPC 调用失败，这时候使用重试机制可以提高请求的最终成功率，减少故障影响，让系统运行更稳定。<p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/img.png"></p><h3 id="0c4f3d55">重试的风险</h3>重试能够提高服务稳定性，但是一般情况下大家都不会轻易去重试，或者说不敢重试，主要是因为重试有放大故障的风险。<p>首先，重试会加大直接下游的负载。如下图，假设 A 服务调用 B 服务，重试次数设置为 r（包括首次请求），当 B 高负载时很可能调用不成功，这时 A 调用失败重试 B ，B 服务的被调用量快速增大，最坏情况下可能放大到 r 倍，不仅不能请求成功，还可能导致 B 的负载继续升高，甚至直接打挂。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/img_1.png"></p><p>更可怕的是，重试还会存在链路放大的效应，结合下图说明一下：</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/img_2.png"></p><p>假设现在场景是 Backend A 调用 Backend B，Backend B 调用 DB Frontend，均设置重试次数为 3 。如果 Backend B 调用 DB Frontend，请求 3 次都失败了，这时 Backend B 会给 Backend A 返回失败。但是 Backend A 也有重试的逻辑，Backend A 重试 Backend B 三次，每一次 Backend B 都会请求 DB Frontend 3 次，这样算起来，DB Frontend 就会被请求了 9 次，实际是指数级扩大。假设正常访问量是 n，链路一共有 m 层，每层重试次数为 r，则最后一层受到的访问量最大，为 n * r ^ (m - 1) 。这种指数放大的效应很可怕，可能导致链路上多层都被打挂，整个系统雪崩。</p><h3 id="b5425771">重试的使用成本</h3>另外使用重试的成本也比较高。之前在字节跳动的内部框架和服务治理平台中都没有支持重试，在一些很需要重试的业务场景下（比如调用一些第三方业务经常失败），业务方可能用简单 for 循环来实现，基本不会考虑重试的放大效应，这样很不安全，公司内部出现过多次因为重试而导致的事故，且出事故的时候还需要修改代码上线才能关闭重试，导致事故恢复也不迅速。<p>另外也有一些业务使用开源的重试组件，这些组件通常会考虑对直接下游的保护，但不会考虑链路级别的重试放大，另外需要业务方修改 RPC 调用代码才能使用，对业务代码入侵较多，而且也是静态配置，需要修改配置时都必须重新上线。</p><p>基于以上的背景，为了让业务方能够灵活安全的使用重试，我们字节跳动直播中台团队设计和实现了一个重试治理组件，具有以下优点：</p><ol><li>能够在链路级别防重试风暴。</li><li>保证易用性，业务接入成本小。</li><li>具有灵活性，能够动态调整配置。</li></ol><p>下面介绍具体的实现方案。</p><h2 id="70c7bcd6">重试治理</h2><h3 id="bcbcb822">动态配置</h3>如何让业务方简单接入是首先要解决的问题。如果还是普通组件库的方式，依旧免不了要大量入侵用户代码，且很难动态调整。<p>字节跳动的 Golang 开发框架支持中间件 (Milddleware) 模式，可以注册多个自定义 Middleware 并依次递归调用，通常是用于完成打印日志、上报监控等非业务逻辑，能够有效将业务和非业务代码功能进行解耦。因此我们决定使用 Middleware 的方式来实现重试功能，定义一个 Middleware 并在内部实现对 RPC 的重复调用，把重试的配置信息用字节跳动的分布式配置存储中心存储，这样 Middleware 中能够读取配置中心的配置并进行重试，对用户来说不需要修改调用 RPC 的代码，而只需要在服务中引入一个全局的 Middleware 即可。</p><p>如下面的整体架构图所示，我们提供配置的网页和后台，用户能够在专门进行服务治理的页面上很方便的对 RPC 进行配置修改并自动生效，内部的实现逻辑对用户透明，对业务代码无入侵。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/img_3.png"></p><p>配置的维度按照字节跳动的 RPC 调用特点，选定 [调用方服务，调用方集群，被调用服务， 被调用方法] 为一个元组，按照元组来进行配置。Middleware 中封装了读取配置的方法，在 RPC 调用的时候会自动读取并生效。</p><p>这种 Middleware 的方式能够让业务方很容易接入，相对于之前普通组件库的方式要方便很多，并且一次接入以后就具有动态配置的能力，可能很方便地调整或者关闭重试配置。</p><h3 id="cf646b02">退避策略</h3>确定了接入方式以后就可以开始实现重试组件的具体功能，一个重试组件所包含的基本功能中，除了重试次数和总延时这样的基础配置外，还需要有退避策略。<p>对于一些暂时性的错误，如网络抖动等，可能立即重试还是会失败，通常等待一小会儿再重试的话成功率会较高，并且也可能打散上游重试的时间，较少因为同时都重试而导致的下游瞬间流量高峰。决定等待多久之后再重试的方法叫做退避策略，我们实现了常见的退避策略，如：</p><ul><li>线性退避：每次等待固定时间后重试。</li><li>随机退避：在一定范围内随机等待一个时间后重试。</li><li>指数退避：连续重试时，每次等待时间都是前一次的倍数。</li></ul><h3 id="ae55722e">防止 retry storm</h3>如何安全重试，防止 retry storm 是我们面临的最大的难题。<h4 id="70a25729">限制单点重试</h4>首先要在单点进行限制，一个服务不能不受限制的重试下游，很容易造成下游被打挂。除了限制用户设定的重试次数上限外，更重要的是限制重试请求的成功率。<p>实现的方案很简单，基于断路器的思想，限制 请求失败&#x2F;请求成功 的比率，给重试增加熔断功能。我们采用了常见的滑动窗口的方法来实现，如下图，内存中为每一类 RPC 调用维护一个滑动窗口，比如窗口分 10 个 bucket ，每个 bucket 里面记录了 1s 内 RPC 的请求结果数据（成功、失败）。新的一秒到来时，生成新的 bucket ，并淘汰最早的一个 bucket ，只维持 10s 的数据。在新请求这个 RPC 失败时，根据前 10s 内的 失败&#x2F;成功 是否超过阈值来判断是否可以重试。默认阈值是 0.1 ，即下游最多承受 1.1 倍的 QPS ，用户可以根据需要自行调整熔断开关和阈值。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/img_4.png"></p><h4 id="941c5026">限制链路重试</h4>前面说过在多级链路中如果每层都配置重试可能导致调用量指数级扩大，虽然有了重试熔断之后，重试不再是指数增长(每一单节点重试扩大限制了 1.1 倍)，但还是会随着链路的级数增长而扩大调用次数，因此还是需要从链路层面来考虑重试的安全性。<p>链路层面的防重试风暴的核心是限制每层都发生重试，理想情况下只有最下一层发生重试。Google SRE 中指出了 Google 内部使用特殊错误码的方式来实现：</p><ul><li>统一约定一个特殊的 status code ，它表示：调用失败，但别重试。</li><li>任何一级重试失败后，生成该 status code 并返回给上层。</li><li>上层收到该 status code 后停止对这个下游的重试，并将错误码再传给自己的上层。</li></ul><p>这种方式理想情况下只有最下一层发生重试，它的上游收到错误码后都不会重试，链路整体放大倍数也就是 r 倍(单层的重试次数)。但是这种策略依赖于业务方传递错误码，对业务代码有一定入侵，而且通常业务方的代码差异很大，调用 RPC 的方式和场景也各不相同，需要业务方配合进行大量改造，很可能因为漏改等原因导致没有把从下游拿到的错误码传递给上游。</p><p>好在字节跳动内部用的 RPC 协议中有扩展字段，我们在 Middleware 中做了很多尝试，封装了错误码处理和传递的逻辑，在 RPC 的 Response 扩展字段中传递错误码标识 nomore_retry ，它告诉上游不要再重试了。Middleware 完成错误码的生成、识别、传递等整个生命周期的管理，不需要业务方修改本身的 RPC 逻辑，错误码的方案对业务来说是透明的。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/img_5.png"></p><p>在链路中，推进每层都接入重试组件，这样每一层都可以通过识别这个标志位来停止重试，并逐层往上传递，上层也都停止重试，做到链路层面的防护，达到“只有最靠近错误发生的那一层才重试”的效果。</p><h4 id="2f88ea06">超时处理</h4>在测试错误码上传的方案时，我们发现超时的情况可能导致传递错误码的方案失效。<p>对于 A -&gt; B -&gt; C 的场景，假设 B -&gt; C 超时，B 重试请求 C ，这时候很可能 A -&gt; B 也超时了，所以 A 没有拿到 B 返回的错误码，而是也会重试 B , 这个时候虽然 B 重试 C 且生成了重试失败的错误码，但是却不能再传递给 A 。这种情况下，A 还是会重试 B ，如果链路中每一层都超时，那么还是会出现链路指数扩大的效应。</p><p>因此为了处理这种情况，除了下游传递重试错误标志以外，我们还实现了“对重试请求不重试”的方案。</p><p>对于重试的请求，我们在 Request 中打上一个特殊的 retry flag ，在上面 A -&gt; B -&gt; C 的链路，当 B 收到 A 的请求时会先读取这个 flag 判断这个请求是不是重试请求，如果是，那它调用 C 即使失败也不会重试；否则调用 C 失败后会重试 C 。同时 B 也会把这个 retry flag 下传，它发出的请求也会有这个标志，它的下游也不会再对这个请求重试。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/img_6.png"></p><p>这样即使 A 因为超时而拿不到 B 的返回，对 B 发出重试请求后，B 能感知到并且不会对 C 重试，这样 A 最多请求 r 次，B 最多请求 r + r - 1，如果后面还有更下层次的话，C 最多请求 r + r + r - 2 次， 第 i 层最多请求 i * r - (i-1) 次，最坏情况下是倍数增长，不是指数增长了。加上实际还有重试熔断的限制，增长的幅度要小很多。</p><p>通过重试熔断来限制单点的放大倍数，通过重试错误标志链路回传的方式来保证只有最下层发生重试，又通过重试请求 flag 链路下传的方式来保证对重试请求不重试，多种控制策略结合，可以有效地较少重试放大效应。</p><h4 id="6ee85c31">超时场景优化</h4>分布式系统中，RPC 请求的结果有三种状态：成功、失败、超时，其中最难处理的就是超时的情况。但是超时往往又是最经常发生的那一个，我们统计了字节跳动直播业务线上一些重要服务的 RPC 错误分布，发现占比最高的就是超时错误，怕什么偏来什么。<p>在超时重试的场景中，虽然给重试请求添加 retry flag 能防止指数扩大，但是却不能提高请求成功率。如下图，假如 A 和 B 的超时时间都是 1000ms ，当 C 负载很高导致 B 访问 C 超时，这时 B 会重试 C ，但是时间已经超过了 1000ms ，时间 A 这里也超时了并且断开了和 B 的连接，所以 B 这次重试 C 不管是否成功都是无用功，从 A 的视角看，本次请求已经失败了。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/img_7.png"></p><p>这种情况的本质原因是因为链路上的超时时间设置得不合理，上游和下游的超时时间设置的一样，甚至上游的超时时间比下游还要短。在实际情况中业务一般都没有专门配置过 RPC 的超时时间，所以可能上下游都是默认的超时，时长是一样的。为了应对这种情况，我们需要有一个机制来优化超时情况下的稳定性，并减少无用的重试。</p><p>如下图，正常重试的场景是等拿到 Resp1 (或者拿到超时结果) 后再发起第二次请求，整体耗时是 t1 + t2 。我们分析下，service A 在发出去 Req1 之后可能等待很长的时间，比如 1s ，但是这个请求的 pct99 或者 pct999 可能通常只有 100ms 以内，如果超过了 100ms ，有很大概率是这次访问最终会超时，能不能不要傻等，而是提前重试呢？</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/img_8.png"></p><p>基于这种思想，我们引入并实现了 Backup Requests 的方案。如下图，我们预先设定一个阈值 t3（比超时时间小，通常建议是 RPC 请求延时的 pct99 ），当 Req1 发出去后超过 t3 时间都没有返回，那我们直接发起重试请求 Req2 ，这样相当于同时有两个请求运行。然后等待请求返回，只要 Resp1 或者 Resp2 任意一个返回成功的结果，就可以立即结束这次请求，这样整体的耗时就是 t4 ，它表示从第一个请求发出到第一个成功结果返回之间的时间，相比于等待超时后再发出请求，这种机制能大大减少整体延时。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/img_9.png"></p><p>实际上 Backup Requests 是一种用访问量来换成功率 (或者说低延时) 的思想，当然我们会控制它的访问量增大比率，在发起重试之前，会为第一次的请求记录一次失败，并检查当前失败率是否超过了熔断阈值，这样整体的访问比率还是会在控制之内。</p><h4 id="7b89a359">结合 DDL</h4>Backup Requests 的思路能在缩短整体请求延时的同时减少一部分的无效请求，但不是所有业务场景下都适合配置 Backup Requests ，因此我们又结合了 DDL 来控制无效重试。<p>DDL 是“ Deadline Request 调用链超时”的简称，我们知道 TCP&#x2F;IP 协议中的 TTL 用于判断数据包在网络中的时间是否太长而应被丢弃，DDL 与之类似，它是一种全链路式的调用超时，可以用来判断当前的 RPC 请求是否还需要继续下去。如下图，字节跳动的基础团队已经实现了 DDL 功能，在 RPC 请求调用链中会带上超时时间，并且每经过一层就减去该层处理的时间，如果剩下的时间已经小于等于 0 ，则可以不需要再请求下游，直接返回失败即可。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/img_10.png"></p><p>DDL 的方式能有效减少对下游的无效调用，我们在重试治理中也结合了 DDL 的数据，在每一次发起重试前都会判断 DDL 的剩余值是否还大于 0 ，如果已经不满足条件了，那也就没必要对下游重试，这样能做到最大限度的减少无用的重试。</p><h4 id="0e2edff4">实际的链路放大效应</h4>之前说的链路指数放大是理想情况下的分析，实际的情况要复杂很多，因为有很多影响因素：<table><thead><tr><th><strong>策略</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>重试熔断</td><td>请求失败 &#x2F; 成功 &gt; 0.1 时停止重试</td></tr><tr><td>链路上传错误标志</td><td>下层重试失败后上传错误标志，上层不再重试</td></tr><tr><td>链路下传重试标志</td><td>重试请求特殊标记，下层对重试请求不会重试</td></tr><tr><td>DDL</td><td>当剩余时间不够时不再发起重试请求</td></tr><tr><td>框架熔断</td><td>微服务框架本身熔断、过载保护等机制也会影响重试效果</td></tr></tbody></table><p>各种因素综合下来，最终实际方法情况不是一个简单的计算公式能说明，我们构造了多层调用链路，在线上实际测试和记录了在不同错误类型、不同错误率的情况下使用重试治理组件的效果，发现接入重试治理组件后能够在链路层面有效的控制重试放大倍数，大幅减少重试导致系统雪崩的概率。</p><h2 id="25f9c7fa">总结</h2>如上所述，基于服务治理的思想我们开发了重试治理的功能，支持动态配置，接入方式基本无需入侵业务代码，并使用多种策略结合的方式在链路层面控制重试放大效应，兼顾易用性、灵活性、安全性，在字节跳动内部已经有包括直播在内的很多服务接入使用并上线验证，对提高服务本身稳定性有良好的效果。目前方案已经被验证并在字节跳动直播等业务推广，后续将为更多的字节跳动业务服务。]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九大服务架构性能优化方式</title>
      <link href="/2024/10/18/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/10/18/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：孙加亮<br>在服务架构设计时通常可以使用一些中间件去提升服务性能，例如使用mysql，redis，kafka等，因为这些中间件有着很好的读写性能。除了使用中间件提升服务性能外，也可以通过探索它们通过什么样的底层设计实现的高性能，将这些设计应用到我们的服务架构中。<br>原文链接：<a href="https://mp.weixin.qq.com/s/38rsvewtkkqxRLPad-P3_Q">九大服务架构性能优化方式</a></p></blockquote><p>最近做了一些服务性能优化，文章池服务平均耗时跟p99耗时都下降80%左右，事件底层页服务平均耗时下降50%多左右，主要优化项目中一些不合理设计，例如服务间使用json传输数据，监控上报处理逻辑在主流程中，重复数据每次都请求下游服务，多个耗时操作串行请求等，这些问题都对服务有着严重的性能影响。</p><p>在服务架构设计时通常可以使用一些中间件去提升服务性能，例如使用mysql，redis，kafka等，因为这些中间件有着很好的读写性能。除了使用中间件提升服务性能外，也可以通过探索它们通过什么样的底层设计实现的高性能，将这些设计应用到我们的服务架构中。</p><p>常用的性能优化方法可以分为以下几种：</p><h4 id="14d5ef3c">性能优化九大方式： </h4><h5 id="e80c310e">缓存 </h5>性能优化，缓存为王，所以开始先介绍一下缓存。缓存在我们的架构设计中无处不在的，常规请求是浏览器发起请求，请求服务端服务，服务端服务再查询数据库中的数据，每次读取数据都会至少需要两次网络I/O，性能会差一些，我们可以在整个流程中增加缓存来提升性能。首先是浏览器测，可以通过Expires、Cache-Control、Last-Modified、Etag等相关字段来控制浏览器是否使用本地缓存。<p>其次我们可以在服务端服务使用本地缓存或者一些中间件来缓存数据，例如redis。redis之所以这么快，主要因为数据存储在内存中，不需要读取磁盘，因为内存读取速度通常是磁盘的数百倍甚至更多；</p><p>然后在数据库测，通常使用的是mysql，mysql的数据存储到磁盘上，但是mysql为了提升读写性能，会利用bufferpool缓存数据页。mysql读取时会按照页的粒度将数据页读取到bufferpool中，bufferpool中的数据页使用LRU算法淘汰长期没有用到的页面，缓存最近访问的数据页。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img.png"></p><p>此外小到cpu的l1、l2、l3级cache，大到浏览器缓存都是为了提高性能，缓存也是进行服务性能优化的重要手段，使用缓存时需要考虑以下几点。</p><h6 id="6c8f29b6"> 使用什么样的缓存 </h6>使用缓存时可以使用redis或者机器内存来缓存数据，使用redis的好处可以保证不同机器读取数据的一致性，但是读取redis会增加一次I/O，使用内存缓存数据时可能会出现读取数据不一致，但是读取性能好。例如文章的阅读数数据，如果使用机器内存作为缓存，容易出现不同机器上缓存数据的不一致，用户不同刷次会请求到不同服务端机器，读取的阅读数不一致，可能会出现阅读数变小的情况，用户体验不好。对于阅读数这种经常变更的数据比较适合使用redis来统一缓存。<p>也可以将两者结合提升服务的性能,例如在内容池服务，利用redis跟机器内存缓存热点文章详情，优先读取机器内存中的数据，数据不存在的时候会读取redis中的缓存数据，当redis中的数据也不存在的时候，会读取下游持久化存储中的全量数据。其中内存级缓存过期时间为15s，在数据变更的时候不保证数据一致性，通过数据自然过期来保证最终一致性。redis中缓存数据需要保证与持久化存储中数据一致性，如何保证一致性在后续讲解。可以根据自己的业务场景可以选择合适的缓存方案。</p><p>使用缓存时可以使用redis或者机器内存来缓存数据，使用redis的好处可以保证不同机器读取数据的一致性，但是读取redis会增加一次I&#x2F;O，使用内存缓存数据时可能会出现读取数据不一致，但是读取性能好。例如文章的阅读数数据，如果使用机器内存作为缓存，容易出现不同机器上缓存数据的不一致，用户不同刷次会请求到不同服务端机器，读取的阅读数不一致，可能会出现阅读数变小的情况，用户体验不好。对于阅读数这种经常变更的数据比较适合使用redis来统一缓存。</p><p>也可以将两者结合提升服务的性能,例如在内容池服务，利用redis跟机器内存缓存热点文章详情，优先读取机器内存中的数据，数据不存在的时候会读取redis中的缓存数据，当redis中的数据也不存在的时候，会读取下游持久化存储中的全量数据。其中内存级缓存过期时间为15s，在数据变更的时候不保证数据一致性，通过数据自然过期来保证最终一致性。redis中缓存数据需要保证与持久化存储中数据一致性，如何保证一致性在后续讲解。可以根据自己的业务场景可以选择合适的缓存方案。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_1.png"></p><h6 id="8bd6c0a5"> 缓存常见问题 </h6>1、缓存雪崩：缓存雪崩是指缓存中的大量数据同时失效或者过期，导致大量的请求直接读取到下游数据库，导致数据库瞬时压力过大，通常的解决方案是将缓存数据设置的过期时间随机化。在事件服务中就是利用固定过期时间+随机值的方式进行文章的淘汰，避免缓存雪崩。<p>2、 缓存穿透：缓存穿透是指读取下游不存在的数据，导致缓存命中不了，每次都请求下游数据库。这种情况通常会出现在线上异常流量攻击或者下游数据被删除的状况，针对缓存穿透可以使用布隆过滤器对不存在的数据进行过滤，或者在读取下游数据不存在的情况，可以在缓存中设置空值，防止不断的穿透。事件服务可能会出现查询文章被删除的情况，就是利用设置空值的方法防止被删除数据的请求不断穿透到下游。</p><p>3、 缓存击穿: 缓存击穿是指某个热点数据在缓存中被删除或者过期，导致大量的热点请求同时请求数据库。解决方案可以对于热点数据设置较长的过期时间或者利用分布式锁避免多个相同请求同时访问下游服务。在新闻业务中，对于热点新闻经常会出现这种情况，事件服务利用golang的singlefilght保证同一篇文章请求在同一时刻只有一个会请求到下游，防止缓存击穿。</p><p>4、热点key: 热点key是指缓存中被频繁访问的key，导致缓存该key的分片或者redis访问量过高。可以将可热点key分散存储到多个key上，例如将热点key+序列号的方式存储，不同key存储的值都是相同的，在访问时随机访问一个key，分散原来单key分片的压力；此外还可以将key缓存到机器内存中，避免redis单节点压力过大，在新闻业务中，对于热点文章就是采用这种方式，将热点文章存储到机器内存中，避免存储热点文章redis单分片请求量过大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key val    =&gt;  key1 val 、  key2 val、  key3 val 、 key4 val</span><br></pre></td></tr></table></figure><h6 id="4e5788f5"> 缓存淘汰 </h6>缓存的大小是有限的，因为需要对缓存中数据进行淘汰，通常可以采用随机、LRU或者LFU算法等淘汰数据。LRU是一种最常用的置换算法，淘汰最近最久未使用的数据，底层可以利用map+双端队列的数据结构实现。<p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_2.png"></p><p>最原生的LRU算法是存在一些问题的，不知道大家在使用过有没有遇到过问题。首先需要注意的是在数据结构中有互斥锁，因为golang对于map的读写会产生panic，导致服务异常。使用互斥锁之后会导致整个缓存性能变差，可以采用分片的思想，将整个LRUCache分为多个，每次读取时读取其中一个cache片，降低锁的粒度来提升性能，常见的本地缓存包通常就利用这种方式实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type LRUCache struct &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    size int     </span><br><span class="line">    capacity int</span><br><span class="line">    cache map[int]*DLinkNode</span><br><span class="line">    head, tail *DLinkNode</span><br><span class="line">&#125;</span><br><span class="line">type DLinkNode struct &#123;</span><br><span class="line">    key,value int</span><br><span class="line">    pre, next *DLinkNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mysql也会利用LRU算法对buffer pool中的数据页进行淘汰。由于mysql存在预读，在读取磁盘时并不是按需读取，而是按照整个数据页的粒度进行读取，一个数据页会存储多条数据，除了读取当前数据页，可能也会将接下来可能用到的相邻数据页提前缓存到bufferpool中，如果下次读取的数据在缓存中，直接读取内存即可,不需要读取磁盘，但是如果预读的数据页一直没有被访问，那就会存在预读失效的情况，淘汰原来使用到的数据页。mysql将buffer pool中的链表分为两部分，一段是新生代，一段是老生代，新老生代的默认比是7:3，数据页被预读的时候会先加到老生代中，当数据页被访问时才会加载到新生代中，这样就可以防止预读的数据页没有被使用反而淘汰热点数据页。此外mysql通常会存在扫描表的请求，会顺序请求大量的数据加载到缓存中，然后将原本缓存中所有热点数据页淘汰，这个问题通常被称为缓冲池污染，mysql中的数据页需要在老生代停留时间超过配置时间才会老生代移动到新生代时来解决缓存池污染。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_3.png"></p><p>redis中也会利用LRU进行淘汰过期的数据，如果redis将缓存数据都通过一个大的链表进行管理，在每次读写时将最新访问的数据移动到链表队头，那样会严重影响redis的读写性能,此外会增加额外的存储空间，降低整体存储数量。redis是对缓存中的对象增加一个最后访问时间的字段，在对对象进行淘汰的时候，会采用随机采样的方案，随机取5个值，淘汰最近访问时间最久的一个，这样就可以避免每次都移动节点。但是LRU也会存在缓存污染的情况，一次读取大量数据会淘汰热点数据，因此redis可以选择利用LFU进行淘汰数据，是将原来的访问时间字段变更为最近访问时间+访问次数的一个字段，这里需要注意的是访问次数并不是单纯的次数累加，而是根据最近访问时间跟当前时间的差值进行时间衰减的，简单说也就是访问越久以及访问次数越少计算得到的值也越小，越容易被淘汰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line"> unsigned type:4;</span><br><span class="line"> unsigned encoding:4;</span><br><span class="line"> unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or</span><br><span class="line"> * LFU data (least significant 8 bits frequency</span><br><span class="line"> * and most significant 16 bits access time). */</span><br><span class="line"> int refcount;</span><br><span class="line"> void *ptr;</span><br><span class="line">&#125; obj ;</span><br></pre></td></tr></table></figure><p>可以看出不同中间件对于传统的LRU淘汰策略都进行了一定优化来保证服务性能，我们也可以参考不同的优化策略在自己的服务中进行缓存key的淘汰。</p><h6 id="d6c6707a"> 缓存数据一致性 </h6>当数据库中的数据变更时，如何保证缓存跟数据库中的数据一致，通常有以下几种方案：更新缓存再更新DB，更新DB再更新缓存，先更新DB再删除缓存，删除缓存再更新DB。这几种方案都有可能会出现缓存跟数据库中的数据不一致的情况，最常用的还是更新DB再删除缓存，因为这种方案导致数据不一致的概率最小，但是也依然会存在数据不一致的问题。例如在T1时缓存中无数据，数据库中数据为100，线程B查询缓存没有查询到数据，读取到数据库的数据100然后去更新缓存，但是此时线程A将数据库中的数据更新为99，然后在T4时刻删除缓存中的数据，但是此时缓存中还没有数据，在T5的时候线程B才更新缓存数据为100，这时候就会导致缓存跟数据库中的数据不一致。<p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_4.png"></p><p>为保证缓存与数据库数据的一致性。常用的解决方案有两种，一种是延时双删，先删除缓存，后续更新数据库，休眠一会再删除缓存。文章池服务中就是利用这种方案保证数据一致性，如何实现延迟删除，是通过go语言中channel实现简单延时队列，没有引入第三方的消息队列，主要为了防止服务的复杂化；另外一种可以订阅DB的变更binlog，数据更新时只更新DB，通过消费DB的binlog日志，解析变更操作进行缓存变更，更新失败时不进行消息的提交，通过消息队列的重试机制实现最终一致性。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_5.png"></p><h5 id="b959b2d9"> 并行化处理 </h5>redis在版本6.0之前都是号称单线程模型，主要是利用epllo管理用户海量连接，使用一个线程通过事件循环来处理用户的请求，优点是避免了线程切换和锁的竞争，以及实现简单，但是缺点也比较明显，不能有效的利用cpu的多核资源。随着数据量和并发量的越来越大，I/O成了redis的性能瓶颈点，因此在6.0版本引入了多线程模型。redis的多线程将处理过程最耗时的sockect的读取跟解析写入由多个I/O 并发完成，对于命令的执行过程仍然由单线程完成。<p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_6.png"></p><p>mysql的主从同步过程从数据库通过I&#x2F;Othread读取住主库的binlog，将日志写入到relay log中，然后由sqlthread执行relaylog进行数据的同步。其中sqlthread就是由多个线程并发执行加快数据的同步，防止主从同步延迟。sqlthread多线程化也经历了多个版本迭代，按表维度分发到同一个线程进行数据同步，再到按行维度分发到同一个线程。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_7.png"></p><p>小到线程的并发处理，大到redis的集群，以及kafka的分topic分区都是通过多个client并行处理提高服务的读写性能。在我们的服务设计中可以通过创建多个容器对外服务提高服务的吞吐量，服务内部可以将多个串行的I&#x2F;O操作改为并行处理，缩短接口的响应时长，提升用户体验。对于I&#x2F;O存在相互依赖的情况，可以进行多阶段分批并行化处理，另外一种常见的方案就是利用DAG加速执行，但是需要注意的是DAG会存在开发维护成本较高的情况，需要根据自己的业务场景选择合适的方案。并行化也不是只有好处没有坏处的，并行化有可能会导致读扩散严重，以及线程切换频繁存在一定的性能影响。</p><h5 id="220db113"> 批量化处理 </h5>kafka的消息发送并不是直接写入到broker中的，发送过程是将发送到同一个topic同一个分区的消息通过main函数的partitioner组件发送到同一个队列中，由sender线程不断拉取队列中消息批量发送到broker中。利用批量发送消息处理，节省大量的网络开销，提高发送效率。<p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_8.png"></p><p>redis的持久化方式有RDB跟AOF两种，其中AOF在执行命令写入内存后，会写入到AOF缓冲区，可以选择合适的时机将AOF缓冲区中的数据写入到磁盘中，刷新到磁盘的时间通过参数appendfsync控制，有三个值always、everysec、no。其中always会在每次命令执行完都会刷新到磁盘来保证数据的可靠性；everysec是每秒批量写入到磁盘，no是不进行同步操作，由操作系统决定刷新到写回磁盘，当redis异常退出时存在丢数据的风险。AOF命令刷新到磁盘的时机会影响redis服务写入性能，通常配置为everysec批量写入到磁盘，来平衡写入性能和数据可靠性。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_9.png"></p><p>我们读取下游服务或者数据库的时候，可以一次多查询几条数据，节省网络I&#x2F;O;读取redis的还可以利用pipeline或者lua脚本处理多条命令，提升读写性能；前端请求js文件或者小图片时，可以将多个js文件或者图片合并到一起返回，减少前端的连接数，提升传输性能。同样需要注意的是批量处理多条数据，有可能会降低吞吐量，以及本身下游就不支持过多的批量数据，此时可以将多条数据分批并发请求。对于事件底层页服务中不同组件下配置的不同文章id，会统一批量请求下游内容服务获取文章详情，对于批量的条数也会做限制，防止单批数据量过大。</p><h5 id="3b41e488"> 数据压缩合并 </h5>redis的AOF重写是利用bgrewriteaof命令进行AOF文件重写，因为AOF是追加写日志，对于同一个key可能存在多条修改修改命令，导致AOF文件过大，redis重启后加载AOF文件会变得缓慢，导致启动时间过长。可以利用重写命令将对于同一个key的修改只保存一条记录，减小AOF文件体积。<p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_10.png"></p><p>大数据领域的Hbase、cassandra等nosql数据库写入性能都很高，它们的底层存储数据结构就是LSM树(log structured merge tree),这种数据结构的核心思想是追加写，积攒一定的数据后合并成更大的segement，对于数据的删除也只是增加一条删除记录。同样对一个key的修改记录也有多条。这种存储结构的优点是写入性能高，但是缺点也比较明显，数据存在冗余和文件体积大。主要通过线程进行段合并将多个小文件合并成更大的文件来减少存储文件体积，提升查询效率。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_11.png"></p><p>对于kafka进行传输数据时，在生产者端和消费者端可以开启数据压缩。生产者端压缩数据后，消费者端收到消息会自动解压，可以有效减小在磁盘的存储空间和网络传输时的带宽消耗，从而降低成本和提升传输效率。需要注意生产者端和消费者端指定相同的压缩算法。</p><p>在降本增效的浪潮中，降低redis成本的一种方式，就是对存储到redis中的数据进行压缩，降低存储成本,重构后的内容微服务通过持久化存储全量数据，采用snappy压缩，压缩后只是原来数据的40%-50%；还有一种方式是将服务之间的调用从http的json改为trpc的pb协议，因为pb协议编码后的数据更小，提升传输效率，在服务优化时，将原来请求tab的协议从json转成pb，降低几毫秒的时延，此外内容微服务存储的数据采用flutbuffer编码，相比较于protobuffer有着更高的压缩比跟更快的编解码速度；对于JS&#x2F;CSS多个文件下发也可以进行混淆和压缩传递；对于存储在es中的数据也可以手动调用api进行段合并，减小存储数据的体积，提高查询速度；在我们工作中还有一个比较常见的问题是接口返回的冗余数据特别多，一个接口服务下发的数据大而全，而不是对于当前场景做定制化下发，不满足接口最小化原则，白白浪费了很多带宽资源和降低传输效率。</p><h5 id="e3315609"> 无锁化 </h5>redis通过单线程避免了锁的竞争，避免了线程之间频繁切换才有这很好的读写性能。<p>go语言中提供了atomic包，主要用于不同线程之间的数据同步，不需要加锁，本质上就是封装了底层cpu提供的原子操作指令。此外go语言最开始的调度模型时GM模型，所有的内核级线程想要执行goroutine需要加锁从全局队列中获取，所以不同线程之间的竞争很激烈，调度效率很差。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_12.png"></p><p>后续引入了P(Processor)，每一个M(thread)要执行G(gorontine)的时候需要绑定一个P，其中P中会有一个待执行G的本地队列，只由当前M可以进行读写（少数情况会存在偷其他协程的G），读取P本地队列时不需要进行加锁，通过降低锁的竞争大幅度提升调度G的效率。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_13.png"></p><p>mysql利用mvcc实现多个事务进行读写并发时保证数据的一致性和隔离型，也是解决读写并发的一种无锁化设计方案之一。它主要通过对每一行数据的变更记录维护多个版本链来实现的，通过隐藏列rollptr和undolog来实现快照读。在事务对某一行数据进行操作时，会根据当前事务id以及事务隔离级别判断读取那个版本的数据，对于可重复读就是在事务开始的时候生成readview，在后续整个事务期间都使用这个readview。mysql中除了使用mvcc避免互斥锁外，bufferpool还可以设置多个，通过多个bufferpool降低锁的粒度，提升读写性能，也是一种优化方案。</p><p>日常工作 在读多写少的场景下可以利用atomic.value存储数据，减少锁的竞争，提升系统性能，例如配置服务中数据就是利用atomic.value存储的；syncmap为了提升读性能，优先使用atomic进行read操作，然后再进行加互斥锁操作进行dirty的操作，在读多写少的情况下也可以使用syncmap。</p><p>秒杀系统的本质就是在高并发下准确的增减商品库存，不出现超卖少卖的问题。因此所有的用户在抢到商品时需要利用互斥锁进行库存数量的变更。互斥锁的存在必然会成为系统瓶颈，但是秒杀系统又是一个高并发的场景，所以如何进行互斥锁优化是提高秒杀系统性能的一个重要优化手段。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_14.png"></p><p>无锁化设计方案之一就是利用消息队列，对于秒杀系统的秒杀操作进行异步处理，将秒杀操作发布一个消息到消息队列中，这样所有用户的秒杀行为就形成了一个先进先出的队列，只有前面先添加到消息队列中的用户才能抢购商品成功。从队列中消费消息进行库存变更的线程是个单线程，因此对于db的操作不会存在冲突，不需要加锁操作。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_15.png"></p><p>另外一种优化方式可以参考golang的GMP模型，将库存分成多份，分别加载到服务server的本地，这样多机之间在对库存变更的时候就避免了锁的竞争。如果本地server是单进程的，因此也可以形成一种无锁化架构；如果是多进程的，需要对本地库存加锁后在进行变更，但是将库存分散到server本地，降低了锁的粒度，提高整个服务性能。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_16.png"></p><h5 id="e9f55573"> 顺序写 </h5>mysql的InnoDB存储引擎在创建主键时通常会建议使用自增主键，而不是使用uuid，最主要的原因是InnoDB底层采用B+树用来存储数据，每个叶子结点是一个数据页，存储多条数据记录，页面内的数据通过链表有序存储，数据页间通过双向链表存储。由于uuid是无序的，有可能会插入到已经空间不足的数据页中间，导致数据页分裂成两个新的数据页以便插入新数据，影响整体写入性能。<p>此外mysql中的写入过程并不是每次将修改的数据直接写入到磁盘中，而是修改内存中buffer pool内存储的数据页，将数据页的变更记录到undolog和binlog日志中，保证数据变更不丢失，每次记录log都是追加写到日志文件尾部，顺序写入到磁盘。对数据进行变更时通过顺序写log，避免随机写磁盘数据页，提升写入性能，这种将随机写转变为顺序写的思想在很多中间件中都有所体现。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_17.png"></p><p>kakfa中的每个分区是一个有序不可变的消息队列，新的消息会不断的添加的partition的尾部，每个partition由多个segment组成，一个segment对应一个物理日志文件，kafka对segment日志文件的写入也是顺序写。顺序写入的好处是避免了磁盘的不断寻道和旋转次数，极大的提高了写入性能。</p><p>顺序写主要会应用在存在大量磁盘I&#x2F;O操作的场景，日常工作中创建mysql表时选择自增主键，或者在进行数据库数据同步时顺序读写数据，避免底层页存储引擎的数据页分裂，也会对写入性能有一定的提升。</p><h5 id="f5af8b4c"> 分片化 </h5>redis对于命令的执行过程是单线程的，单机有着很好的读写性能，但是单机的机器容量跟连接数毕竟有限，因此单机redis必然会存在读写上限跟存储上限。redis集群的出现就是为了解决单机redis的读写性能瓶颈问题，redis集群是将数据自动分片到多个节点上，每个节点负责数据的一部分，每个节点都可以对外提供服务，突破单机redis存储限制跟读写上限，提高整个服务的高并发能力。除了官方推出的集群模式，代理模式codis等也是将数据分片到不同节点，codis将多个完全独立的redis节点组成集群，通过codis转发请求到某一节点，来提高服务存储能力和读写性能。<p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_18.png"></p><p>同样的kafka中每个topic也支持多个partition，partition分布到多个broker上，减轻单台机器的读写压力，通过增加partition数量可以增加消费者并行消费消息，提高kafka的水平扩展能力和吞吐量。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_19.png"></p><p>新闻每日会生产大量的图文跟视频数据，底层是通过tdsql存储，可以分采分片化的存储思想，将图文跟视频或者其他介质存储到不同的数据库或者数据表中，同一种介质每日的生产量也会很大，这时候就可以对同一种介质拆分成多个数据表，进一步提高数据库的存储量跟吞吐量。另外一种角度去优化存储还可以将冷热数据分离，最新的数据采用性能好的机器存储，之前老数据访问量低，采用性能差的机器存储，节省成本。</p><p>在微服务重构过程中，需要进行数据同步，将总库中存储的全量数据通过kafka同步到内容微服务新的存储中，预期同步qps高达15k。由于kafka的每个partition只能通过一个消费者消费，要达到预期qps，因此需要创建750+partition才能够实现，但是kafka的partition过多会导致rebalance很慢，影响服务性能，成本和可维护行都不高。采用分片化的思想，可以将同一个partition中的数据，通过一个消费者在内存中分片到多个channel上，不同的channel对应的独立协程进行消费，多协程并发处理消息提高消费速度，消费成功后写入到对应的成功channel，由统一的offsetMaker线程消费成功消息进行offset提交，保证消息消费的可靠性。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_20.png"></p><h5 id="5a175771"> 避免请求 </h5>为提升写入性能，mysql在写入数据的时候，对于在bufferpool中的数据页，直接修改bufferpool的数据页并写redolog;对于不在内存中的数据页并不会立刻将磁盘中的数据页加载到bufferpool中，而是仅仅将变更记录在缓冲区，等后续读取磁盘上的数据页到bufferpool中时会进行数据合并，需要注意的是对于非唯一索引才会采用这种方式，对于唯一索引写入的时候需要每次都将磁盘上的数据读取到bufferpool才能判断该数据是否已存在，对于已存在的数据会返回插入失败。<p>另外mysql查询例如select * from table where name &#x3D; ‘xiaoming’ 的查询，如果name字段存在二级索引，由于这个查询是*，表示需要所在行的所有字段，需要进行回表操作，如果仅需要id和name字段，可以将查询语句改为select id , name from tabler where name &#x3D; ‘xiaoming’ ，这样只需要在name这个二级索引上就可以查到所需数据，避免回表操作，减少一次I&#x2F;O，提升查询速度。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_21.png"></p><p>web应用中可以使用缓存、合并css和js文件等，避免或者减少http请求，提升页面加载速度跟用户体验。</p><p>在日常移动端开发应用中，对于多tab的数据，可以采用懒加载的方式，只有用户切换到新的tab之后才会发起请求，避免很多无用请求。服务端开发随着版本的迭代，有些功能字段端上已经不展示，但是服务端依然会返回数据字段，对于这些不需要的数据字段可以从数据源获取上就做下线处理，避免无用请求。另外在数据获取时可以对请求参数的合法性做准确的校验，例如请求投票信息时，运营配置的投票ID可能是“” 或者“0”这种不合法参数，如果对请求参数不进行校验，可能会存在很多无用I&#x2F;O请求。另外在函数入口处通常会请求用户的所有实验参数，只有在实验期间才会用到实验参数，在实验下线后并没有下线ab实验平台的请求，可以在非实验期间下线这部分请求，提升接口响应速度。</p><h5 id="63a87cde"> 池化 </h5>golang作为现代原生支持高并发的语言，池化技术在它的GMP模型就存在很大的应用。对于goroutine的销毁就不是用完直接销毁，而是放到P的本地空闲队列中，当下次需要创建G的时候会从空闲队列中直接取一个G复用即可；同样的对于M的创建跟销毁也是优先从全局队列中获取或者释放。此外golang中sync.pool可以用来保存被重复使用的对象，避免反复创建和销毁对象带来的消耗以及减轻gc压力。<p>mysql等数据库也都提供连接池，可以预先创建一定数量的连接用于处理数据库请求。当请求到来时，可以从连接池中选择空闲连接来处理请求，请求结束后将连接归还到连接池中，避免连接创建和销毁带来的开销，提升数据库性能。</p><p>在日常工作中可以创建线程池用来处理请求，在请求到来时同样的从链接池中选择空闲的线程来处理请求，处理结束后归还到线程池中，避免线程创建带来的消耗，在web框架等需要高并发的场景下非常常见。</p><h5 id="99668f5d"> 异步处理 </h5>异步处理在数据库中同样应用广泛，例如redis的bgsave，bgrewriteof就是分别用来异步保存RDB跟AOF文件的命令，bgsave执行后会立刻返回成功，主线程fork出一个线程用来将内存中数据生成快照保存到磁盘，而主线程继续执行客户端命令；redis删除key的方式有del跟unlink两种，对于del命令是同步删除，直接释放内存，当遇到大key时，删除操作会让redis出现卡顿的问题，而unlink是异步删除的方式，执行后对于key只做不可达的标识，对于内存的回收由异步线程回收，不阻塞主线程。<p>mysql的主从同步支持异步复制、同步复制跟半同步复制。异步复制是指主库执行完提交的事务后立刻将结果返回给客户端，并不关心从库是否已经同步了数据；同步复制是指主库执行完提交的事务，所有的从库都执行了该事务才将结果返回给客户端；半同步复制指主库执行完后，至少一个从库接收并执行了事务才返回给客户端。有多种主要是因为异步复制客户端写入性能高，但是存在丢数据的风险，在数据一致性要求不高的场景下可以采用，同步方式写入性能差，适合在数据一致性要求高的场景使用。    此外对于kafka的生产者跟消费者都可以采用异步的方式进行发送跟消费消息，但是采用异步的方式有可能会导致出现丢消息的问题。对于异步发送消息可以采用带有回调函数的方式，当发送失败后通过回调函数进行感知，后续进行消息补偿。</p><p>在做服务性能优化中，发现之前的一些监控上报，曝光上报等操作都在主流程中，可以将这部分功能做异步处理，降低接口的时延。此外用户发布新闻后，会将新闻写入到个人页索引，对图片进行加工处理，标题进行审核，或者给用户增加活动积分等操作，都可以采用异步处理，这里的异步处理是将发送消息这个动作发送消息到消息队列中，不同的场景消费消息队列中的消息进行各自逻辑的处理，这种设计保证了写入性能，也解耦不同场景业务逻辑，提高系统可维护性。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-18-%E4%B9%9D%E5%A4%A7%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/img_22.png"></p><h3 id="25f9c7fa"> 总结 </h3>本文主要总结进行服务性能优化的几种方式，每一种方式在我们常用的中间件中都有所体现，我想这也是我们常说多学习这些中间件的意义，学习它们不仅仅是学会如何去使用它们，也是学习它们底层优秀的设计思想，理解为什么要这样设计，这种设计有什么好处，后续我们在架构选型或者做服务性能优化时都会有一定的帮助。此外性能优化方式也给出了具体的落地实践，<p>希望通过实际的应用例子加强对这种优化方式的理解。此外要做服务性能优化，还是要从自身服务架构出发，分析服务调用链耗时分布跟cpu消耗，优化有问题的rpc调用和函数。</p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态延时任务总结</title>
      <link href="/2024/10/02/2024-10-02-%E5%8A%A8%E6%80%81%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/02/2024-10-02-%E5%8A%A8%E6%80%81%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之所以延时任务就是为了将更新数据库的时间延时到下一个文件片更新之后，然后延时任务刷新，避免反复请求数据库。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>文件上传是一个很古老的业务了，业界在设计的时候都会规划三个功能：秒传、分片上传、断点续传。</p><h3 id="MD5密码杂凑算法"><a href="#MD5密码杂凑算法" class="headerlink" title="MD5密码杂凑算法"></a>MD5密码杂凑算法</h3><p>在介绍这三点之前，需要先了解MD5算法。这是一种密码杂凑算法，对于给定的任何输入，都会输出128位固定长度的16进制数字。既然长度固定，就会有重复的风险。国产算法SM3就是MD5的改良版，它优化了加密流程，也将输出的比特数增加到256位。</p><p>MD5重复的问题不是本文的重点，因此在接下来的叙述中不会考虑MD5重复的问题。</p><p>针对于MD5算法，我们任意输入文件名不同但文件内容相同的文件，都能得到相同的MD5值。这就是秒传的原理。如果数据库中已经存在客户端传过来的MD5值，那就说明以前有人已经上传过这份文件了，只需要新增一条用户和文件的对应关系即可。可以通俗的理解为：MD5值就是文件的身份证。</p><h3 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h3><p>很明显，用户和文件之间是多对多的关系。</p><p>我思考过两种表结构：</p><ol><li>只建立用户表和文件表，在文件表里关联用户表主键。</li><li>建立用户表、文件表、用户文件关联表。</li></ol><p>考虑到网盘的场景，文件内容相同的文件虽然文件名不同，但它们实际上还是同一份文件。</p><h4 id="采用第一种方案"><a href="#采用第一种方案" class="headerlink" title="采用第一种方案"></a>采用第一种方案</h4><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>MD5不能做主键，放着天然的主键属性不要，得让业务去生成主键。假如说有一个文件<code>程序员的自我修养.txt</code>，A用户上传完成后，在文件表增加一条<br><code>程序员的自我修养.txt-&gt;A</code>的一行数据。B把它更名为<code>自我修养.txt</code>上传，虽然文件名不同，MD5值却是相同的。但是文件表里肯定要再插入一条数据<br><code>自我修养.txt-&gt;B</code>的记录。MD5做主键就会冲突。但是这不是什么要紧的事。</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>相比于第二种方案，可以少建一张表，且避免了回表查询。</p><h4 id="用第二种方案"><a href="#用第二种方案" class="headerlink" title="用第二种方案"></a>用第二种方案</h4><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>MD5还是不能做主键。在这种方案里，如果文件表用MD5做主键，同一份文件只有一行数据，A对这个文件的文件名做了修改，在B用户看来，文件名是被同步修改的。B用户肯定会觉得碰上鬼打墙了，啥都没干文件名就被改了。</li><li><strong>要多建一张表，且会导致回表查询。</strong>查询某个用户上传的全部文件。如果是建立关联表的话，得先查关联表，拿到文件ID列表再去做回表查询。但如果是在文件表加用户字段，只需要查询<br><code>where userID ＝ xxx</code>就可以把用户上传的全部文件查出来。</li></ol><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><p>相比于第一种方案并没有什么优点。</p><h3 id="三个功能"><a href="#三个功能" class="headerlink" title="三个功能"></a>三个功能</h3><ul><li>秒传：发现数据库里已经存在相同MD5值的文件时，去文件表新增一行数据，判定此次上传完毕。</li><li>分片上传：将文件划分为多个子部分，分别上传每个子部分，是断点续传的实现原理。</li><li>断点续传：如果上一次上传被中断需要重新上传，不需要从头开始上传，而是从上一次已上传的最新部分开始上传。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然由于场景限制导致MD5这一天然的主键属性不能作为主键，这是产品特性决定的，同一份文件可能在不同用户的视角下名字不一样。但是MD5这个属性可以建立非唯一索引。</p><p>总体来看，流程比较简单，但是深究起来其中还是有不少可以挖掘的业务问题。</p><h2 id="没上传完怎么办？"><a href="#没上传完怎么办？" class="headerlink" title="没上传完怎么办？"></a>没上传完怎么办？</h2><h3 id="上传后的文件片怎么处理？"><a href="#上传后的文件片怎么处理？" class="headerlink" title="上传后的文件片怎么处理？"></a>上传后的文件片怎么处理？</h3><p>服务端需要将上传的那些文件片按照一定的规则（年-月）保存在临时目录中。出于需要实现断点续传的考虑，临时目录不能立马删掉。得保存一段时间。</p><ul><li>后续由延时任务将它删除吗？我认为并不需要，临时目录的删除并不需要很高的时间精准度，犯不着用延时任务增加系统复杂度。</li><li>那把删除临时目录的任务发送到MQ？也没有必要。在MQ不出现消息积压的情况下，几秒钟内消息就会被消费。破坏了断点续传。</li></ul><p>我认为最好的办法就是在月初统一删除上一个月的临时目录。比如第一级文件夹是xxxx年，第二级是xx月，里面保存了所有在xx月上传的文件片(<br>当然根据需要也可以精确到天，增加三级目录xx天)<br>。虽然会导致极端场景下断点续传失效（月底的晚上开始上传），但没必要为了极端场景做非常多优化。这些优化本身的成本可能比极端场景发生后的损失还大。技术总是服务于业务。（那我现在写的就是极端场景下恶意上传打垮服务器的解决方案，为什么要考虑它的解决方案？不考虑解决方案我怎么写简历？）</p><h3 id="有人恶意攻击怎么办"><a href="#有人恶意攻击怎么办" class="headerlink" title="有人恶意攻击怎么办"></a>有人恶意攻击怎么办</h3><p>前面说到文件片按照一定的规则（年-月）保存在临时目录中，月初才清理。</p><p>且文件片只有在全部上传完毕后才会合并，并更新用户已使用空间。</p><p>假如现在硬盘资源有限，有人从月初开始攻击服务器，具体表现为上传文件时不上传完。那么这些上传的文件碎片就会白白占据服务器硬盘资源而上传它们的用户的已使用空间却不会增加。久而久之用户上传的文件片已经远远超过他们的额度，服务器硬盘资源会被打垮。怎么解决？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>每个文件片上传时都去数据库里增加用户已使用空间吗？这会不会给数据库带来压力呢？数据库是整个服务端的最后方的组件，将数据持久化至硬盘，因此数据库本身的QPS完全比不上缓存。所以不能随随便便就请求数据库。</p><p>那就引入缓存？</p><p>将用户的已使用空间保存在redis里面？那是不是要考虑和数据库的一致性呢？redis虽然本身有备份机制，**<br>但他的备份机制并不能保证完全不丢数据。如果需要保证和数据库的一致性，**那和直接更新数据库没有任何区别，因为这些请求全部是写请求。</p><p>还有一个问题。用户上传到一半手动取消上传了，从用户角度考虑，用户肯定不希望在查看已使用空间时看到取消上传的文件还占据着已使用空间。这就带来一个新的问题：<br>服务器视角下的已使用大小是已上传完毕的文件总大小加上未上传完毕的总大小。用户视角下的已使用大小是他已经上传完毕的那些文件的总大小（实际使用中发现百度网盘、夸克网盘等等都是这样做的）。这就需要我们准备两套计算已使用大小的方案。</p><p>在用户表里用两个字段分别表示已上传完毕文件总大小以及未上传完毕总大小。前者只在文件片合并和删除文件时更新即可，后者则是每有一个文件片上传都需要更新。</p><p>服务器在判断是否超出限额时需要将两者相加。</p><p>在 Redis 中记录用户的这两个字段。每个文件片更新时更新未上传完毕总大小。然后保证和数据库的一致性。</p><p>但是这样做和直接更新数据库还是没有区别。有多少文件片被上传就要更新多少次数据库。能不能减少更新次数？</p><p>注意到即使更新无数次数据库，每一次更新都可以覆盖前一次更新。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>第一次更新是将未上传完大小<code>100M</code>加上这次文件片的大小<code>5M</code>得到<code>105M</code>；第二次更新是将未上传完大小<code>105M</code>加上这次文件片的大小<br><code>5M</code>得到<code>110M</code>。更新了两次数据库。如果在第二次更新时加上<code>5M * 2 = 10M</code>，再把第一次更新删除，也就是<code>100M + 10M = 110M</code>。这样做只更新了一次数据库。</p><p>因此考虑引入延时任务,每个文件片上传后，在上一个延时任务执行之前刷新延时任务的执行时间，将它接着向后延。让最后一次更新覆盖之前所有更新，做到只更新一次数据库。</p><h3 id="延时任务"><a href="#延时任务" class="headerlink" title="延时任务"></a>延时任务</h3><h4 id="存储延时任务的结构"><a href="#存储延时任务的结构" class="headerlink" title="存储延时任务的结构"></a>存储延时任务的结构</h4><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p>插入：O(1)</p><p>查询：O(logN)</p><p>实现：我们可以利用列表去存即将触发的任务信息，通过遍历的方式去取到大于当前时间的任务，并且触发。</p><p>优点：实现简单</p><p>缺点：但需要对所有任务进行遍历，查出很多无效数据，极其低效。</p><h5 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h5><p>删除：O(logN)</p><p>查询：O(1)</p><p>实现：我们也可以利用大顶堆的性质，每次都取堆顶元素，如果堆顶元素大于当前时间，那么就取最大元素。其余元素会利用大顶堆的性质，继续浮出最大的元素，然后继续比较。</p><p>优点：查询快，只会查到快到时间的任务，实现简单。</p><p>缺点：需要维护自身堆的性质，cpu压力高，无法抗住高并发。</p><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>查询：O(logN)</p><p>B+树（B-plus tree）是一种自平衡的树数据结构，它能够保持数据有序，允许插入、删除和查找操作在对数时间内完成。B+树特别适合于磁盘或其他直接存取辅助设备的存储系统，因为它能够最大化地减少I&#x2F;O操作次数。</p><h5 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h5><p>查询：O(logN)</p><p>跳表（Skip List）是一种基于有序链表的高效数据结构，它通过在链表的基础上增加多级索引来实现快速的查找操作。跳表允许在对数时间内完成搜索、插入和删除操作，且插入和删除操作不需要频繁调整数据结构。</p><h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><p>总的来说，列表和大顶堆由于自身的性质，并不适合这样的场景。对于扫表+触发的模式，其实本质是需要一个能高速范围查询的数据结构。</p><p>B+树和跳表都是高效的能范围查询数据结构，但它们各自适用于不同的场景。B+树更适合于磁盘存储和范围查询，而跳表则更适合于内存中的快速查找和分布式环境。</p><h4 id="存储数据库分析"><a href="#存储数据库分析" class="headerlink" title="存储数据库分析"></a>存储数据库分析</h4><p>我们举出基于内存的数据库的代表Redis和基于磁盘的数据库进行分析。</p><h5 id="Redis-VS-MySQL"><a href="#Redis-VS-MySQL" class="headerlink" title="Redis VS MySQL"></a>Redis VS MySQL</h5><p>1.Redis的底层是跳表，而MySQL的底层是B+树。就范围查询而言，两者不分伯仲。</p><p>2.但Redis没有事务概念，内部实现是单线程，没有锁竞争，再加上IO多路复用的特性和极其高效的数据结构实现，就注定单机qps要远超过mysql。</p><p>3.mysql在这个场景下的优势则是有持久化能力，不容易丢数据，Redis可能在RDB和AOF的过程中有丢数据的可能性。</p><p>因此，mysql和redis都有可能是作为存储任务的数据库，需要区分场景。</p><p>综合考虑下我选用Redis。虽然Redis有丢数据的风险无法完美保证延时任务不丢，但是在本文中描述的延时任务是不断更新的，是动态的。比如某条数据现在是10M，然后执行RDB备份。再然后更新延时任务变成11M，假设此时断电宕机，11M这个数据没保存下来，但是10M这个数据已经保存了啊。虽然丢了一点数据，但是不多。系统停机维护时把延时任务和临时目录全删了，再把数据库中记录用户未上传完大小的这个字段置为0。一切又回到最初的起点。</p><blockquote><p>问题又来了，既然这里可以接受丢数据，那为什么不把未上传完大小这个字段放在 redis ，然后不保证和 mysql 的一致性？或者说只有<br>redis 里放未上传完大小，mysql 表字段里只有用户已上传完大小。都是相同的丢数据风险。为什么这里可以接受上面不可以接受？</p><p>其实这个需求就不是个合理的需求。只是我需要通过这个需求找到一个可以写简历的亮点。恰好对任务调度比较熟悉，所以需要通过这个不合理的需求引入任务调度。</p></blockquote><p>如果用mysql存储动态延时任务，那就要经常更新mysql。其实也可以。但是mysql扛不住比较大的QPS，速度不如redis。综合考虑我还是用redis存延时任务。</p><h4 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h4><p>只要涉及到了缓存和数据库就一定会有缓存一致性问题，延时任务也不例外。</p><p>这里用的策略是先更新缓存，再更新数据库。</p><p>数据库的更新取决于延时任务被执行的时间。</p><p>通过延时任务的执行来保证 redis 和 mysql 的最终一致性。</p><h4 id="延时任务的具体思路"><a href="#延时任务的具体思路" class="headerlink" title="延时任务的具体思路"></a>延时任务的具体思路</h4><p>文件片被上传时，用一个redis结构保存延时任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">    <span class="type">long</span> timestamp; <span class="comment">// 任务被创建或更新的时间</span></span><br><span class="line">    <span class="type">long</span> unfinishedDBSize;<span class="comment">// 待更新至数据库的未上传完成大小</span></span><br><span class="line">    String userID; <span class="comment">// 任务执行器需要根据UserID写SQL</span></span><br><span class="line">    String md5;<span class="comment">//标识唯一文件</span></span><br><span class="line">    <span class="type">int</span> flag;<span class="comment">//标识当前延时任务是否被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义zset中的member</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-10-02-fileIUpLoad/img.png"></p><p>zset 中 member 的整体结构设计。<br>同一个zset桶中，同一个用户的不同延时任务的时间戳可能相同，这需要member中保存userID和md5作为辨别。</p><blockquote><p>对上图的更正：</p><ol><li>HashMap结构中的V保存时间戳与userID的或运算结果与Zset桶的编号</li><li>zset中的score保存时间戳与UserId的或运算结果。因为在某个zset桶中，不同用户上传的文件片延时任务的时间戳可能相同。但如果只是时间戳+userID的话太长了，不能作为 score。因此改为或运算结果(时间戳是Long类型，占低41位，高23位是0。userID的高23位有1有0，也就是说高23位的或运算结果就是userid的高23位。在时间戳相同的情况下，区分度完全由Userid决定，这就避免了不同用户上传的文件片的延时任务在zset桶中具有相关的score)。同时对于单个zset而言，score有不有序不重要，重要的是能通过score定义到唯一的member。但是这也意味着某个zset桶中可能存在同一个用户的不同延时任务。</li></ol><p>再次更正：</p><p>既然 score 用 timestamp 与 userID 的或运算结果，而且区分度取决于 userID。那为什么不直接用 userID 作为 score？</p><p>最终结果：</p><ol><li>HashMap结构中的V保存Zset桶的编号</li><li>zset 桶中的score 是 userID</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table user_info</span><br><span class="line">(</span><br><span class="line">    user_id              varchar(12) not null primary key,</span><br><span class="line">    use_space_finished   bigint default 1024 comment &#x27;已上传完毕文件使用总空间,单位byte&#x27;,</span><br><span class="line">    use_space_unfinished bigint default 0 comment &#x27;未上传完毕文件使用总空间,单位byte&#x27;,</span><br><span class="line">    total_space          bigint comment &#x27;总空间&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>用户表相关字段</p><p>某文件第一个文件分片上传完后，创建出一个任务。根据当前时间戳 ，得到目标 zset 桶编号(如23-54-1）， 以 userID 作为 score，任务作为<code>member</code>加入到<code>zset</code>中。再用一个 map 记录md5+userid 和zset 桶编号(23-54-1)的映射。</p><p>后续的文件分片上传时，因为任务需要更新，。所以需要设计了以下几个步骤：</p><ol><li>从 hashmap 中根据 userID+md5 拿到zset 桶编号。</li><li>从 zset 桶中用 <code>ZRANGEBYSOCRE</code> 取出这个 userID 对应的任务列表(都是这个用户上传的文件片的任务且还没有被调度)，并从中找到当前 md5 对应的任务。如果找不到说明任务被调度了，创建新任务。</li><li>更新任务信息</li><li>根据当前 timestamp 算出存储任务的桶，如果还是这个桶，就通过 <code>ZADD</code>命令把任务列表放回桶(23-54-1) ，跳过第五步；如果不是，就计算出新的桶编号，如：(23-59-3)，并执行第五步。</li><li>将任务列表中的目标任务删除，任务列表重新插入 zset 桶(23-54-1)，目标任务加入到 zset 桶(23-59-4)中。</li><li>更新HashMap中记录的时间戳与桶编号</li></ol><p>第5,6步中对 redis 的操作不是原子性的，可能会有这样的问题吗？</p><ol><li>调度器先扫描了 zset 桶(23-54-1)，然后任务列表才被重新放回桶中，导致任务要晚一天执行。<blockquote><p>并不会有，延时任务在业务的设定下是延时23个小时。调度器调度的任务是23个小时之前的，不会调度现在新增的任务</p></blockquote></li></ol><blockquote><p>为什么 不用 文件id作为key呢？</p></blockquote><p>主要是考虑到在文件被完全上传完之前，确定id没有意义。除非客户端在上传一个文件时携带id，且保证发生断点续传时，第二次上传携带的id和第一次相同。但是满足这个条件的id的生成规则肯定和雪花算法不同，因为雪花算法生成的id和时间有关，但当前场景下需要时间无关。注意。这里的意思并不是说一个文件被重复上传时客户端生成的id前后都一样，而是在一次上传流程中，如果因为应用重启等原因出现了中断，中断后的上传请求中的文件id和中断前保持相同。重复上传时的id则必须不同。</p><blockquote><p>文件只在完全被上传后才会为它生成 id，否则用 md5+userid表示</p><p>而且这篇文章是针对于服务端的，我假设客户端上传时不携带id信息。另外，我认为服务端一个重要的原则就是不要相信客户端传来的数据，能做检验的数据一定要做检验。客户端传来的数据都是可以被篡改的。https虽然安全，但如果出现了中间服务器，https报文就变成明文了。</p></blockquote><p>后续文件片上传时，去 map 里根据md5+userid 拿到保存任务的 zset 编号，根据当前时间所属分钟 + 5s 是否等于该 zset 所属的分钟得到<br>boolean 类型变量 x。 去这个 zset 里根据md5+userid 找到这个文件的任务。如果 x &#x3D;&#x3D; true, 修改该任务。否则将该任务删除，移至下一分钟的<br>zset。</p><p>当所有文件片正常上传完触发文件片合并，然后数据库更新<code>use_space_finished</code>字段。</p><p>之后根据<code>map</code>通过<code>用户id + 文件md5值</code>获取 zset 编号，获取该<code>zset</code>中对应任务的<code>unfinishedDBSize</code>和<code>unfinishedSize</code>。</p><p>执行<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> - <code>unfinishedDBSize</code> - <code>unfinishedSize</code>。这是补偿用户的操作。</p><p>因为延时任务肯定会被执行的(<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> + <code>unfinishedDBSize</code>)，先减<code>unfinishedDBSize</code><br>和后减<code>unfinishedDBSize</code>没区别。至于<code>unfinishedSize</code><br>？只要这个文件的延时任务没有被执行过，它就是0。即使执行过也没关系，见<a href="#custom">3.4 考虑断点续传，用户只上传了一部分就宕机了，然后恢复机器继续上传。但是此时这个文件在zset里的任务已经更新到数据库了。后续的一部分文件上传是什么流程？</a></p><p>（延时任务能不能成功执行至关重要！！！最终一致性全靠它保证！！！）</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>一个文件片上传完后，有六个步骤：</p><ol><li>如果没有这个文件 md5 + userid 的临时目录，那么创建任务，放入当前实际的 Zset，在 map 里记录 Zset 和 MD5+</li><li>后续的文件片上传根据<code>文件md5值+用户id</code>去<code>map</code>里找到保存上一个文件片延时任务的 zset，在根据 md5 + userid 去 Zset<br>里找到延时任务</li><li>修改任务，根据当前时间 + 5s 决定任务修改后是否移至另一 Zset 。是考虑到调度器的调度时机。</li><li>写<code>map</code>，更新<code>文件md5值+用户id</code>对应的 Zset 编号。</li><li>执行延时任务，<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> + <code>unfinishedDBSize</code></li><li>文件上传完成，<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> - <code>unfinishedDBSize</code> - <code>unfinishedSize</code></li></ol><p>第五步和第六步的执行顺序没有要求！谁先执行都可以！</p><hr><h3 id="延时任务执行调度"><a href="#延时任务执行调度" class="headerlink" title="延时任务执行调度"></a>延时任务执行调度</h3><p>当任务量很大时，任务的执行调度也需要花心思设计。</p><h4 id="调度器扫描"><a href="#调度器扫描" class="headerlink" title="调度器扫描"></a>调度器扫描</h4><p>集群模式下的调度器每分钟执行一次，扫描上一个小时的该分钟内所有的 zset 桶。注意由于是集群模式，需要先获得目标桶的锁才能扫描，抢锁用 redission 看门狗实现。如果调度器执行过程中挂了，里面这些任务就得晚一天执行了。</p><blockquote><p>如果某个调度器获得了一个桶的锁却挂了，有没有一种核验机制能够确定这一分钟内的桶哪些被扫描执行了哪些没被扫描执行呢？</p><p>有，另起一个定时任务，检查上一分钟的那些桶的里有没有数据。如果有，调度一遍。</p><p>原因见下文。刚被调度了的桶再想有数据新增，得等 1 个小时。</p><p>所以上一分钟的那些桶里如果还有数据，一定是调度器有问题，得看日志排查。</p></blockquote><p>任务扫描这里有个问题：扫描出来的任务在下发后要从桶中删掉，桶里新增的任务也会被删，怎么办？</p><blockquote><p>由于任务调度的那些桶对应的时间比当前时间早一个小时，新增的任务都放在当前时间的那些桶里了，当前扫描的桶里的任务都是 23 小时前增加的。</p><p>比如现在时间是 2023-12-21  20:40, 某个调度器扫描了(21-40-1)这个桶，这个桶里的任务都是2023-12-20  21:40 放进去的，现在新增的任务进的桶是(20-40-1) - (20-40-n)。</p><p>(21-40-1)这个桶再想有数据新增，得等 1 个小时。</p><p>除非生产者的机器时钟有问题，否则绝对不会有数据新增。</p></blockquote><p>这也就意味着一天 24 个小时，每时每刻 23 个小时里的桶有数据，1 个小时里的桶没数据。如果不能理解可以这样理解：24 个小时都没数据，零点开始运行，第零个小时里的桶有数据。扫描器扫描的是第一个小时，无数据………到了 23 点，第 23 个小时的桶开始有数据，扫描器开始扫描第零个小时的桶，有数据。<br>当然延时 23 个小时有点太长了，也可以根据真实业务场景用分钟代替小时，每 23 分钟一循环。</p><h4 id="任务下发"><a href="#任务下发" class="headerlink" title="任务下发"></a>任务下发</h4><p>扫描出来的任务通过带回调函数的 send 方法发给 Kafka，配置好 ack。所有任务都发给 Kafka 后，删除这个桶里全部数据。</p><p>有些任务实在发不出去，也不能留在桶里，因为调度器只要正常调度了，桶里的数据就要删掉，Kafka 的问题是 Kafka 的问题，和调度器没关系。</p><p>发不出去的任务在回调函数中设置存入数据库里的死信表里等运维人员处理。</p><blockquote><p>如果任务发不出去，数据库也挂了怎么办？<br>消息发送前先写日志。数据库挂了先恢复，再根据日志里的记录和表中数据比对，比对不上的做数据恢复。</p></blockquote><p>任务调度的更多细节具体参考</p><p><a href="https://juziblog.space/2024/08/30/2024-08-30-%E9%AB%98%E6%80%A7%E8%83%BD%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/">高性能调度系统设计总结</a></p><h2 id="一些A-Q"><a href="#一些A-Q" class="headerlink" title="一些A&amp;&amp;Q"></a>一些A&amp;&amp;Q</h2><h3 id="延时任务重复问题"><a href="#延时任务重复问题" class="headerlink" title="延时任务重复问题"></a>延时任务重复问题</h3><p>一个文件多个分片上传，会造成该文件有多个延时任务。也就说一个分片一个延时任务。如何解决重复的问题？</p><p>只有第一个分片会创建延时任务，后续文件片根据 <code>MD5 + userid</code> 会找到延时任务删除、修改、新增。</p><h3 id="用户开多个客户端同时上传，怎么保证延时任务更新正确？"><a href="#用户开多个客户端同时上传，怎么保证延时任务更新正确？" class="headerlink" title="用户开多个客户端同时上传，怎么保证延时任务更新正确？"></a>用户开多个客户端同时上传，怎么保证延时任务更新正确？</h3><p><code>zset</code>中的延时任务只和某一个文件有关。开多个客户端上传多个文件，就会出现多个延时任务，彼此互不干扰，并不会有什么问题。</p><h4 id="开多个客户端上传同一份文件呢？"><a href="#开多个客户端上传同一份文件呢？" class="headerlink" title="开多个客户端上传同一份文件呢？"></a>开多个客户端上传同一份文件呢？</h4><p>那就让他传。本质上和开多个客户端上传多个文件没有区别。只是服务器上会出现两份相同的文件。</p><p>而且这种情况出现概率非常小。</p><h3 id="用户开多个客户端同时上传，怎么保证不会超过限额？"><a href="#用户开多个客户端同时上传，怎么保证不会超过限额？" class="headerlink" title="用户开多个客户端同时上传，怎么保证不会超过限额？"></a>用户开多个客户端同时上传，怎么保证不会超过限额？</h3><p>网盘产品里，用户一但登录了，大概率会开第二个客户端也登录，比如手机登录了，上传一个文件，网页接着登录，下载该文件。这期间，用户可能会多次刷新网页或者打开网盘的别的页面。而每个页面都需要显示用户已使用空间和总空间。</p><p>于是可以考虑在用户登录后缓存一些数据。在 Redis 中保存每个用户的总空间<code>total_Space</code>，已上传完毕大小<code>finishedFileSize</code>和未上传完毕大小<code>unfinishedFileSize</code>。</p><p>文件片上传前，判断下<code>unfinishedFileSize</code>+ <code>finishedFileSize</code> 是否大于<code>total_Space</code>。如果大于，就返回错误信息，直接告诉用户别的客户端上传的文件有点大，超过了限额，当前文件不能上传。</p><p>如果上面的校验没问题，那就让<code>unfinishedFileSize</code>加上文件总大小。</p><p>文件上传完毕，从<code>unfinishedFileSize</code>中减去该文件的大小。</p><p>显示给用户看的已使用空间就是<code>finishedFileSize</code>。只把<code>finishedFileSize</code>返回即可。</p><h3 id="custom">考虑断点续传，用户只上传了一部分就宕机了，然后恢复机器继续上传。但是此时这个文件在zset里的任务已经更新到数据库了。后续的一部分文件上传是什么流程？</h3><p>举个场景例子并给出解决方案：</p><p>某用户在数据库中<code>use_space_unfinished</code>字段是0。<code>zset</code>里<code>unfinishedDBSize</code>字段是10M。</p><p>然后用户宕机，延时任务没有被刷新而是被触发，导致用户在数据库中的<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> + <code>10M</code>  &#x3D; <code>0M</code> + <code>10M</code>&#x3D; <code>10M</code>。任务触发后被删除。</p><p>用户重启客户端发生断点续传，下一个大小为<code>1M</code>的文件片被上传了。于是写<code>zset</code>，新增一个延时任务，<code>unfinishedDBSize</code>字段是<code>1M</code>。</p><p>假如这个大小为<code>1M</code>的文件片是最后一个文件片，上传完就触发文件片合并流程。在合并的流程中，计算出真实合并了<code>11M</code>大小的文件片，于是修改<code>use_space_unfinished</code>字段，<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> - <code>11M</code> &#x3D; <code>-1M</code>。</p><p>但是延时任务还没执行，等到延时任务执行后，<code>use_space_unfinished</code> &#x3D; <code>use_space_unfinished</code> + <code>1M</code>  &#x3D; <code>-1M</code> + <code>1M</code>&#x3D; <code>0M</code>。保证了最终一致性。</p><h3 id="为什么不用md5-userid-作为文件表主键呢？"><a href="#为什么不用md5-userid-作为文件表主键呢？" class="headerlink" title="为什么不用md5+userid 作为文件表主键呢？"></a>为什么不用md5+userid 作为文件表主键呢？</h3><p>因为用户可以一份文件上传多次，会出现主键重复问题</p><h3 id="为什么延时任务不设计成一个用户一个任务而是一个文件一个任务？"><a href="#为什么延时任务不设计成一个用户一个任务而是一个文件一个任务？" class="headerlink" title="为什么延时任务不设计成一个用户一个任务而是一个文件一个任务？"></a>为什么延时任务不设计成一个用户一个任务而是一个文件一个任务？</h3><p>一个用户一个任务是更优的方案，可以显著降低任务的数量。这是一个优化点。</p><p>在一个用户一个客户端的情况下，一个用户一个任务和一个文件一个任务是一样的。</p><p>一个用户开多个客户端上传或者单客户端并行上传多文件，可以降低任务的数量。</p>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 任务调度 </tag>
            
            <tag> 延时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能调度系统设计总结</title>
      <link href="/2024/08/30/2024-08-30-%E9%AB%98%E6%80%A7%E8%83%BD%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/"/>
      <url>/2024/08/30/2024-08-30-%E9%AB%98%E6%80%A7%E8%83%BD%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：akinwang<br>调度模块在很多系统中都是常用的模块，比如实习生的每天签到邮件，预约银行的业务短信，学习通的上课通知，腾讯视频push中台的任务下发，调度系统在中间起到关键作用。<br>原文链接：<a href="https://mp.weixin.qq.com/s/fAzH8SOWnocshMX3CB6OMw">高性能调度系统设计总结</a></p></blockquote><p>那么什么是调度？<br />本质就是通过一些自定义策略，定时或者周期性的去触发某些事件，比如去发起一次rpc调用，和下游进行一次通信。<br><a name="9bfd9ada"></a></p><h3 id="通用流程"><a href="#通用流程" class="headerlink" title="通用流程"></a><strong>通用流程</strong></h3><p>调度行为可以抽象成以下几步：<br />1.任务生成。<br />2.任务存储。<br />3.任务触发。<br />4.路由实例。<br />如果能做好这几步，那么一个高性能的调度系统也就诞生了，而每一步的技术选型，都和未来系统想要达成的目标（高精度，高可用），有着密不可分的关系，下面我会针对这几步进行分析。<br />后面会举出一些实际的系统进行说明。<br><a name="599c0c18"></a></p><h3 id="任务生成"><a href="#任务生成" class="headerlink" title="任务生成"></a><strong>任务生成</strong></h3><p>1.<strong>单次任务生成</strong>：对于单次任务，通常由管理台直接发起请求，将任务信息写入系统。<br />2.<strong>周期性任务生成</strong>：周期性任务生成类似于打点计时器。每当任务触发时，系统会计算出未来需要触发的任务时间列表。例如，对于每小时执行的任务，系统会在第二天生成24个整点任务。<br />3.<strong>推送系统任务生成</strong>：对于推送系统任务，系统会根据用户过去的行为画像预测其最有可能点击的时间区间。在第二天到来之前，系统会预先计算并生成第二天各个时间点的推送任务。<br /><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-30-%E9%AB%98%E6%80%A7%E8%83%BD%E8%B0%83%E5%BA%A6/img.png" alt="image.png"><br><a name="89748a0e"></a></p><h3 id="任务存储"><a href="#任务存储" class="headerlink" title="任务存储"></a><strong>任务存储</strong></h3><p>任务存储的思考分为两个方面，第一，是用什么数据结构存。第二是用什么类型的db去存。<br />对于高性能调度系统而言，主要看重<strong>范围查询效率</strong>，<strong>查询的qps，分布式锁的表现。</strong><br />至于这里为什么提到了分布式锁，是因为在集群模式下，哪一台实例去执行任务扫描这一过程依赖于分布式锁的抢占。<br><a name="13105c6e"></a></p><h4 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="数据结构分析"></a><strong>数据结构分析</strong></h4><p><a name="3712972d"></a></p><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h5><p>插入：O(1)<br />查询：O(logN)<br />实现：我们可以利用列表去存即将触发的任务信息，通过遍历的方式去取到大于当前时间的任务，并且触发。<br />优点：实现简单<br />缺点：但需要对所有任务进行遍历，查出很多无效数据，极其低效。<br><a name="82197238"></a></p><h5 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a><strong>大顶堆</strong></h5><p>删除：O(logN)<br />查询：O(1)<br />实现：我们也可以利用大顶堆的性质，每次都取堆顶元素，如果堆顶元素大于当前时间，那么就取最大元素。其余元素会利用大顶堆的性质，继续浮出最大的元素，然后继续比较。<br />优点：查询快，只会查到快到时间的任务，实现简单。<br />缺点：需要维护自身堆的性质，cpu压力高，无法抗住高并发。<br><a name="19dd3d1e"></a></p><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a><strong>B+树</strong></h5><p>查询：O(logN)<br />B+树（B-plus tree）是一种自平衡的树数据结构，它能够保持数据有序，允许插入、删除和查找操作在对数时间内完成。B+树特别适合于磁盘或其他直接存取辅助设备的存储系统，因为它能够最大化地减少I&#x2F;O操作次数。<br><a name="b9130034"></a></p><h5 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a><strong>跳表</strong></h5><p>查询：O(logN)<br />跳表（Skip List）是一种基于有序链表的高效数据结构，它通过在链表的基础上增加多级索引来实现快速的查找操作。跳表允许在对数时间内完成搜索、插入和删除操作，且插入和删除操作不需要频繁调整数据结构。<br><a name="cc1d28d4"></a></p><h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a><strong>小总结</strong></h5><p>总的来说，列表和大顶堆由于自身的性质，并不适合这样的场景。对于扫表+触发的模式，其实本质是需要一个能高速范围查询的数据结构。<br />B+树和跳表都是高效的能范围查询数据结构，但它们各自适用于不同的场景。B+树更适合于<strong>磁盘存储和范围查询</strong>，而跳表则更适合于<strong>内存中的快速查找和分布式环境</strong>。<br><a name="3c460321"></a></p><h4 id="数据库分析"><a href="#数据库分析" class="headerlink" title="数据库分析"></a><strong>数据库分析</strong></h4><p>我们举出基于内存的数据库的代表Redis和基于磁盘的数据库进行分析。<br><a name="redis-vs-mysql"></a></p><h5 id="Redis-VS-MySQL"><a href="#Redis-VS-MySQL" class="headerlink" title="Redis VS MySQL"></a><strong>Redis VS MySQL</strong></h5><p>1.Redis的底层是跳表，而MySQL的底层是B+树。就范围查询而言，两者<strong>不分伯仲</strong>。<br />2.但Redis没有事务概念，内部实现是单线程，没有锁竞争，再加上IO多路复用的特性和极其高效的数据结构实现，就注定单机qps要远超过mysql。<br />3.mysql在这个场景下的优势则是有持久化能力，不容易丢数据，redis可能在RDB和AOF的过程中有<strong>丢数据</strong>的可能性。<br />因此，mysql和redis都有可能是作为存储任务的数据库，需要区分场景。<br><a name="14edacb1"></a></p><h4 id="分布式锁的分析"><a href="#分布式锁的分析" class="headerlink" title="分布式锁的分析"></a><strong>分布式锁的分析</strong></h4><p>在集群模式下，哪一台实例去执行任务扫描这一过程依赖于分布式锁的抢占。<br><a name="dda2dbe3"></a></p><h5 id="基于MySQL实现"><a href="#基于MySQL实现" class="headerlink" title="基于MySQL实现"></a><strong>基于MySQL实现</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from lock_table where lock_name = &#x27;schedule_lock&#x27; for update</span><br></pre></td></tr></table></figure><p>主要是利用了当前读，将这条数据加上了行锁，其他线程在抢锁的时候会阻塞。<br><a name="557c1664"></a></p><h5 id="基于Redis实现"><a href="#基于Redis实现" class="headerlink" title="基于Redis实现"></a><strong>基于Redis实现</strong></h5><p>加锁：SET key value PX expireTime NX。<br />解锁：del key。<br />然而，仅依靠这两行命令作为分布式锁的实现，确实显得过于简单。在网络波动或垃圾回收（GC）的情况下，很有可能出现超时时间已过，但仍尝试释放锁的情况，从而导致错误地释放了其他客户端持有的锁。<br />这种情况可能会引起任务的重复下发，为了避免这一问题，下游系统不得不引入去重机制。<br />为确保安全，建议引入Lua脚本来优化锁的操作。在释放锁之前，Lua脚本可以检查锁的持有者是否为当前客户端，只有确认是自身持有的锁时，才执行释放操作。这样一来，GET和DEL两个操作就能合并为一次原子操作，从而避免潜在的安全隐患。<br />总的而言，mysql的分布式锁实现简单，但性能低。redis实现稍微复杂，性能高，一般用redis的多一点。</p><p><a name="33c3bf86"></a></p><h3 id="任务触发"><a href="#任务触发" class="headerlink" title="任务触发"></a><strong>任务触发</strong></h3><p>在构建高效、可靠的分布式任务调度系统时，我们需要考虑多个方面，触发包括定时扫描、状态更新、任务重试等关键环节。<br><a name="2e5c6c42"></a></p><h4 id="定时扫描"><a href="#定时扫描" class="headerlink" title="定时扫描"></a><strong>定时扫描</strong></h4><p>触发的本质就是将数据从db加载进内存中，那么我们可以通过定时任务，按照一定时间间隔去加载。那么<br />1.谁来扫描？<br />2.扫描的时间间隔多少合理？<br><a name="0575021e"></a></p><h5 id="谁来扫描？"><a href="#谁来扫描？" class="headerlink" title="谁来扫描？"></a><strong>谁来扫描？</strong></h5><p>负责扫描的实例需将扫描到的任务进行下发，即发起RPC调用。<br />为确保实例能够并发发起多条请求，其机器资源应具备<strong>足够的线程数</strong>。为实现扫描与下发任务的负载均衡，各实例可通过抢锁机制竞争扫描权限。<br />获得锁的实例将负责执行扫描及下发任务的职责。<br /><br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-30-%E9%AB%98%E6%80%A7%E8%83%BD%E8%B0%83%E5%BA%A6/img_1.png" alt="image.png"><br />如上图，每个实例都有一个定时任务，x秒执行一次，去尝试抢锁。<br><a name="1a58ecca"></a></p><h5 id="扫描的时间间隔多少合理？"><a href="#扫描的时间间隔多少合理？" class="headerlink" title="扫描的时间间隔多少合理？"></a><strong>扫描的时间间隔多少合理？</strong></h5><p>扫描时间间隔的设定对于确保系统性能和精度至关重要。这个间隔应当基于系统所需的实时精度以及单次扫描所生成的任务数量来合理确定。盲目降低扫描时间间隔并不总是能提高精度；相反，它可能会导致效率降低，甚至增加数据延迟。<br />举个例子，如果系统每1秒执行一次扫描，但每次扫描产生大量任务，而RPC处理时间长达2秒，且在此期间无法解锁以供其他实例扫描，那么第2秒的数据延迟将会显著增加。也就是说，本该1s完成的事情，他拖到了第2s才完成，那么第2s的任务就会被连累到第3s才做完……<br />因此，在确定扫描时间间隔时，应考虑以下两点：<br />1.<strong>对于精度要求不高且任务量较大的场景</strong>：可以适当延长扫描时间间隔，以确保在单次扫描周期内能够完成所有任务的处理下发。这样可以减轻系统负担，提高整体效率。<br />2.<strong>对于精度要求高同时任务量也很大的场景</strong>：除了优化RPC处理流程外，还可以考虑改进数据存储结构，将数据分片分桶处理。通过为每个数据分片分配独立的扫描实例，可以实现并行处理，从而在保证高精度的同时提升系统响应速度。<br />综上所述，合理的扫描时间间隔应当根据具体应用场景和系统需求进行细致调整，以达到最佳的性能和精度平衡点。<br><a name="164140b2"></a></p><h4 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a><strong>状态更新</strong></h4><p>为了让我们的系统展现出卓越的性能和高精度，我们采用了异步方式来下发任务。异步处理的明显优势在于它能够使任务并发执行，无需等待响应，从而显著提升了系统的信息处理能力。然而，这也带来了一个问题：我们无法确切知道下游系统是否真正收到了任务。即便上游系统竭尽全力发送任务，如果下游系统接收不到，这些努力也将化为泡影。<br />因此，我们需要下游系统在成功接收到信息后，主动发送一个<strong>确认信号（ACK）</strong>。一旦系统接收到这个ACK，我们就能记录下触发时间和执行时间等相关信息，以便后续的任务重试模块进行相应的处理。<br />考虑到任务是并发下发的，返回的信息量可能会非常庞大，每条返回信息都可能触发一次远程过程调用（RPC），这无疑会大量消耗连接资源。为了解决这个问题，我们引入了队列机制。<br /><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-30-%E9%AB%98%E6%80%A7%E8%83%BD%E8%B0%83%E5%BA%A6/img_2.png" alt="image.png"><br />队列机制的工作原理如下：<br />通过引入ACK队列，我们实现了以下几个关键效果：<br />1.当任务队列满载时，我们可以一次性取出所有元素，触发一次RPC请求。这样，原本需要多次请求的单个数据处理，现在可以合并为一次批量处理。<br />2.即使任务队列未满，但如果自上次取元素以来经过的时间超过了预设的阈值，我们也会将队列中的所有数据一次性取出，触发一次RPC请求。<br />通过这种方式，我们成功地实现了连接复用和即时响应的双重效果，<strong>这也是一个写聚合的思想。</strong><br />但是坏处也很明显，就是我们这个队列是基于内存的，实例宕机有丢消息的可能性。时间的阈值也需要经验去设置，如果设置短了，连接不会复用，设置长了，可能影响后续任务重试时的扫描，造成误判。<br />这种思想源于Kafka提供的Micro-Batch的概念，他会将相同Topic和Partition的消息聚合成一个批次，然后一次性发送到Kafka集群<br><a name="a8b9b9b5"></a></p><h4 id="任务重试"><a href="#任务重试" class="headerlink" title="任务重试"></a><strong>任务重试</strong></h4><p>上文我们分析了如何让海量任务下发，但仍然做不到能让调度系统拥有可靠性。在分布式环境下，服务器可能因为网络延迟，服务器故障，资源竞争等原因，任务执行可能会失败。那么如何处理这些失败的任务呢？<br />其实这个问题可以拆解成几个小任务：<br><a name="822e66fc"></a></p><h5 id="如何检测到失败的任务？"><a href="#如何检测到失败的任务？" class="headerlink" title="如何检测到失败的任务？"></a><strong>如何检测到失败的任务？</strong></h5><p>我们上个步骤的下发回流，就是为了收集任务的执行上下文信息。有了这些信息，我们只需要去设置一个定时任务，快速的扫描这个任务信息即可。<br><a name="60ce54a3"></a></p><h5 id="如何定义一个失败的任务？"><a href="#如何定义一个失败的任务？" class="headerlink" title="如何定义一个失败的任务？"></a><strong>如何定义一个失败的任务？</strong></h5><p>1.在下发一段较长的时间后，仍然没有回流信息写入。<br />2.回流信息写入成功，但回流信息中的响应code为失败。<br><a name="d2edc2f5"></a></p><h5 id="检测到失败任务以后的重试策略？"><a href="#检测到失败任务以后的重试策略？" class="headerlink" title="检测到失败任务以后的重试策略？"></a><strong>检测到失败任务以后的重试策略？</strong></h5><p>重试策略分为重试次数和重试间隔。<br />每次重试完成，我们需要去更新这个已经重试次数，并检测他是否等于最大重试次数，之所有有这个最大重试次数，是为了防止他无限重试，造成重试风暴，而超过这个最大重试次数的，我们可以把它塞入<strong>死信队列</strong>中，让负责这个任务的人手动的去处理。<br />而重试间隔主要也分为几种：<br /><strong>1. 固定间隔重试</strong><br />在这种策略中，每次重试之间都有一个固定的时间间隔。例如，如果操作失败，系统会在1秒后重试，然后是2秒后重试，依此类推。<br /><strong>2. 指数退避重试</strong><br />指数退避重试策略是一种更复杂的重试策略，其中每次重试之间的时间间隔呈指数增长。例如，第一次重试可能在1秒后，第二次在2秒后，第三次在4秒后，以此类推。这种策略有助于减少对系统的冲击，特别是在高负载或网络拥塞的情况下。<br />之所以采用以上这两种策略是因为rpc接口调用在遇到服务质量异常的错误的时候，由于服务质量异常是有一定时间的，因此有各种退避策略，一定程度上给足下游恢复的时间。<br><a name="c678fed7"></a></p><h5 id="下游应该如何处理重试的任务？"><a href="#下游应该如何处理重试的任务？" class="headerlink" title="下游应该如何处理重试的任务？"></a><strong>下游应该如何处理重试的任务？</strong></h5><p>在扫描的过程中，如果因为网络波动的原因，导致回流消息的时间被拉长，而我们上游在扫描的时候误认为没有下发成功，而实际上已经下发成功了，我们依旧发起了重试，那么就会导致重复下发。<br />为了避免这一现象发生，下游有必要去做一次去重。我们可以给每次下发的任务都冠以一个唯一id，然后用位图对当日的下发进行去重处理。<br />我们可以使用雪花算法去生成唯一id，也可以通过每次生成的业务id去拼接当前下发的秒数去生成唯一id，这个方案很多，不多赘述。</p><p><a name="94b65699"></a></p><h3 id="路由实例"><a href="#路由实例" class="headerlink" title="路由实例"></a><strong>路由实例</strong></h3><p>在经过上述流程之后，我们需要做的是，选择一个合适的实例进行触发，往往通过<strong>线程池，协程池</strong>进行rpc调度。<br />总结了市面上的开源中间件主要有以下几种路由算法的实现：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>轮询</td><td>依次遍历执行器列表</td></tr><tr><td>随机数</td><td>random函数实现</td></tr><tr><td>一致性哈希</td><td>通过2^32 ring (md5散列的方式计算hash值)，尽可能保证每轮触发都均匀落到每个执行器上。</td></tr><tr><td>LRU</td><td>最近最久未使用。</td></tr><tr><td>LFU</td><td>每个使用频率最低的执行器优先被淘汰。</td></tr><tr><td>心跳</td><td>遍历每个执行器，向每个执行器发起请求，如果哪个执行器最快发回心跳包，说明他最闲，那么就选择他。</td></tr></tbody></table><p>这些路由算法都是为了能让不同执行器的负载变得均衡，需要根据场景选择合适的路由算法。</p><p><a name="b165504a"></a></p><h3 id="优秀系统的设计"><a href="#优秀系统的设计" class="headerlink" title="优秀系统的设计"></a><strong>优秀系统的设计</strong></h3><p><a name="37c99b53"></a></p><h4 id="xxl-job的实现"><a href="#xxl-job的实现" class="headerlink" title="xxl-job的实现"></a><strong>xxl-job的实现</strong></h4><p>XXL-JOB是一款知名的分布式任务调度框架，它采用内存中的时间轮算法结合MySQL作为持久化存储来管理调度任务，其调度粒度精准至秒级。<br />以下是XXL-JOB的核心工作流程：<br />1.<strong>调度线程预读与更新</strong>：调度线程负责提前读取未来5秒内即将执行的任务，将这些任务载入内存中的时间轮，并同步更新它们的下一次触发时刻。<br />2.<strong>时间轮线程轮询执行：</strong>时间轮线程每隔一秒从等待状态激活为可运行状态。它会捕获当前时间的秒级信息，并在时间轮中定位到对应的任务。一旦找到，时间轮线程便会利用预先配置的线程池发起RPC调用，触发任务执行。<br />下面是简易版的伪代码(笔者凭借之前的印象写的，可能并不完整)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间轮 秒数为key,task列表为value</span></span><br><span class="line">Map&lt;Integer,List&lt;Task&gt;&gt; ringData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// rpc线程池</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">schedulerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="number">1.</span> 从数据库预读未来5s的任务</span><br><span class="line">        List&lt;Task&gt; tasks = mapper.loadTask(now() + <span class="number">5000</span>)  </span><br><span class="line">        <span class="keyword">for</span>(task in tasks)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> task.getTriggerTime();</span><br><span class="line">            <span class="comment">// 根据触发时间计算秒数。比如触发时间是 21：00：01 那么秒数就是 1</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">second</span> <span class="operator">=</span> time.calculateSecond();</span><br><span class="line">            ringData.put(task.getSecond(), task)</span><br><span class="line">            <span class="comment">// 更新下一次触发事件，运行状态等信息，</span></span><br><span class="line">            updateTask(task)</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">schedulerThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间轮线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">ringThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">       <span class="comment">//秒数对齐，整秒数激活为可运行状态</span></span><br><span class="line">       Thread.sleep(<span class="number">1000</span> - System.currentTimeMillis() % <span class="number">1000</span>);</span><br><span class="line">       <span class="comment">//获取苏醒时候的秒数</span></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">currentSecond</span> <span class="operator">=</span> now().getSecond();</span><br><span class="line">       List&lt;Task&gt; tasks = ringData.get(currentSecond);</span><br><span class="line">       <span class="comment">//放入线程池发起rpc调度</span></span><br><span class="line">       threadPool.trigger(tasks)</span><br><span class="line">       <span class="comment">// help gc</span></span><br><span class="line">       tasks.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">ringThread.start();</span><br></pre></td></tr></table></figure><p>这里的时间轮就是一个key为秒数，value为即将要执行的任务id列表。<br />时间轮分为单级时间轮和多级时间轮。xxl-job并没有像kafka那样采用多级时间轮，主要是因为设计理念的不同，他为了简化设计，并且单级时间轮已经满足大部分任务调度的需求。<br />优点：<br />1.<strong>高效检索与持久化</strong>：借助MySQL B+树的特性，搜索操作的时间复杂度降至O(logN)，同时提供数据的持久化存储，确保数据安全不易丢失。<br />2.<strong>高精度调度</strong>：通过将任务提前<strong>预读</strong>至内存，提升了任务调度的精度和响应速度。<br />3.<strong>生产者-消费者模型</strong>：调度线程与时间轮线程的协同工作构成了经典的生产者-消费者模型。时间轮作为任务缓冲区，有效实现流量削峰，减轻系统瞬时负载压力。<br />缺点：<br />1.<strong>调度器集群性能瓶颈</strong>：现有架构依赖调度器集群间的锁机制来执行任务，这可能导致单个调度器承受过大压力，限制了系统的并发处理能力（QPS）。在任务量激增时，难以通过水平扩展提升调度能力，从而可能导致部分任务延迟过高。<br />2.<strong>磁盘存储的性能局限</strong>：虽然MySQL提供了可靠的数据存储，但作为基于磁盘的数据库，在高并发场景下的性能可能不如内存型数据库如Redis。<br />总体而言，XXL-JOB采用内存结合MySQL的部署方式简单易行，无需额外引入中间件。这种设计在追求调度精度的同时牺牲了一定的水平扩展性。对于任务量适中的场景而言，它仍然是一个值得考虑的优秀调度框架选项。<br><a name="e52a38b0"></a></p><h4 id="腾讯视频push中台的实现"><a href="#腾讯视频push中台的实现" class="headerlink" title="腾讯视频push中台的实现"></a><strong>腾讯视频push中台的实现</strong></h4><p>腾讯视频push中台为了应对海量的并发，牺牲了调度的精度，以redis作为db，ZSet(跳表)作为底层数据结构来支持任务的范围查询。<br />主要流程：将任务id作为key，时间戳作为value进行任务的新增，利用Zrange 命令获取要触发的任务，并判断是否需要触发。而任务拉取任务依赖不同实例去抢分布式锁，然后执行。<br />优点：<br />1.基于redis，查询快，qps是mysql的好几倍，实现简单，易于维护。<br />2.redis的分布式锁性能优秀，加锁解锁快。<br />3.无需依赖其他中间件，成本小。<br />4.让搜素的时间复杂度降低到O(logN)，查询快，无需遍历额外数据。<br />缺点：精度无法保证。<br><a name="eacbc086"></a></p><h4 id="Redis的高精度版本实现"><a href="#Redis的高精度版本实现" class="headerlink" title="Redis的高精度版本实现"></a><strong>Redis的高精度版本实现</strong></h4><p><a name="0f9b4069"></a></p><h5 id="分片"><a href="#分片" class="headerlink" title="分片"></a><strong>分片</strong></h5><p>为了实现更高精度的Redis调度，我们需要确保跳表中的数据量保持在合理范围内。过多的数据可能导致内存占用过高、成本不足以及读写响应时间变长等问题(<strong>大Key问题</strong>)。因此，为了降低Redis访问的响应时间（即提高精度），我们对数据进行分片处理，使调度器每次只需扫描一个分片的数据。<br />如下图：<br /><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-30-%E9%AB%98%E6%80%A7%E8%83%BD%E8%B0%83%E5%BA%A6/img_2.png" alt="image.png"><br />我们可以把一天的数据分为多个分钟级别的数据，虽然搜索的时间复杂度仍为O(logN)，但由于N大大减小，搜索效率得到提高，响应速度更快。<br />然而，这仍然无法解决一个问题：如果某个实例通过抢锁方式获得某一分钟分片的扫描权限，但该分钟内的数据量仍然很大，可能会导致实例的线程数不足，无法实现并发处理。<br><a name="b6e85540"></a></p><h5 id="分桶"><a href="#分桶" class="headerlink" title="分桶"></a><strong>分桶</strong></h5><p>为了解决这个问题，我们可以采用分桶策略，将这一分钟的数据划分为多个bucket。<br />在集群模式的调度器下，每个实例竞争的是各个bucket的锁，获得锁后，只需扫描相应分桶的数据。这种方法可以实现每分钟级别的tasklist调度，多台机器可以同时扫描和下发，避免了单个实例线程不足的问题。<br />如下图：<br /><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-30-%E9%AB%98%E6%80%A7%E8%83%BD%E8%B0%83%E5%BA%A6/img_3.png" alt="image.png"><br />1<br />若即使分成三个桶，数据量仍然过大，我们可以引入一个决策服务来监控任务的延时情况。如果任务的延时率持续较高，可以根据实际情况<strong>动态调整分桶数量</strong>，从而更好地满足实际需求。</p><p><a name="25f9c7fa"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>本文详细探讨了调度模块在多种系统中的应用及其重要性，并深入分析了调度系统的通用流程，包括任务生成、任务存储、定时扫描和路由实例等关键步骤。<br />文章针对每个步骤的技术选型进行了探讨，并结合实际系统（如XXL-JOB和腾讯视频push中台）进行了案例分析。此外，还讨论了各种路由算法的实现及其适用场景。<br />总的来说，一个高性能的调度系统需要综合考虑任务生成策略、存储数据结构的选择、数据库选型、分布式锁的实现以及定时扫描的机制等多个方面。通过合理的技术选型和系统设计，可以实现高精度和高可用的调度目标。同时，根据具体的应用场景和需求，灵活调整调度策略和路由算法，以达到最佳的性能和效率平衡点。</p><h2 id="个人问题"><a href="#个人问题" class="headerlink" title="个人问题"></a>个人问题</h2><p>个人在读完这篇文章后有一个问题：<br />为什么下发任务走的是RPC而不是MQ？<br />我的理解是这样的：<br />MQ适合的是对消息时效性要求不高的场景。是用来削峰填谷的。消息存在Broker里，消费者可以慢慢消费。<br />但是消息推送系统不一样，它对时效性要求很高。必须保证用户在某个时间点能收到消息推送。扫描任务扫描出的是最近五分钟的推送任务。这些任务必须在短时间内推送到用户手机上。<br />不可能说存到MQ里让消费者慢慢消费。况且走MQ就涉及到了生产者，中间服务器，消费者三个角色，两次数据传输。RPC呢？只有生产者消费者两个角色，数据传输只有一次，在速度上天然就比MQ更快，消费者能更快消费消息。<br />但是缺少了中间服务器，就可能会导致消息积压。<a href="#2e5c6c42">定时扫描</a><br />消费者消费不过来生产者又发来了新的任务怎么办？<br />这就需要更改生产者的生产逻辑。控制扫描任务的时间间隔。<br />怎么控制呢？参考原文：</p><blockquote><p>因此，在确定扫描时间间隔时，应考虑以下两点：<br>1.<strong>对于精度要求不高且任务量较大的场景</strong>：可以适当延长扫描时间间隔，以确保在单次扫描周期内能够完成所有任务的处理下发。这样可以减轻系统负担，提高整体效率。<br>2.<strong>对于精度要求高同时任务量也很大的场景</strong>：除了优化RPC处理流程外，还可以考虑改进数据存储结构，将数据分片分桶处理。通过为每个数据分片分配独立的扫描实例，可以实现并行处理，从而在保证高精度的同时提升系统响应速度。<br>综上所述，合理的扫描时间间隔应当根据具体应用场景和系统需求进行细致调整，以达到最佳的性能和精度平衡点。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 任务调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap并发扩容</title>
      <link href="/2024/08/27/2024-08-27-concurrentHashMap%E5%B9%B6%E5%8F%91%E6%89%A9%E5%AE%B9/"/>
      <url>/2024/08/27/2024-08-27-concurrentHashMap%E5%B9%B6%E5%8F%91%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>更多细节见<a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html#_3-put">ConcurrentHashMap 源码分析</a></p></blockquote><p>JDK7和JDK8两个版本的扩容有点不一样。</p><h1 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h1><p>JDK7版本中，扩容是在持有锁时发生的。<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-27-concurrentHashMap/img_4.png"><br>35行的rehash是扩容函数。直到46行的finally代码块才释放锁。<br>拿到锁的线程执行put方法时会检查要不要扩容（已有元素个数 &#x2F; table数组的长度  &gt; 负载因子）。<br>因此只有一个线程可以执行扩容操作，不存在并发问题。<br>但是map扩容了总得让其它线程知道吧。具体是怎么知道的呢？<br>其实数组table是一个volatile变量，这就保证了可见性。<br>证据见JDK 8中源码778行。我没有装JDK 7,但JDK7里也肯定是一个volatile变量。<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-27-concurrentHashMap/img.png"></p><h1 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h1><p>JDK8版本中，扩容是在不持有锁时发生的。<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-27-concurrentHashMap/img_1.png"><br>倒数第三行的addCount是扩容的检查函数，可以清晰的看到，它不在syncronized代码块里。  </p><p>先看看add方法：<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-27-concurrentHashMap/img_2.png"><br><strong>扩容检查流程：</strong></p><ul><li>计算元素总量 size，若 CAS 冲突严重则放弃扩容。  </li><li>若 size 计算成功，有新元素加入，且检测到元素总量大于阈值 size &gt; sizeCtl。  <ul><li>如果检查到当前已有线程在进行扩容。  <ul><li>扩容已经接近完成或足够多的线程参与到扩容中了，当前线程直接返回。  </li><li>当前线程参与扩容。</li></ul></li><li>如果没有其他线程在进行扩容，则修改 sizeCtl 标识，进行扩容。</li></ul></li></ul><h2 id="扩容流程"><a href="#扩容流程" class="headerlink" title="扩容流程"></a>扩容流程</h2><p>上述流程只是扩容之前的准备，扩容的核心逻辑在 transfer() 方法中。  </p><h3 id="transfer-源码"><a href="#transfer-源码" class="headerlink" title="transfer() 源码"></a>transfer() 源码</h3><p>看源码之前，提前梳理一下扩容过程：  </p><ol><li>创建 nextTable，新容量是旧容量的 2 倍。  </li><li>将原 table 的所有桶逆序分配给多个线程，每个线程每次最小分配 16 个桶，防止资源竞争导致的效率下降。指定范围的桶可能分配给多个线程同时处理。  </li><li><strong>扩容时遇到空的桶，采用 CAS 设置为 ForwardingNode 节点，表示该桶扩容完成。</strong>  </li><li><strong>扩容时遇到 ForwardingNode 节点，表示该桶已扩容过了，直接跳过。</strong>  </li><li><strong>单个桶内元素的迁移是加锁的</strong>，将旧 table 的 i 位置上所有元素迁移到新表。  </li><li>最后将旧 table 的 i 位置设置为 ForwardingNode 节点。  </li><li>所有桶扩容完毕，将 table 指向 nextTable，设置 sizeCtl 为新容量 0.75 倍</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) <span class="comment">// 每核处理的桶的数目，最小为16</span></span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// MIN_TRANSFER_STRIDE写死了16，每个线程每次只分配16个桶</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>]; <span class="comment">// 构建nextTable，其容量为原来容量的两倍</span></span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n; <span class="comment">// 迁移总进度，值范围为[0,n]，表示从table的第n-1位开始处理直到第0位。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab); <span class="comment">// 扩容时的特殊节点，hash固定为-1，标明此节点正在进行迁移。扩容期间的元素查找要调用其find方法在nextTable中查找元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 当前线程是否需要继续寻找下一个可处理的节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab // 所有桶是否都已迁移完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123; <span class="comment">// 此循环的作用是 1.确定当前线程要迁移的桶的范围；2.通过更新i的值确定当前范围内下一个要处理的节点</span></span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing) <span class="comment">// 每次循环都检查结束条件：i自减没有超过下界，finishing标识为true时，跳出while循环</span></span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123; <span class="comment">// 迁移总进度&lt;=0，表示所有桶都已迁移完成</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                 <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    下面这段代码通过cas的方式确定自己负责的桶范围。</span></span><br><span class="line"><span class="comment">                    假如有多个线程都执行到了下面这行代码，</span></span><br><span class="line"><span class="comment">                    怎么保证只有一个线程可以cas成功？</span></span><br><span class="line"><span class="comment">                    或者说，32-16的桶范围只有一个线程可以拿到？</span></span><br><span class="line"><span class="comment">                    U是一个unsafe对象，可以直接操作内存</span></span><br><span class="line"><span class="comment">                    TRANSFERINDEX通过U这个unsafe对象获取了transferIndex的内存地址，</span></span><br><span class="line"><span class="comment">                    修改TRANSFERINDEX就等于直接修改transferIndex</span></span><br><span class="line"><span class="comment">                    而transferIndex是一个volatile变量</span></span><br><span class="line"><span class="comment">                    每个线程在TRANSFERINDEX=nextIndex时都会发出写屏障修改TRANSFERINDEX</span></span><br><span class="line"><span class="comment">                    但是CPU的总线仲裁机制能够保证：</span></span><br><span class="line"><span class="comment">                    只有一个线程可以发出写屏障更新TRANSFERINDEX(transferIndex)</span></span><br><span class="line"><span class="comment">                    并且向CPU总线发出广播，让其它核心（线程）的缓存块失效</span></span><br><span class="line"><span class="comment">                    等它们从主内存更新缓存块后，cas的条件已经不成立了。于是陷入自旋</span></span><br><span class="line"><span class="comment">                    自旋超时后，会返回false，执行后面的代码。</span></span><br><span class="line"><span class="comment">                    可能这时已经扩容完了没它事。</span></span><br><span class="line"><span class="comment">                    竞争失败后就相当于走了个过场。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123; <span class="comment">// CAS执行transferIndex=transferIndex-stride，即transferIndex减去已分配出去的桶，得到边界，这里为下界</span></span><br><span class="line">                bound = nextBound; <span class="comment">// 当前线程需要处理的桶下标的下界</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>; <span class="comment">// 当前线程需要处理的桶下标</span></span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123; <span class="comment">// 当前线程自己的活已经做完或所有线程的活都已做完</span></span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123; <span class="comment">// 已经完成所有节点复制了。所有线程已干完活，最后才走这里</span></span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                table = nextTab; <span class="comment">// table指向nextTable</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>); <span class="comment">// 设置sizeCtl为新容量0.75倍</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123; <span class="comment">// 当前线程已结束扩容，sizeCtl-1表示参与扩容线程数-1</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) <span class="comment">// 相等时说明没有线程在参与扩容了，置finishing=advance=true，为保险让i=n再检查一次</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>) <span class="comment">// 遍历到i位置为null，则放入ForwardingNode节点，标志该桶扩容完成。</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// f.hash == -1 表示遍历到了ForwardingNode节点，意味着该节点已经处理过了</span></span><br><span class="line">            advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 桶内元素迁移需要加锁</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 链表节点。非链表节点hash值小于0</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n; <span class="comment">// 根据 hash&amp;n 的结果，将所有结点分为两部分</span></span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n; <span class="comment">// 遍历链表的每个节点，依次计算 hash&amp;n</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln); <span class="comment">// hash&amp;n为0，索引位置不变，作低位链表</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn); <span class="comment">// hash&amp;n不为0，索引变成“原索引+oldCap”，作高位链表</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln); <span class="comment">// 低位链表放在i处</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn); <span class="comment">// 高位链表放在i+n处</span></span><br><span class="line">                        setTabAt(tab, i, fwd); <span class="comment">// 在原table的i位置设置ForwardingNode节点，以提示该桶扩容完成</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些并发问题："><a href="#一些并发问题：" class="headerlink" title="一些并发问题："></a>一些并发问题：</h2><h3 id="怎么保证一个桶范围和一个线程一一对应？"><a href="#怎么保证一个桶范围和一个线程一一对应？" class="headerlink" title="怎么保证一个桶范围和一个线程一一对应？"></a>怎么保证一个桶范围和一个线程一一对应？</h3><p>有一个全局的volatile变量transferIndex。它记录最新的哈希桶迁移索引。<br>每个线程通过cas的方式获取自己的哈希桶范围。如果有多个线程预期的哈希桶范围都一样，<br>那么因为cas的原因，只有一个线程可以拥有这段范围并且更新transferIndex的值。其它线程自旋等待，超时才进入下一步<br>具体见下面这段解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123; <span class="comment">// 此循环的作用是 1.确定当前线程要迁移的桶的范围；2.通过更新i的值确定当前范围内下一个要处理的节点</span></span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing) <span class="comment">// 每次循环都检查结束条件：i自减没有超过下界，finishing标识为true时，跳出while循环</span></span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123; <span class="comment">// 迁移总进度&lt;=0，表示所有桶都已迁移完成</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    下面这段代码通过cas的方式确定自己负责的桶范围。</span></span><br><span class="line"><span class="comment">                    假如有多个线程都执行到了下面这行代码，</span></span><br><span class="line"><span class="comment">                    怎么保证只有一个线程可以cas成功？或者说，32-16的桶范围只有一个线程可以拿到？</span></span><br><span class="line"><span class="comment">                    U是一个unsafe对象，可以直接操作内存</span></span><br><span class="line"><span class="comment">                    TRANSFERINDEX通过U这个unsafe对象获取了transferIndex的内存地址，</span></span><br><span class="line"><span class="comment">                    修改TRANSFERINDEX就等于直接修改transferIndex</span></span><br><span class="line"><span class="comment">                    而transferIndex是一个volatile变量</span></span><br><span class="line"><span class="comment">                    每个线程在TRANSFERINDEX = nextIndex时都会请求发出写屏障修改TRANSFERINDEX</span></span><br><span class="line"><span class="comment">                    但是CPU的总线仲裁机制能够保证：</span></span><br><span class="line"><span class="comment">                    只有一个线程可以发出写屏障更新TRANSFERINDEX(transferIndex)</span></span><br><span class="line"><span class="comment">                    并且向CPU总线发出广播，让其它线程的缓存块失效</span></span><br><span class="line"><span class="comment">                    等它们从主内存更新缓存块后，cas的条件已经不成立了。于是陷入自旋</span></span><br><span class="line"><span class="comment">                    自旋超时后，会返回false，执行后面的代码。</span></span><br><span class="line"><span class="comment">                    可能这时已经扩容完了没它事。</span></span><br><span class="line"><span class="comment">                    竞争失败后就相当于走了个过场。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123; <span class="comment">// CAS执行transferIndex=transferIndex-stride，即transferIndex减去已分配出去的桶，得到边界，这里为下界</span></span><br><span class="line">                bound = nextBound; <span class="comment">// 当前线程需要处理的桶下标的下界</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>; <span class="comment">// 当前线程需要处理的桶下标</span></span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="只用CAS操作也能做到可见性，为什么transferIndex还要用volatile修饰？"><a href="#只用CAS操作也能做到可见性，为什么transferIndex还要用volatile修饰？" class="headerlink" title="只用CAS操作也能做到可见性，为什么transferIndex还要用volatile修饰？"></a>只用CAS操作也能做到可见性，为什么transferIndex还要用volatile修饰？</h3><p>CAS的可见性很局限，对于CAS操作里的变量，只有在执行CAS操作时才能得知它在主内存里的最新值，不通过CAS去访问变量得到的还是线程本地内存里的旧值。<br>所以还需要volatile去保证任意时刻的可见性</p><p>TRANSFERINDEX在源码的6357行通过unsafe对象获取了transferIndex的内存地址<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-27-concurrentHashMap/img_3.png"> </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap线程不安全举例</title>
      <link href="/2024/08/21/2024-08-21-HashMap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E4%B8%BE%E4%BE%8B/"/>
      <url>/2024/08/21/2024-08-21-HashMap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E4%B8%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h2><p>这个问题是JDK7中put方法是头插法导致的<br>JDK8及后续版本已经改成尾插法修复此问题<br><a href="https://www.yuque.com/u41117719/xd1qgc/heysdsfv6flmxuag">哈希表成环</a></p><h2 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h2><p>共有两种数据丢失的位置：</p><ol><li><p>table[i]为null时的哈希桶头部<br>有两个线程：B插入（2，”two”）,A插入（1，”one”）。<br>假如table[15]这个哈希桶是null，A和B并发执行中都知道15是null<br>B先执行，tab[15] &#x3D; new node(hash, 2,”two”, null)<br>A后执行，tab[15] &#x3D; new node(hash, 1,”one”, null)<br>正常来说应该是<br>  tab[15] &#x3D; new node(hash, 2,”two”, null)<br>  tab[15].next &#x3D; new node(hash, 1, “one”, null)<br>  但实际是<br>  tab[15] &#x3D; new node(hash, 1, “one”, null)<br>  tab[15].next &#x3D; null<br>但是A把B put 的数据覆盖了。get(2)是get不到的</p></li><li><p>table[i]不为null时的哈希桶尾部<br>看下面源码就知道其实和前一种情况是一样的</p></li></ol><p>结合源码看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) <span class="comment">// A和B都运行到这里，但是A时间片用尽，B先执行</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                table[i]为null时数据丢失问题</span></span><br><span class="line"><span class="comment">                B先执行，tab[15] = new node(hash, 2,&quot;two&quot;, null);</span></span><br><span class="line"><span class="comment">                A后执行，tab[15] = new node(hash, 1,&quot;one&quot;, null);</span></span><br><span class="line"><span class="comment">                完美把B覆盖了</span></span><br><span class="line"><span class="comment">                这里的并发问题是加锁 &amp;&amp; 加判断解决的</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>); </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//下面这行也会出现并发问题，这个并发问题加锁直接解决了</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                         <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            table[i]不为null时数据丢失问题</span></span><br><span class="line"><span class="comment">                            B先执行，p.next = new node(hash, 2,&quot;two&quot;, null);</span></span><br><span class="line"><span class="comment">                            A后执行，p.next = new node(hash, 1,&quot;one&quot;, null);</span></span><br><span class="line"><span class="comment">                            完美把B覆盖了</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>如何解决？<br>加锁解决链表尾部覆盖问题 &amp;&amp; cas解决链表头部覆盖问题。<br>看看ConcurrentHashMap的源码具体怎么做的（JDK21）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 整个表都为null</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 解决table[i]为null时头部数据丢失的问题</span></span><br><span class="line"><span class="comment">                 要插入的桶为null，就通过cas插入</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 这个桶正在迁移，执行helpTransfer帮助其迁移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">                </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                onlyIfAbsent是boolean类型。true表示仅在键不存在时put，否则不put</span></span><br><span class="line"><span class="comment">                fh == hash表示是否出现哈希碰撞</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                (fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk)) </span></span><br><span class="line"><span class="comment">                检查当前节点的键（fk）是否与插入元素的键相同。如果键相同，则表示当前桶中已经存在这个键。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                也就是说，如果</span></span><br><span class="line"><span class="comment">                只在不存在key重复时才put</span></span><br><span class="line"><span class="comment">                并且 出现了哈希碰撞 </span></span><br><span class="line"><span class="comment">                并且 哈希桶的头节点的key和待插入元素的key相同</span></span><br><span class="line"><span class="comment">                并且 头节点的value不是null</span></span><br><span class="line"><span class="comment">                那么就返回头节点，不插入</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">                     &amp;&amp; fh == hash</span><br><span class="line">                     &amp;&amp; ((fk = f.key) == key || (fk != <span class="literal">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                     &amp;&amp; (fv = f.val) != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> fv;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                上面的条件都不满足，要在链表尾部插入</span></span><br><span class="line"><span class="comment">                那就</span></span><br><span class="line"><span class="comment">                先锁住哈希桶头节点f</span></span><br><span class="line"><span class="comment">                顺着头节点往下遍历</span></span><br><span class="line"><span class="comment">                如果出现了key相同的节点并且onlyIfAbsent = false（已经存在key也插入，覆盖掉）</span></span><br><span class="line"><span class="comment">                遍历完了还没有出现key相同的节点，就新建一个节点加到链表尾部</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                防止并发问题的关键代码是哪一行呢？</span></span><br><span class="line"><span class="comment">                synchronized (f) &#123;</span></span><br><span class="line"><span class="comment">                    if (tabAt(tab, i) == f)  是加锁后的这一行</span></span><br><span class="line"><span class="comment">                还是以上文的AB两个线程举例</span></span><br><span class="line"><span class="comment">                现在tabAt(tab, i) != null， f = tabAt(tab, i) != null,都去链表尾部插入</span></span><br><span class="line"><span class="comment">                A和B都执行到了synchronized这里，竞争锁</span></span><br><span class="line"><span class="comment">                B竞争成功，此时语句if (tabAt(tab, i) == f) 成立，开始在链表尾部插入</span></span><br><span class="line"><span class="comment">                然后B释放锁，A得到锁</span></span><br><span class="line"><span class="comment">                突然A线程由运行态变成就绪态</span></span><br><span class="line"><span class="comment">                此时有个C线程执行remove方法，把f给从链表中移走了，即f.next = 新的链表头节点 = tabAt(tab, i)，然后f.next = null</span></span><br><span class="line"><span class="comment">                A执行语句：</span></span><br><span class="line"><span class="comment">                if (tabAt(tab, i) == f)</span></span><br><span class="line"><span class="comment">                发现结果为false。tabAt(tab, i)不是f，是原先链表的第二个节点</span></span><br><span class="line"><span class="comment">                f已经是一个即将被GC的垃圾对象，插在它后面只会等着一起被GC</span></span><br><span class="line"><span class="comment">                于是A跳过本轮循环，在下一轮循环中继续插入</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                    插入链表尾部时</span></span><br><span class="line"><span class="comment">                                    下面这行不可能出现并发问题</span></span><br><span class="line"><span class="comment">                                    由于锁的原因</span></span><br><span class="line"><span class="comment">                                    后执行的A线程执行到此处时一定已经遍历过了B线程put的节点</span></span><br><span class="line"><span class="comment">                                    不会再出现key不同也覆盖的情况</span></span><br><span class="line"><span class="comment">                                */</span></span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>顺便吐槽一下源码的代码风格，在判断语句里给变量赋值，给我整懵了。<br>直接看最后一个else的时候发现变量怎么定义了没赋值？仔细一看原来是在判断语句里赋值。<br>太恶心了，就不能在定义时就赋值吗？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka事务化发送消息</title>
      <link href="/2024/08/18/2024-08-18-Kafka%E4%BA%8B%E5%8A%A1%E5%8C%96%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/"/>
      <url>/2024/08/18/2024-08-18-Kafka%E4%BA%8B%E5%8A%A1%E5%8C%96%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Kafka的事务由Broker的事务协调器负责，也有ACID特性。但一致性由于CAP限制只保证最终一致性且隔离级别只有读未提交和读已提交</p></blockquote><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line">       <span class="comment">// 3 初始化事务</span></span><br><span class="line">       producer.initTransactions();</span><br><span class="line">       <span class="comment">// 4 标识事务开始</span></span><br><span class="line">       producer.beginTransaction();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 5 构建待发送的消息</span></span><br><span class="line">           ProducerRecord&lt;String, String&gt; record = <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i ++) &#123;</span><br><span class="line">               record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topicName, msg);</span><br><span class="line">               <span class="comment">// 6 发送消息</span></span><br><span class="line">               producer.send(record);</span><br><span class="line">               <span class="comment">// 省略一些其他逻辑</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 7 commit事务</span></span><br><span class="line">           producer.commitTransaction();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ProducerFencedException e1) &#123;</span><br><span class="line">           e1.printStackTrace();</span><br><span class="line">           producer.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (KafkaException e2) &#123;</span><br><span class="line">           e2.printStackTrace();</span><br><span class="line">           producer.abortTransaction();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 8 关闭生产者实例</span></span><br><span class="line">       producer.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="事务执行原理"><a href="#事务执行原理" class="headerlink" title="事务执行原理"></a>事务执行原理</h2><h3 id="初始化事务"><a href="#初始化事务" class="headerlink" title="初始化事务"></a>初始化事务</h3><ol><li>首先，需要在生产者客户端配置 producerProps.put(“transactional.id”, “ShiWuID”);，设置 事务id，可以让程序重启之后被识别为同一个事务生产者。</li><li>当执行<code>producer.initTransactions()</code>后，生产者会与某个Broker端的事务协调器产生联系。具体怎么确定是哪个Broker呢？<ol><li>在 Kafka 中有个特殊的事务 topic，名称为 __transaction_state ，负责持久化事务消息。该 topic 默认有 50 个Partition，每个Parition负责一部分事务。</li><li>事务划分规则是当生产者向 bootstrap.servers 中任何一个地址发送请求时，该 Broker 会先计算 事务id 的哈希值，然后将该哈希值 % 50 得到一个计算结果，该结果就是 __transaction_state 的某个Partition</li><li>由该分区的 Leader 副本所在的 Broker 节点就是该生产者所属的事务协调器。随后就会向生产者反馈事务协调器的地址</li></ol></li></ol><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>生产者在每次发送消息的请求中都会包含 PID、Epoch 和 事务id 以及其他字段。而生产者在每次调用 producer.send() 方法时，需要循环执行以下两个步骤：</p><ol><li>AddPartitionsToTxnRequest：将本次发送请求涉及到的 TopicPartition 添加到事务协调器对应的 __transaction_state 的某个分区中，这样当事务提交之后，事务协调器会将 __transaction_state 分区中 TopicPartition 的状态标记为已提交(Commit)或放弃(Abort)。</li><li>ProduceRequest：对于每个 PID、Epoch 和 事务id 组合，生产者都会维护一个序列号，该序列号从 0 开始，每条消息的序列号都会单调递增。Broker也会维护每个 PID、Epoch 和 Transactional ID 组合的序列号，如果当前序列号不比前一个序列号大 1，就会拒绝请求。</li></ol><h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><p>根据事务的原子性，要么全部成功，要么全部回滚。生产者就会向事务协调器调用 commitTransaction() 或 abortTransaction()，从而完成事务。</p><h3 id="消费者消费"><a href="#消费者消费" class="headerlink" title="消费者消费"></a>消费者消费</h3><p>以下两次调用是消费者端的事务一致性功能</p><ol><li>AddOffsetsToTxnRequest：消费者会通过 AddOffsetsToTxnRequest 将 Consumer Group ID 信息传递给事务协调器，事务协调器从中提炼出消费者订阅的 TopicPartition，并将其记录在事务日志中。</li><li>TxnOffsetCommitRequest：当消费者成功消费完数据之后，会在内部通过调用 TxnOffsetCommitRequest，将该 TopicPartition 和 消息 offset 的写到 __consumer_offsets 主题中，表示数据已经成功消费。注意，在生产者发送消息的事务完成之前，消费者是无法看到这些消息的 offset 的。即当消费者将隔离级别设置为isolation.level &#x3D; read_committed时，消费者看不见未完成状态的消息，只能看见事务已提交状态的消息。</li></ol><h2 id="事务协调器解决数据不一致问题"><a href="#事务协调器解决数据不一致问题" class="headerlink" title="事务协调器解决数据不一致问题"></a>事务协调器解决数据不一致问题</h2><p>先举个例子：生产者向topic1发送两条消息。下游消费者等待事务提交后消费这两条消息<br>整体执行流程如下：</p><ol><li>生产者开启事务，锁定事务协调器</li><li>向topic1的Partition1发送两条消息，同时向事务协调器发送topic1，事务协调器记录topic1的Partition1参与了该事务。事务协调器还会向__transaction_state这个topic里写入一条控制消息，记录这条消息所属的事务id。</li><li>事务协调器维护topic1的Partition1的LSO（log stable offset）。一个Partition中存了多个事务消息，也存储了很多非事务的普通消息，而LSO为第一个正在进行中的事务消息的offset。<img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-18-Kafka/img_1.png" alt="image.png"></li></ol><p>如上图:<br>a： 已经无效的事务<br>b： 已经提交的事务<br>c： 正在进行中的事务（不确定最终是取消还是提交）<br>d： 普通消息，非事务消息<br>在LSO之后的位置(上图LSO右边)的消息是不可以被隔离级别为读已提交的消费者消费的</p><ol start="4"><li>生产者提交事务，向事务协调器发送信号，事务协调器修改事务状态的同时，通知本次事务涉及到的所有Partition更新LSO。</li><li>生产者主动回滚事务或触发超时，事务协调器主动回滚事务。事务协调器通知各个partiton更新LSO并将本次事务产生的消息作废。</li></ol><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-18-Kafka/img.png" alt="image.png"></p><p>Kafka事务的整体流程是分布式事务里标准的两阶段提交<br><a href="https://www.yuque.com/u41117719/xd1qgc/rs1c36guisudkgm8">分布式事务</a></p><h2 id="跨会话和跨-Partition-的幂等性"><a href="#跨会话和跨-Partition-的幂等性" class="headerlink" title="跨会话和跨 Partition 的幂等性"></a>跨会话和跨 Partition 的幂等性</h2><ul><li>跨会话幂等性：</li></ul><p>Kafka 的事务机制保证了即使在生产者会话之间切换，基于相同事务 ID 的操作仍然保持幂等性。如果生产者崩溃并重启，只要事务 ID 是相同的，Kafka 会确保不会重复处理同一事务的消息。</p><ul><li>跨 Partition 幂等性：</li></ul><p>Kafka 的事务机制允许生产者在多个 Topic 和分区中发送消息，并通过事务 ID 维护幂等性。即使消息分布在多个分区中，Kafka 会确保所有相关的消息在事务提交前不会被重复写入或丢失。</p><h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><ol><li><strong>问题1:</strong> 上图3.1向<code>__transaction_state</code>主题写完事务状态后，便给Producer回应说事务提交成功，假如说3.2执行过程中被hang住了，在Producer看来，既然事务已经提交成功，为什么还是读不到对应消息呢？<ol><li>的确是这样，这里成功指的是Coordinator收到了消息，并且成功修改了事务状态。因此<strong>返回成功的语义指的是一阶段提交成功</strong>，因为后续向各个Partition发送写marker的会无限重试，直至成功</li></ol></li><li><strong>问题2:</strong> 上图3.2中向多个Broker发送marker消息，如果Broker1、Broker2均写入成功了，但是Broker3因为网络抖动，Coordinator还在重试，那么此时Broker1、Broker2上的消息对Consumer来说已经可见了，但是Broker3上的消息还是看不到，这不就不符合事务语义了吗？<ol><li>事实确实如此，所以kafka的事务不能保证强一致性，并不是说kafka做的不够完美，而是这种分布式事务统一存在类似的问题，CAP铁律限制，这里只能做到最终一致性了。不过对于常规的场景这里已经够用了，Coordinator会不遗余力的重试，直至成功</li></ol></li><li><strong>问题3</strong>：LSO之前有3条消息，2个a（事务取消），1个b（事务提交），consumer读到这3条消息后怎么处理呢？无非就是以下两种处理逻辑。<ol><li>暂存在consumer端，直至读取到事务最终状态，再来判断是吐给业务端（事务成功），还是消息扔掉（事务取消）<ol><li>这样设计是没有问题的，可以保证消息的准确性，但是如果某个事务提交的数据量巨大（事务最长超时时间可达15分钟），这样势必造成consumer端内存吃紧，甚至OOM</li></ol></li><li>实时判断当前消息是该成功消费还是被扔掉<ol><li>能够实时判断肯定是非常理想的结果，可是如何实时判断呢？难道每次消费时都要再向broker发送请求获取消息的状态吗？</li></ol></li><li>Kafka具体采用哪种策略？<br>实际上Partition依托于__transaction_state主题里的控制消息，是可以得知消息状态的。Partiton 会根据 <code>LSO</code> 和事务日志的记录，只返回已提交的消息。消费者不需要查询或额外判断消息的状态 。</li></ol></li></ol><blockquote><p><a href="https://www.cnblogs.com/xijiu/p/16917741.html">Kafka事务「原理剖析」 - 昔久 - 博客园</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
          <category> 生产者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka发送消息的三种模式</title>
      <link href="/2024/08/18/2024-08-18-Kafka%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/08/18/2024-08-18-Kafka%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>省流：推荐使用带回调方法的异步发送</p></blockquote><h3 id="发后即忘"><a href="#发后即忘" class="headerlink" title="发后即忘"></a>发后即忘</h3><p>这种模式只管往broker里发数据，但是broker收没收到它不管。<br>通常情况下，这种发后即忘(fire-and-forget)的方式并不会出现问题，但也有意外情况：</p><ol><li><p>遇到可重试异常，如果发送消息到broker时抛出异常，且是可重试异常，就会去重试执行方法。org.apache.kafka.clients.producer.internals.Sender类中有如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canRetry</span><span class="params">(ProducerBatch batch, ProduceResponse.PartitionResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> batch.attempts() &lt; <span class="built_in">this</span>.retries &amp;&amp;</span><br><span class="line">            ((response.error.exception() <span class="keyword">instanceof</span> RetriableException) ||</span><br><span class="line">                    (transactionManager != <span class="literal">null</span> &amp;&amp; transactionManager.canRetry(response, batch)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许重试需要满足两个条件：</p></li><li><p>重试次数少于参数retries指定的值；</p></li><li><p>异常是RetriableException类型或者TransactionManager允许重试；</p></li></ol><h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><p>严格上来说，Kafka并没有同步发送机制。因为发送消息的send方法本身是异步的。<br>但是Kafka也有提供一些机制让我们做到同步发送。<br>具体怎么做到同步发送呢？</p><ul><li>send方法是有返回值的，返回值是Future类型，这是一个接口，可以提供异步的执行结果。我们可以使用Future的get方法去等待异步结束。这样就把异步改成了同步。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// RecordMetadata包含了成功发送到 Kafka Broker 的消息的元数据信息</span></span><br><span class="line">        Future&lt;RecordMetadata&gt; future = producer.send(record);</span><br><span class="line">        <span class="type">RecordMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Send Record(key=%s value=%s) &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;meta(Partition=%d, offset=%d) \n&quot;</span>,</span><br><span class="line">                record.key(), record.value(),</span><br><span class="line">                metadata.partition(), metadata.offset());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>如果遇到可重试异常，在超出最大重试次数之前如果能解决，我们的代码就不会捕获到异常，否则就会爆出异常需要捕获</li><li>如果是不可重试异常，是肯定要做异常捕获的。做好异常捕获记录详细日志信息，日后排查问题也方便</li></ul><p>同步发送的可靠性比较高，如果发生异常，可以捕获并处理异常；并不会像 “发后即忘” 的方式直接造成消息丢失。但是，<strong>同步发送的方式性能会比较差，需要阻塞等待一条消息发送成功之后才会发送下一条消息。</strong>kafka的批消息发送也就成摆设了。</p><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">producer.send(record, <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (metadata != <span class="literal">null</span> ) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;Send Record(key=%s value=%s) &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;meta(Partition=%d, offset=%d) \n&quot;</span>,</span><br><span class="line">                        record.key(), record.value(),</span><br><span class="line">                        metadata.partition(), metadata.offset());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>异步发送消息，比前两种方法多了一个回调函数的参数<br>不需要 try&#x2F;catch，因为异常会在回调函数中处理。<br>回调方法中的 onCompletion() 方法中的两个参数是互斥的。消息发送成功时，metadata 不为 null 而 exception 为 null，反之则反之。<br>回调方法的真正优势在于发送数据失败时，可以在数据发送失败时采取一些措施，如抛出异常、记录错误或将失败的数据写入到其他地方进行分析。很显然，<strong>使用带回调函数的异步发送方式既高效、又优雅</strong>，通常在生产环境中都建议使用这种方式发送消息。</p><p>:::warning<br>注意：回调函数是在生产者的主线程中执行的。必须要确保回调方法的执行速度足够快，<strong>绝对不能在回调方法中产生阻塞</strong>，否则会减慢生产者的运行速度。<br>:::</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
          <category> 生产者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka路由策略</title>
      <link href="/2024/08/18/2024-08-18-Kafka%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/"/>
      <url>/2024/08/18/2024-08-18-Kafka%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>生产者的路由策略决定了消息应该写入哪个分区。选择合适的路由策略可以优化生产者的性能和负载均衡 。</p></blockquote><h2 id="粘性路由策略"><a href="#粘性路由策略" class="headerlink" title="粘性路由策略"></a>粘性路由策略</h2><ul><li>粘性路由策略尝试将一段时间内的消息发送到相同的分区。这个策略在生产者启动时选择一个分区，并在接下来的时间里尽量将所有消息发送到这个分区。只有在当前分区达到一定条件（如大小或数量限制）时，生产者才会切换到其他分区。</li><li><strong>优点</strong>：<ul><li><strong>减少分区切换</strong>：减少了生产者频繁切换分区的次数，从而提高了写入效率。</li><li><strong>提高吞吐量</strong>：集中写入同一个分区可以提高磁盘的写入性能，特别是在高负载场景下。</li><li><strong>改善负载均衡</strong>：粘性路由可以在时间范围内平衡分区负载，避免短时间内的负载不均。</li><li><strong>适用场景</strong>：适合需要高吞吐量和较少分区切换的场景，如大批量消息写入和高性能的数据写入场景。</li></ul></li></ul><h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p> 默认的分区路由策略。生产者将消息均匀地分配到 Topic 的所有分区中。每个消息会被依次发送到不同的分区，以实现负载均衡。  </p><ul><li><strong>优点</strong>：简单易用，能够均匀地分配消息负载。</li><li><strong>适用场景</strong>：适合消息负载比较均匀的场景。</li></ul><h2 id="基于键的路由"><a href="#基于键的路由" class="headerlink" title="基于键的路由"></a>基于键的路由</h2><p> 生产者根据消息的key的哈希值来决定分区。相同的键将始终路由到同一个分区。  这个路由需要我们在发送消息时指定key。send方法有一个重载版本可以传入key。</p><ul><li><strong>优点</strong>：能够确保同一类型的消息（相同键）始终发送到同一个分区，有利于顺序消费和数据局部性。</li><li><strong>适用场景</strong>：需要确保相关数据在同一分区的场景，例如用户会话数据或交易记录。</li></ul><p><strong>如果我们执行send方法时指定了key，不管配置了什么路由都会选择基于键的路由。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
          <category> 生产者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka如何保证消息不重复</title>
      <link href="/2024/08/18/2024-08-18-Kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E9%87%8D%E5%A4%8D/"/>
      <url>/2024/08/18/2024-08-18-Kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E9%87%8D%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Kafka支持幂等操作，保证了消息不重复，不丢失。从Kafka3.0版本开始默认开启幂等。<br>开启幂等需要配置消息发送的重试次数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启生产者幂等</span></span><br><span class="line">props.setProperty(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, <span class="string">&quot;true&quot;</span>); </span><br><span class="line">props.setProperty(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;all&quot;</span>); </span><br><span class="line"><span class="comment">// 配置重试次数</span></span><br><span class="line">props.setProperty(ProducerConfig.RETRIES_CONFIG, Integer.toString(Integer.MAX_VALUE)); </span><br><span class="line"><span class="comment">// 如果 Kafka 版本 &gt;= 2.0，可配置为5；否则配置成 1</span></span><br><span class="line">props.setProperty(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, <span class="string">&quot;5&quot;</span>); </span><br></pre></td></tr></table></figure><h2 id="为什么要设置发送消息的重试次数"><a href="#为什么要设置发送消息的重试次数" class="headerlink" title="为什么要设置发送消息的重试次数"></a>为什么要设置发送消息的重试次数</h2><p>当生产者向 Broker 端发送消息失败时，Broker 端会向生产者端返回错误码。因此我们需要重新发送该消息。这是尽量避免消息丢失。但是会有这样一种情况：<br>第一次发送消息时，虽然 Broker 已经收到消息了，但由于网络抖动等原因导致 Broker 向生产者反馈的 ack 失败。因此，生产者会重新发送这批消息，最终导致消息重复。<br>但还是要开启重试机制。重复的问题留给幂等性解决。</p><h2 id="幂等，如何做到？"><a href="#幂等，如何做到？" class="headerlink" title="幂等，如何做到？"></a>幂等，如何做到？</h2><h3 id="做到不重复"><a href="#做到不重复" class="headerlink" title="做到不重复"></a>做到不重复</h3><p>要做到幂等性，要解决下面的问题：</p><ol><li>Broker 端能够鉴别一条数据到底是不是重复的数据？最常用的手段是通过 唯一键&#x2F;唯一id 来判断，因此需要在 Broker 端缓存已经处理的唯一键记录，这样才能判断出新发送过来的数据是否重复。</li><li>唯一键应该选择什么粒度？对于分布式系统来说，肯定不建议使用全局唯一键。Kafka 在这方面的考虑是在分区的维度上面设计唯一键，让每个分区的 Leader 判断数据是否重复。</li><li>将唯一键设计到分区粒度是否有问题？有可能有多个生产者同时向一个 Partition 中写入数据，各个生产者都是独立的个体，他们之间的通信比较困难。因此，选择设计的唯一键是 Producer + TopicPartition 维度。</li><li>如何保证消息的顺序性？生产者在发送信息时会同时发送一个序列号，序列号以 TopicPartition 为基础，从 0 开始，并随着每条信息的产生而递增。在 Broker 端通过序列号是否连续来判断消息是否是顺序发送。</li></ol><p>出于对以上内存的考虑，Kafka 要做到幂等性，就要做到以下几个方面：</p><h4 id="Broker角度"><a href="#Broker角度" class="headerlink" title="Broker角度"></a>Broker角度</h4><ol><li><strong>PID</strong>（Producer ID）：给每个生产者都指定的生产者 ID（PID）。</li><li><strong>Sequence Number</strong>：生产者在发送信息时会发送一个序列号，序列号以 TopicPartition 为基础，从 0 开始，并随着每条信息的产生而递增。Broker 会存储每个生产者为给定的 TopicPartition 发送的序列号，并据此判断该消息是否是：</li></ol><ul><li>新消息：Broker 新收到的消息的序列号刚好比给定生产者在本地存储的序列号大 1。</li><li>重复消息：Broker 新收到的消息的序列号小于等于给定生产者保存的最大序列号。</li><li>失序：Broker 新收到的消息序列号 - 本地最大序列号的差值大于 1，这意味着有些消息丢失了。</li></ul><h4 id="Producer角度"><a href="#Producer角度" class="headerlink" title="Producer角度"></a>Producer角度</h4><p>上面是从服务器角度考虑的幂等性实现。但如果我们能在消息发出去之前就判断出这条消息是重复的岂不更好？<br>Kafka的消息是批发送的，批消息叫做ProducerBatch，在一个ProducerBatch中的消息都是要发往同一个Partition的。<strong>如果一条消息重复发送那么其所属的ProducerBatch一定也重复发送了。</strong><br>每当有新的 ProducerBatch 被添加到 RecordAccumulator 时，<strong>就会有新的元数据 batchMetadata 被添加到batchMetadata队列中（该队列最大为5）</strong>，一个batchMetadata 对应一个ProducerBatch。而 batchMetadata 中主要包括lastSeq、lastOffset、offsetDelta 和 timestamp 等元数据。</p><ol><li>lastSeq：序列号是每条添加到 ProducerBatch 的编号，而 lastSeq 记录的是每个 ProducerBatch 的最后一条消息的序列号。</li><li>lastOffset：每个 ProducerBatch 中的最后一条消息的 offset。</li><li>offsetDelta ：每个 ProducerBatch 中，最后一条消息和第一条消息的 offset 差值。lastSeq - offsetDelta 可以得到第一条消息的 seq，lastOffset - offsetDelta 可以得到第一条消息的 offset。</li><li>timestamp：每个 ProducerBatch 最后一条消息的添加时间。</li></ol><p>在Producer内部有专门的方法校验ProducerBatch是否有重复消息：</p><ul><li>遍历 batchMetadata队列中的元数据，如果新发送的 ProducerBatch 的 firstSeq 和 lastSeq 都和 batchMetadata队列中缓存的某个 batchMetadata 相同，说明是重复批次。</li></ul><p>简单说就是：<br><strong>Producer维护了发往某个Partition的最近五个批次的元数据。里面保存了每一个批次的最新和最旧序列号。如果现在准备发送的批消息的最新最旧序列号和最近五个批消息的最新最近系列号重合了，说明是重复消息。不予发送。</strong><br><strong>为什么是最近五个？因为源代码里写死了。</strong></p><h3 id="做到不乱序"><a href="#做到不乱序" class="headerlink" title="做到不乱序"></a>做到不乱序</h3><p>存储ProducerBatch的是一个队列。假如现在情况如下：</p><p>【|  |  |  |  |  |  |  |  |  |】                       &lt;— 1 2 3 4 5 6 7 8 9</p><p>顺序发送数据包123，456，789。但是由于网络链路的原因，123先到，789次之，造成了乱序</p><p>【| 1 | 2 | 3 | 7 | 8 | 9 |  |  |  |】 4 5 6   &lt;— Empty Queue</p><p>如果不开启幂等性，Broker不管任何顺序都是接收不误的。一旦开启了幂等性，Broker就会拒接接收789数据包。将789退还给双端队列。</p><p>【| 1 | 2 | 3 |  |  |  |  |  |  |】 4 5 6         &lt;—                  7 8 9</p><p>接收456，再接收789</p><p>【| 1 | 2 | 3 | 4 | 5 | 6 |  |  |  |】            &lt;—                  7 8 9</p><p>这样就解决了乱序问题了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样实现的幂等还是有缺陷的：</p><ol><li>只能保证 Producer 在单个会话内消息的不丟不重不乱，如果 Producer 出现意外宕机再重启是无法保证的（由于在幂等性的场景下，无法获取 Producer 宕机之前的状态信息比如PID，PID每次都是不一样的。因此是无法做到跨会话级别的不丢不重不乱）;</li><li>幂等性不能跨多个 TopicPartition，只能保证 Producer 在单个 TopicPartition 内的幂等性，当涉及多个 TopicPartition 时，这些状态信息并没有同步。</li></ol><p><strong>如果需要实现跨会话、跨多个 Topic-Partition 的幂等性，需要使用 Kafka 的事务性来实现。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
          <category> 生产者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas实战-排查死锁</title>
      <link href="/2024/08/18/2024-08-18-arthas%E5%AE%9E%E6%88%98%EF%BC%9A%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5/"/>
      <url>/2024/08/18/2024-08-18-arthas%E5%AE%9E%E6%88%98%EF%BC%9A%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-准备测试应用"><a href="#一、-准备测试应用" class="headerlink" title="一、 准备测试应用"></a>一、 准备测试应用</h2><ol><li>新建一个测试程序，写一段线程死锁的代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; resource1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; resource2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        threadLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">threadLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; got resource1 lock.&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟工作时间，让死锁更容易观察到</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to get resource2 lock.&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123; <span class="comment">// 尝试获取resource2的锁</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; got resource2 lock.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; got resource2 lock.&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟工作时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; trying to get resource1 lock.&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123; <span class="comment">// 尝试获取resource1的锁</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; got resource1 lock.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、使用Arthas排查问题"><a href="#二、使用Arthas排查问题" class="headerlink" title="二、使用Arthas排查问题"></a>二、使用Arthas排查问题</h2><ol><li>启动 Arthas：<br><code>java -jar arthas-boot.jar</code></li></ol><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-18-Arthas/img.png" alt="image.png"><br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-18-Arthas/img_1.png" alt="image.png"></p><ol start="2"><li>查看总体使用情况：<br><code>dashboard</code><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-18-Arthas/img_2.png" alt="image.png"><br>可以看到已经有死锁线程了</li><li>查看总体线程使用情况：<br><code>thread</code><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-18-Arthas/img_3.png" alt="image.png"><strong>BLOCKED</strong>线程数量：2，并且显示了具体的<strong>BLOCKED</strong>线程</li><li>定位死锁的位置：<br><code>thread -b</code><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-18-Arthas/img_4.png" alt="image.png"></li></ol><p>输出解释：</p><ul><li><strong>线程信息</strong>：<code>Thread 2</code> 的ID为22，当前状态为<code>BLOCKED</code>。这意味着它正在等待获取某个对象锁。</li><li><strong>阻塞原因</strong>：<code>Thread 2</code>被阻塞是因为需要获取的对象<code>java.util.ArrayLIst@1d0be4d0</code>正被另一个线程所持有。</li><li><strong>锁持有者</strong>：该对象锁<code>java.util.ArrayLIst@1d0be4d0</code>目前被<code>Thread 1</code>（ID为21）持有。</li><li><code>Thread 1</code><strong>的状态</strong>：虽然输出信息没有直接展示<code>Thread 1</code>的状态，但从上下文可以推断，<code>Thread 1</code> locak了<code>java.util.ArrayLIst@1d0be4d0</code>。<code>Thread 2</code> lock了<code>java.util.ArrayLIst@1f2efe1c</code></li><li><strong>相互阻塞</strong>：最关键的信息是<code>ownd by&#39;thread 1</code> ，指出<code>Thread 2</code>尝试获取的锁被<code>Thread 1</code>持有，同时说明<code>Thread 1</code>至少在某一点上也尝试获取<code>Thread 2</code>持有的锁（或者导致了其他形式的循环等待），从而形成了死锁。这里的<code>but blocks 1 other threads!</code>暗示了这种相互阻塞的关系。</li></ul><p>到目前为止。基本已经定位到死锁的具体原因和位置了。</p><ol><li>查看死锁线程详细信息：<br><code>thread 21</code><br><code>thread 22</code><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-18-Arthas/img_5.png" alt="image.png"></li></ol><p>根据上面的信息，我们可以清晰地看到两个线程<code>Thread 1</code>和<code>Thread 2</code>都处于阻塞状态，形成了死锁：</p><ul><li><code>Thread 1 (Id=21)</code> 的状态也是<code>BLOCKED</code>，它在Test.java:38行尝试获取对象<code>java.util.ArrayLIst@1f2efe1c</code>的锁，而这个锁正被<code>Thread 2</code>持有。</li><li><code>Thread 2 (Id=22)</code> 的状态是<code>BLOCKED</code>，它在Test.java:23行尝试获取对象<code>java.util.ArrayLIst@1d0be4d0</code>的锁，但这个锁正被<code>Thread 1</code>持有。</li></ul><p>这种相互等待对方释放锁的情形正是死锁的经典表现。每个线程都持有一个锁，并尝试获取对方的锁，导致双方都无法继续执行下去。</p><ul><li><code>Thread 1</code>在执行到Test.java的第38行时阻塞，等待<code>java.util.ArrayLIst@1f2efe1c</code>的锁。</li><li><code>Thread 2</code>在执行到同文件的第23行时阻塞，等待<code>java.util.ArrayLIst@1d0be4d0</code>的锁。</li><li>两个线程互相等待对方释放锁，形成了死锁。</li></ul><p>解决这个问题的关键在于打破死锁的四大条件之一。即：</p><ol><li>资源不可重用</li><li>循环等待</li><li>资源不可被抢夺</li><li>吃着碗里的看着锅里的</li></ol>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Arthas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vector API介绍&amp;简单使用</title>
      <link href="/2024/08/02/2024-08-02-Vector%20API%E4%BB%8B%E7%BB%8D&amp;%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/08/02/2024-08-02-Vector%20API%E4%BB%8B%E7%BB%8D&amp;%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 我在参与腾讯犀牛鸟开源时，认领了有关Vector API的issue。但找遍全网也找不到关于Vector API具体使用的介绍。于是我简单学习Vector API之后写下这篇简单的介绍供大家参考。个人水平有限。不足之处请大家多多指正。</p><blockquote><p>【JEP咖啡屋18[熟肉]-如何通过Vector API加速并行计算】<a href="https://www.bilibili.com/video/BV1Nh4y1s7dJ?vd_source=6df57b2b8470f0f2c9187d097a219270">https://www.bilibili.com/video/BV1Nh4y1s7dJ?vd_source&#x3D;6df57b2b8470f0f2c9187d097a219270</a></p></blockquote></blockquote><p><a name="x9C3R"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Vector API是自JDK16开始孵化的预览功能，至今仍在孵化中（2024.08.02）。<br />它适用于多个数组的混合运算。将数组转化为多组<strong>定长</strong>的向量进行计算以加快计算速度。而不适用于单数组的内部运算。如：w[i] &#x3D; w[i - 16] ^ w[i - 9]<br><a name="QW5vV"></a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在使用Vector API中有一个非常重要的概念需要知晓：<br><a name="Y0XS5"></a></p><h3 id="Species"><a href="#Species" class="headerlink" title="Species"></a>Species</h3><p>Species是用于确定你的机器能够将几个数组元素转化为向量的关键变量。一般它的长度在64位到512位之间。即可以将2到16个int数组元素转化为一组向量。或者可以将4到32个shortInt数组元素转化为一组向量。<br />Species.length()与机器有关。但我们也可以手动指定。<br />定义一个64位的VectorSpecies物种如下：<br /><code>private static final VectorSpecies&lt;Integer&gt; SPECIES = IntVector.SPECIES_64;</code></p><p><a name="IJQSt"></a></p><h3 id="从数组中创建向量"><a href="#从数组中创建向量" class="headerlink" title="从数组中创建向量"></a>从数组中创建向量</h3><p>IntVector中提供了一个创建向量的方法fromArray<br />方法签名如下：<br /><code>IntVector fromArray(VectorSpecies&lt;Integer&gt; species,int[] a, int offset)</code></p><ul><li>创建向量必须根据Species创建</li><li>从数组a中创建向量</li><li>offset表示从数组第几位开始创建向量<br><a name="il9lc"></a></li></ul><h3 id="向量写回数组"><a href="#向量写回数组" class="headerlink" title="向量写回数组"></a>向量写回数组</h3><p>IntVector中提供了一个写回数组的方法intoArray<br />方法签名：<code>void intoArray(int[] a, int offset)</code><br /><br>offset表示从数组第几位开始写入。</p><p><a name="sKbf1"></a></p><h3 id="mask"><a href="#mask" class="headerlink" title="mask"></a>mask</h3><p>在标准情况下，并不是每个数组的所有元素都能转化为向量的<br /><br>前文提到了：Vector API将数组转化为多组<strong>定长</strong>的向量。完全转化需要数组长度能被Species.length整除<br /><br>但不是每个数组长度都能被Species.length整除<br /></p><p>比如数组array &#x3D; [0, 1, 2, 3, 4………35]，Species.length &#x3D; 16。只有前32个元素能够被转化为向量，<br>剩下的子数组[32, 33, 34, 35]则不能够被转化<br /><br>在<code>fromArray</code>方法内部对offset有检查。如果<code>offset &gt;= array.length - Species.length</code>,那么会抛出indexOutOfLength异常。<br /></p><p>因此，对于剩下的元素，一般推荐使用原始方式计算。<br /><br>但<code>formArray</code>方法也有一个重载版本可以将剩余元素也转化为向量。<br />重载版本的签名如下<br /><br><code>IntVector fromArray(VectorSpecies&lt;Integer&gt; species,int[] a, int offset,VectorMask&lt;Integer&gt; m)</code><br /><br>多传入一个mask变量，即可做到即使<code>offset &gt;= array.length - Species.length</code>，也能转化为向量。但需要<code>offset &lt; array.length</code><br /><br>mask变量使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    SPECIES.length() = 16</span></span><br><span class="line"><span class="comment">    Array.length = 35</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Array.length; i += SPECIES.length()) &#123;</span><br><span class="line">  <span class="type">var</span> <span class="variable">mask</span> <span class="operator">=</span> SPECIES.indexInRange(i, w.length);</span><br><span class="line">  <span class="type">IntVector</span> <span class="variable">v</span> <span class="operator">=</span> IntVector.fromArray(SPECIES, Array, i - <span class="number">16</span>, mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码<code>var mask = SPECIES.indexInRange(i, array.length);</code>中，定义变量的var关键字自JDK10开始引入。它允许你在声明变量时省略其类型，编译器会自动推断出其类型。类似于lambda表达式的无类型参数。</p><p><a name="xV4bn"></a></p><h3 id="lanwise方法"><a href="#lanwise方法" class="headerlink" title="lanwise方法"></a>lanwise方法</h3><p>lanewise直接翻译就是车道交叉。在Vector API中，向量被视为车道，不同向量之间的运算被视为车道交叉。<br />简单的加减乘除，在<code>jdk.incubator.vector.Vector</code>类中已经封装了。<br />例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">va</span> <span class="operator">=</span> IntVector.fromArray(SPECIES, a, i);</span><br><span class="line"><span class="type">var</span> <span class="variable">vb</span> <span class="operator">=</span> IntVector.fromArray(SPECIES, b, i);</span><br><span class="line"><span class="type">var</span> <span class="variable">vc</span> <span class="operator">=</span> va.add(vb);</span><br><span class="line">vc.intoArray(c, i);</span><br></pre></td></tr></table></figure><h3 id="reducesLanes方法"><a href="#reducesLanes方法" class="headerlink" title="reducesLanes方法"></a>reducesLanes方法</h3><p>这是一种归约操作，将向量中各个元素通过某种操作组合起来。如计算一组元素的乘积，总和，最大值，最小值等等</p><p>以下为计算一组元素的平方和的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntVector</span> <span class="variable">v</span> <span class="operator">=</span> IntVector.fromArray(IVectorSpecies.SPECIES_128, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line"><span class="type">var</span> <span class="variable">v2</span> <span class="operator">=</span> v.mult(v);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> v2.reduceLanes(VectorOperators.ADD);</span><br></pre></td></tr></table></figure><h3 id="更加复杂的操作"><a href="#更加复杂的操作" class="headerlink" title="更加复杂的操作"></a>更加复杂的操作</h3><p>我们应该如何对向量进行复杂的操作呢？<br />在<code>jdk.incubator.vector.VectorOperators</code>中已经定义了很多常用的操作，与或非、异或、同或等等<br />在向量A的lanewise方法中，传入运算符的定义与另一个向量B。即可让A与B执行特定的运算。如<br /><code>IntVector temp = wPrev16.lanewise(VectorOperators.XOR, wPrev9)</code><br />向量temp是 wPrev16和wPrev9的异或运算结果。</p><p><a name="ZdbWo"></a></p><h2 id="如何编译运行使用了Vector-API的代码？"><a href="#如何编译运行使用了Vector-API的代码？" class="headerlink" title="如何编译运行使用了Vector API的代码？"></a>如何编译运行使用了Vector API的代码？</h2><p>由于Vector API至今仍处于孵化期，直接使用必然报错。需要在编译时指定两个参数<code>--enable-preview</code>和<code>--add-modules=jdk.incubator.vector</code>。<br />在哪里指定？<br />网络上一些博客说的在pom文件中添加编译参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">arg</span>&gt;</span>--enable-preview<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">arg</span>&gt;</span>--add-modules=jdk.incubator.vector<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">compilerVersion</span>&gt;</span>21<span class="tag">&lt;/<span class="name">compilerVersion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>21<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>21<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对我而言并没有用。<br />在IDEA的运行配置中添加也没有用：<br /><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-02-VectorAPI/img_1.png" alt="image.png"><br /><br /><br>于是我只能使用最原始的办法。在命令行中运行<br /><br /><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-02-VectorAPI/img_2.png" alt="image.png"><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-08-02-VectorAPI/img_3.png" alt="img.png"><br /><br /><br>我的机器上的JDK版本是21。想使用Vector API最低也要JDK16。<br /><br /></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Java类加载机制谈起：如何实现热部署</title>
      <link href="/2024/08/01/2024-08-01-%E4%BB%8EJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%B0%88%E8%B5%B7%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/08/01/2024-08-01-%E4%BB%8EJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%B0%88%E8%B5%B7%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://developer.aliyun.com/article/828000">从Java类加载机制谈起：如何实现热部署</a></p></blockquote><h2 id="一-、class的热替换"><a href="#一-、class的热替换" class="headerlink" title="一 、class的热替换"></a>一 、class的热替换</h2><p>ClassLoader中重要的方法:</p><h3 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass:"></a>loadClass:</h3><p>**ClassLoader.loadClass(…) **是ClassLoader的入口点。当一个类没有指明用什么加载器加载的时候，JVM默认采用AppClassLoader加载器加载没有加载过的class，调用的方法的入口就是loadClass(…)。如果一个class被自定义的ClassLoader加载，那么JVM也会调用这个自定义的ClassLoader.loadClass(…)方法来加载class内部引用的一些别的class文件。重载这个方法，能实现自定义加载class的方式，抛弃双亲委托机制，但是即使不采用双亲委托机制，比如java.lang包中的相关类还是不能自定义一个同名的类来代替，主要因为JVM解析、验证class的时候，会进行相关判断。</p><h3 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass:"></a>defineClass:</h3><p>系统自带的ClassLoader，默认加载程序的是AppClassLoader，ClassLoader加载一个class，最终调用的是defineClass(…)方法，这时候就在想是否可以重复调用defineClass(…)方法加载同一个类(或者修改过)，最后发现调用多次的话会有相关错误:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.LinkageError </span><br><span class="line">attempted duplicate <span class="keyword">class</span> <span class="title class_">definition</span></span><br></pre></td></tr></table></figure><p>所以<strong>一个class被一个ClassLoader实例加载过的话，就不能再被这个ClassLoader实例再次加载</strong>(这里的加载指的是，调用了defileClass(…)放方法，重新加载字节码、解析、验证。)。而系统默认的AppClassLoader加载器，他们内部会缓存加载过的class，重新加载的话，就直接取缓存。所与对于热加载的话，只能重新创建一个ClassLoader，然后再去加载已经被加载过的class文件。</p><h2 id="二、class的卸载"><a href="#二、class的卸载" class="headerlink" title="二、class的卸载"></a>二、class的卸载</h2><p>在Java中class也是可以unload。<strong>JVM中class和Meta信息存放在PermGen space区域</strong>。如果加载的class文件很多，那么可能导致PermGen space区域空间溢出。引起：java.lang.OutOfMemoryErrorPermGen space. 对于有些Class我们可能只需要使用一次，就不再需要了，也可能我们修改了class文件，我们需要重新加载 newclass，那么oldclass就不再需要了。那么JVM怎么样才能卸载Class呢。<br>JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）：</p><ul><li>该类所有的实例都已经被GC。</li><li>加载该类的ClassLoader实例已经被GC。</li><li>该类的java.lang.Class对象没有在任何地方被引用。</li></ul><p>GC的时机我们是不可控的，那么同样的我们对于Class的卸载也是不可控的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范).</span><br><span class="line">被系统类加载器和标准扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者标准扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小.(当然，在虚拟机快退出的时候可以，因为不管ClassLoader实例或者Class(java.lang.Class)实例也都是在堆中存在，同样遵循垃圾收集的规则).</span><br><span class="line">被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到.可以预想，稍微复杂点的应用场景中(尤其很多时候，用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的).</span><br></pre></td></tr></table></figure><p>综合以上三点， 一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的.同时，我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下来实现系统中的特定功能.</p><hr><h2 id="三、Tomcat中关于类的加载与卸载"><a href="#三、Tomcat中关于类的加载与卸载" class="headerlink" title="三、Tomcat中关于类的加载与卸载"></a>三、Tomcat中关于类的加载与卸载</h2><p>Tomcat中与其说有热加载，还不如说是热部署来的准确些。因为对于一个应用，其中class文件被修改过，那么Tomcat会先卸载这个应用(Context)，然后重新加载这个应用，其中关键就在于自定义ClassLoader的应用。这里有篇文章很好的介绍了tomcat中对于ClassLoader的应用。<br>Tomcat启动的时候，ClassLoader加载的流程：</p><ol><li>system classloader即AppClassLoader加载 {catalina.home}&#x2F;bin里面的jar包，也就是tomcat启动相关的jar包。 </li><li>Tomcat启动类Bootstrap中有3个classloader属性，catalinaLoader、commonLoader、sharedLoader在Tomcat7中默认他们初始化都为同一个StandardClassLoader实例。具体的也可以在 {catalina.home}&#x2F;bin&#x2F;bootstrap.jar包中的catalina.properites中进行配置</li><li>StandardClassLoader加载 {catalina.home}&#x2F;lib下面的所有Tomcat用到的jar包</li><li>一个Context容器，代表了一个app应用。Context–&gt;WebappLoader–&gt;WebClassLoader。并且Thread.contextClassLoader&#x3D;WebClassLoader。应用程序中的jsp文件、class类、lib&#x2F;*.jar包，都是WebClassLoader加载的。</li></ol><p>当Jsp文件修改的时候，Tomcat更新步骤：  </p><ol><li><p>当访问1.jsp的时候，1.jsp的包装类JspServletWrapper会去比较1.jsp文件最新修改时间和上次的修改时间，以此判断1.jsp是否修改过</p></li><li><p>1.jsp修改过的话，那么jspservletWrapper会清除相关引用，包括1.jsp编译后的servlet实例和加载这个servlet的JasperLoader实例</p></li><li><p>重新创建一个JasperLoader实例，重新加载修改过后的1.jsp，重新生成一个Servlet实例</p></li><li><p>返回修改后的1.jsp内容给用户。<br>当app下面的class文件修改的时候，Tomcat更新步骤：</p></li><li><p>Context容器会有专门线程监控app下面的类的修改情况 </p></li><li><p>如果发现有类被修改了。那么调用Context.reload()。清楚一系列相关的引用和资源</p></li><li><p>然后创新创建一个WebClassLoader实例，重新加载app下面需要的class。</p></li></ol><p>在一个有一定规模的应用中，如果文件修改多次，重启多次的话,<code>java.lang.OutOfMemoryErrorPermGen space</code>这个错误的的出现非常频繁。主要就是因为每次重启重新加载大量的class，超过了PermGen space设置的大小<br>两种情况可能导致PermGen space溢出</p><ol><li>GC(Garbage Collection)在主程序运行期对PermGen space没有进行清理(GC的不可控行)， </li><li>重启之前WebClassLoader加载的class在别的地方还存在着引用。  <blockquote><p><a href="http://www.blogjava.net/heavensay/archive/2012/11/07/389685.html">class卸载、热替换和Tomcat的热部署的分析 - heavensay - BlogJava</a></p></blockquote></li></ol><hr><h3 id="类加载的探索"><a href="#类加载的探索" class="headerlink" title="类加载的探索"></a>类加载的探索</h3><p>首先谈一下何为热部署（hotswap），<strong>热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为</strong>。<br>Java 类是通过 Java 虚拟机加载的，某个类的 class 文件在被 classloader 加载后，会生成对应的 Class 对象，之后就可以创建该类的实例。<br><strong>默认的虚拟机行为只会在启动时加载类，如果后期有一个类需要更新的话，单纯替换编译的 class 文件，Java 虚拟机是不会更新正在运行的 class</strong>。如果要实现热部署，最根本的方式是修改虚拟机的源代码，改变 classloader 的加载行为，使虚拟机能监听 class 文件的更新，重新加载 class 文件。这样的行为破坏性很大。  </p><p>另一种友好的方法是创建自己的 classloader 来加载需要监听的 class，这样就能控制类加载的时机，从而实现热部署。<br>本文将具体探索如何实现这个方案。首先需要了解一下 Java 虚拟机现有的加载机制。目前的加载机制，称为<strong>双亲委派</strong>。<br>系统在使用一个 classloader 来加载类时，会先询问当前 classloader 的父类是否有能力加载，如果父类无法实现加载操作，才会将任务下放到该 classloader 来加载。这种自上而下的加载方式的好处是，让每个 classloader 执行自己的加载任务，不会重复加载类。  </p><p><strong>但是这种方式却使加载顺序非常难改变，让自定义 classloader 抢先加载需要监听改变的类成为了一个难题。</strong><br>不过我们可以换一个思路，虽然无法抢先加载该类，但是仍然可以用自定义 classloader 创建一个功能相同的类，让每次实例化的对象都指向这个新的类。当这个类的 class 文件发生改变的时候，再次创建一个更新的类，之后如果系统再次发出实例化请求，创建的对象讲指向这个全新的类。<br>下面来简单列举一下需要做的工作。</p><p>创建自定义的 classloader，加载需要监听改变的类，在 class 文件发生改变的时候，重新加载该类。 改变创建对象的行为，使他们在创建时使用自定义 classloader 加载的 class。</p><hr><h3 id="自定义类加载器的实现"><a href="#自定义类加载器的实现" class="headerlink" title="自定义类加载器的实现"></a>自定义类加载器的实现</h3><p>自定义加载器仍然需要执行类加载的功能。这里却存在一个问题，<strong>同一个类加载器无法同时加载两个相同名称的类</strong>，由于不论类的结构如何发生变化，生成的类名不会变，而 <strong>classloader 只能在虚拟机停止前销毁已经加载的类</strong>，这样 classloader 就无法加载更新后的类了。这里有一个小技巧，让每次加载的类都保存成一个带有版本信息的 class，比如加载 Test.class 时，保存在内存中的类是 Test_v1.class，当类发生改变时，重新加载的类名是 Test_v2.class。但是真正执行加载 class 文件创建 class 的 defineClass 方法是一个 native 的方法，修改起来又变得很困难。所以面前还剩一条路，那就是直接修改编译生成的 class 文件。<br><strong>利用 ASM 修改 class 文件</strong><br>可以修改字节码的框架有很多，比如 ASM，CGLIB。本文使用的是 ASM。先来介绍一下 class 文件的结构，class 文件包含了以下几类信息:</p><p>第一个是类的基本信息，包含了访问权限信息，类名信息，父类信息，接口信息。<br>第二个是类的变量信息。<br>第三个是方法的信息。</p><p>ASM 会先加载一个 class 文件，然后严格顺序读取类的各项信息，用户可以按照自己的意愿定义增强组件修改这些信息，最后输出成一个新的 class。<br>首先看一下如何利用 ASM 修改类信息。</p><ol><li><p>利用 ASM 修改字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS); </span><br><span class="line">   <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="literal">null</span>;     </span><br><span class="line">   <span class="type">String</span> <span class="variable">enhancedClassName</span> <span class="operator">=</span> classSource.getEnhancedName(); </span><br><span class="line">   <span class="keyword">try</span> &#123; </span><br><span class="line">       cr = <span class="keyword">new</span> <span class="title class_">ClassReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>( </span><br><span class="line">               classSource.getFile())); </span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">       e.printStackTrace(); </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="type">ClassVisitor</span> <span class="variable">cv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnhancedModifier</span>(cw, </span><br><span class="line">           className.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>), </span><br><span class="line">           enhancedClassName.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>)); </span><br><span class="line">   cr.accept(cv, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>ASM 修改字节码文件的流程是一个责任链模式，首先使用一个 ClassReader 读入字节码，然后利用 ClassVisitor 做个性化的修改，最后利用 ClassWriter 输出修改后的字节码。<br>之前提过，需要将读取的 class 文件的类名做一些修改，加载成一个全新名字的派生类。这里将之分为了 2 个步骤。<br><strong>第一步，先将原来的类变成接口。</strong></p></li><li><p>重定义的原始类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; redefineClass(String className)&#123; </span><br><span class="line">    <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS); </span><br><span class="line">    <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="type">ClassSource</span> <span class="variable">cs</span> <span class="operator">=</span> classFiles.get(className); </span><br><span class="line">    <span class="keyword">if</span>(cs==<span class="literal">null</span>)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        cr = <span class="keyword">new</span> <span class="title class_">ClassReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(cs.getFile())); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">ClassModifier</span> <span class="variable">cm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassModifier</span>(cw); </span><br><span class="line">    cr.accept(cm, <span class="number">0</span>); </span><br><span class="line">    <span class="type">byte</span>[] code = cw.toByteArray(); </span><br><span class="line">    <span class="keyword">return</span> defineClass(className, code, <span class="number">0</span>, code.length); </span><br></pre></td></tr></table></figure><p>首先 load 原始类的 class 文件，此处定义了一个增强组件 ClassModifier，作用是修改原始类的类型，将它转换成接口。原始类的所有方法逻辑都会被去掉。<br><strong>第二步，生成的派生类都实现这个接口，即原始类，并且复制原始类中的所有方法逻辑。</strong>之后如果该类需要更新，会生成一个新的派生类，也会实现这个接口。这样做的目的是不论如何修改，同一个 class 的派生类都有一个共同的接口，他们之间的转换变得对外不透明。</p></li><li><p>定义一个派生类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 class 文件发生改变时重新定义这个类</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; redefineClass(String className, ClassSource classSource)&#123; </span><br><span class="line">    <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_MAXS); </span><br><span class="line">    <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    classSource.update(); </span><br><span class="line">    <span class="type">String</span> <span class="variable">enhancedClassName</span> <span class="operator">=</span> classSource.getEnhancedName();       </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        cr = <span class="keyword">new</span> <span class="title class_">ClassReader</span>( </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classSource.getFile())); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">EnhancedModifier</span> <span class="variable">em</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EnhancedModifier</span>(cw, className.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>), </span><br><span class="line">            enhancedClassName.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>)); </span><br><span class="line">    <span class="type">ExtendModifier</span> <span class="variable">exm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtendModifier</span>(em, className.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>), </span><br><span class="line">            enhancedClassName.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>)); </span><br><span class="line">    cr.accept(exm, <span class="number">0</span>); </span><br><span class="line">    <span class="type">byte</span>[] code = cw.toByteArray(); </span><br><span class="line">    classSource.setByteCopy(code); </span><br><span class="line">    Class&lt;?&gt; clazz = defineClass(enhancedClassName, code, <span class="number">0</span>, code.length); </span><br><span class="line">    classSource.setClassCopy(clazz); </span><br><span class="line">    <span class="keyword">return</span> clazz; </span><br></pre></td></tr></table></figure></li></ol><p>再次 load 原始类的 class 文件，此处定义了两个增强组件，一个是 EnhancedModifier，这个增强组件的作用是改变原有的类名。第二个增强组件是 ExtendModifier，这个增强组件的作用是改变原有类的父类，让这个修改后的派生类能够实现同一个原始类（此时原始类已经转成接口了）。<br>自定义 classloader 还有一个作用是监听会发生改变的 class 文件，classloader 会管理一个定时器，定时依次扫描这些 class 文件是否改变。</p><hr><h2 id="四、改变创建对象的行为"><a href="#四、改变创建对象的行为" class="headerlink" title="四、改变创建对象的行为"></a>四、改变创建对象的行为</h2><p>Java 虚拟机常见的创建对象的方法有两种，一种是静态创建，直接 new 一个对象，一种是动态创建，通过反射的方法，创建对象。<br>由于已经在自定义加载器中更改了原有类的类型，把它从类改成了接口，所以这两种创建方法都无法成立。我们要做的是将实例化原始类的行为变成实例化派生类。<br>对于第一种方法，需要做的是将静态创建，变为通过 classloader 获取 class，然后动态创建该对象。</p><ol start="4"><li><p>替换后的指令集所对应的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始逻辑</span></span><br><span class="line"><span class="type">Greeter</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeter</span>();</span><br><span class="line"><span class="comment">// 改变后的逻辑</span></span><br><span class="line"><span class="type">IGreeter</span> <span class="variable">p</span> <span class="operator">=</span> (IGreeter)MyClassLoader.getInstance().</span><br><span class="line">findClass(“com.example.Greeter”).newInstance();</span><br></pre></td></tr></table></figure><p>这里又需要用到 ASM 来修改 class 文件了。查找到所有 new 对象的语句，替换成通过 classloader 的形式来获取对象的形式。</p></li><li><p>利用 ASM 修改方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitTypeInsn</span><span class="params">(<span class="type">int</span> opcode, String type)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(opcode==Opcodes.NEW &amp;&amp; type.equals(className))&#123; </span><br><span class="line">        List&lt;LocalVariableNode&gt; variables = node.localVariables; </span><br><span class="line">        <span class="type">String</span> <span class="variable">compileType</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;variables.size();i++)&#123; </span><br><span class="line">            <span class="type">LocalVariableNode</span> <span class="variable">localVariable</span> <span class="operator">=</span> variables.get(i); </span><br><span class="line">            compileType = formType(localVariable.desc); </span><br><span class="line">            <span class="keyword">if</span>(matchType(compileType)&amp;&amp;!valiableIndexUsed[i])&#123; </span><br><span class="line">                valiableIndexUsed[i] = <span class="literal">true</span>; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    mv.visitMethodInsn(Opcodes.INVOKESTATIC, CLASSLOAD_TYPE, </span><br><span class="line">        <span class="string">&quot;getInstance&quot;</span>, <span class="string">&quot;()L&quot;</span>+CLASSLOAD_TYPE+<span class="string">&quot;;&quot;</span>); </span><br><span class="line">    mv.visitLdcInsn(type.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>)); </span><br><span class="line">    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLASSLOAD_TYPE, </span><br><span class="line">        <span class="string">&quot;findClass&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;</span>); </span><br><span class="line">    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">&quot;java/lang/Class&quot;</span>, </span><br><span class="line">        <span class="string">&quot;newInstance&quot;</span>, <span class="string">&quot;()Ljava/lang/Object;&quot;</span>); </span><br><span class="line">    mv.visitTypeInsn(Opcodes.CHECKCAST, compileType); </span><br><span class="line">    flag = <span class="literal">true</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        mv.visitTypeInsn(opcode, type); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>对于第二种创建方法，需要通过修改 Class.forName()和 ClassLoader.findClass()的行为，使他们通过自定义加载器加载类。</p></li></ol><hr><h2 id="五、使用-JavaAgent-拦截默认加载器的行为"><a href="#五、使用-JavaAgent-拦截默认加载器的行为" class="headerlink" title="五、使用 JavaAgent 拦截默认加载器的行为"></a>五、使用 JavaAgent 拦截默认加载器的行为</h2><p>之前实现的类加载器已经解决了热部署所需要的功能，可是 JVM 启动时，并不会用自定义的加载器加载 classpath 下的所有 class 文件，取而代之的是通过应用加载器去加载。如果在其之后用自定义加载器重新加载已经加载的 class，有可能会出现 LinkageError 的 exception。所以必须在应用启动之前，重新替换已经加载的 class。如果在 jdk1.4 之前，能使用的方法只有一种，改变 jdk 中 classloader 的加载行为，使它指向自定义加载器的加载行为。好在 jdk5.0 之后，我们有了另一种侵略性更小的办法，这就是 JavaAgent 方法，JavaAgent 可以在 JVM 启动之后，应用启动之前的短暂间隙，提供空间给用户做一些特殊行为。比较常见的应用，是利用 JavaAgent 做面向方面的编程，在方法间加入监控日志等。<br>JavaAgent 的实现很容易，只要在一个类里面，定义一个 premain 的方法。</p><ol start="6"><li><p>一个简单的 JavaAgent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReloadAgent</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span>&#123; </span><br><span class="line">        <span class="type">GeneralTransformer</span> <span class="variable">trans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralTransformer</span>(); </span><br><span class="line">        inst.addTransformer(trans); </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后编写一个 manifest 文件，将 Premain-Class属性设置成定义一个拥有 premain方法的类名即可。<br>生成一个包含这个 manifest 文件的 jar 包。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">manifest-Version:</span> <span class="number">1.0</span> </span><br><span class="line"><span class="attr">Premain-Class:</span> <span class="string">com.example.ReloadAgent</span> </span><br><span class="line"><span class="attr">Can-Redefine-Classes:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最后需要在执行应用的参数中增加 -javaagent参数 , 加入这个 jar。同时可以为 Javaagent增加参数，下图中的参数是测试代码中 test project 的绝对路径。这样在执行应用的之前，会优先执行 premain方法中的逻辑，并且预解析需要加载的 class。<br>这里利用 JavaAgent替换原始字节码，阻止原始字节码被 Java 虚拟机加载。只需要实现 一个 ClassFileTransformer的接口，利用这个实现类完成 class 替换的功能。</p></li><li><p>替换 class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span> [] transform(ClassLoader paramClassLoader, String paramString, </span><br><span class="line">                         Class&lt;?&gt; paramClass, ProtectionDomain paramProtectionDomain, </span><br><span class="line">                         <span class="type">byte</span> [] paramArrayOfByte) <span class="keyword">throws</span> IllegalClassFormatException &#123; </span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> paramString.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span>(className.equals(<span class="string">&quot;com.example.Test&quot;</span>))&#123; </span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> MyClassLoader.getInstance(); </span><br><span class="line">        cl.defineReference(className, <span class="string">&quot;com.example.Greeter&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> cl.getByteCode(className); </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(className.equals(<span class="string">&quot;com.example.Greeter&quot;</span>))&#123; </span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> MyClassLoader.getInstance(); </span><br><span class="line">        cl.redefineClass(className); </span><br><span class="line">        <span class="keyword">return</span> cl.getByteCode(className); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，所有的工作大功告成。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 字节码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraalVM 静态编译下 OTel Java Agent 的自动增强方案与实现</title>
      <link href="/2024/07/14/2024-07-14-GraalVM%20%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E4%B8%8B%20OTel%20Java%20Agent%20%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%A1%88%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/07/14/2024-07-14-GraalVM%20%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E4%B8%8B%20OTel%20Java%20Agent%20%E7%9A%84%E8%87%AA%E5%8A%A8%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%A1%88%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文档的创作灵感来源于阿里巴巴中间件微信公众号的推文，是对其的解读<br><a href="https://mp.weixin.qq.com/s/kEqBut3gcV9RM86DAMJLRA">GraalVM 静态编译下 OTel Java Agent 的自动增强方案与实现</a><br>本文档讨论的动态、静态编译仅限于java语言  </p></blockquote><h2 id="什么是动态编译？"><a href="#什么是动态编译？" class="headerlink" title="什么是动态编译？"></a>什么是动态编译？</h2><p>启动jar运行程序时，热点代码会被JVM以JIT（Just-In-Time Compilation,即时编译）的形式编译为机器码。当我们启动jar包时，实质上是启动了一个JVM，然后执行类加载，JIT将热点字节码编译为机器码这三个部分。</p><p>也就是说，<strong>java的动态编译是指动态地将热点字节码编译为机器码直接让CPU执行。</strong></p><blockquote><p>需要注意的是，类加<strong>载这个过程</strong>实际上在启动阶段只会加载那些需要被运行的类。笔者在起草这篇文档时已经很久没有接触过JVM的八股了，<strong>忘了类加载的时机</strong>，<strong>以为所有的类在启动时都会被加载</strong>。导致没有理解后续的JIT编译热点代码。<a href="https://www.yuque.com/u41117719/xd1qgc/iqfmoe9tpnstvw0i">类的生命周期与加载时机</a><br><strong>明明所有的类都被加载了,为什么还有编译为机器码的步骤？</strong><br>这是笔者的第二个误区。类的字节码被加载进JVM内存后，JVM会将字节码解析并转换为JVM内部的数据结构，比如:</p><ul><li><strong>方法区</strong>，记录类的相关信息：类名、方法、变量等等</li><li><strong>虚拟机栈</strong>，用栈帧记录每个java方法从调用直至执行完成的过程。栈帧中存储了局部变量表、操作数栈、动态链接、方法返回地址等等信息</li><li><strong>本地方法栈</strong>：与虚拟机栈几乎完全相同。区别在于本地方法栈如其名，只记录native的C++方法</li><li><strong>堆</strong>：存储对象实例和<strong>数组</strong>。是的，也有数组。java秉持着<strong>一切皆对象</strong>的原则，大方地让数组都继承了Object类。</li><li><strong>运行时常量池</strong>：存储像符号引用(类和接口的全限定名、字段名称、方法名称)、编译期计算出来的常量表达式、字符串常量、枚举类常量等等。</li></ul></blockquote><p><a href="https://www.yuque.com/u41117719/xd1qgc/hreiiqh4texe9z9m">运行时内存区域</a></p><blockquote><p>字节码在JVM里并不是以机器码执行的。能够执行机器码的，只有CPU。<br>只是说频繁被使用的字节码会由JIT编译为字节码<strong>直接</strong>让CPU去执行，提高执行效率。<br>秋招前夕，笔者的JVM已经忘得差不多了，难绷</p></blockquote><h2 id="什么是静态编译？"><a href="#什么是静态编译？" class="headerlink" title="什么是静态编译？"></a>什么是静态编译？</h2><p>相比于动态编译只将热点数据编译为机器码让CPU执行，静态编译是把所有字节码全部编译为机器码并打包为二进制可执行文件（如Windows平台的exe文件）。<br>不过由于不同操作系统的二进制文件格式并不一样, 所以静态编译时需要程序员手动指定操作系统</p><h2 id="静态编译有哪些问题？"><a href="#静态编译有哪些问题？" class="headerlink" title="静态编译有哪些问题？"></a>静态编译有哪些问题？</h2><p>下文基于文档开头提到的公众号文章中提到的静态编译技术：GraalVM的Native Image。<br>以下三点问题均引用自公众号原文。</p><h2 id="“一次编译，处处运行”失效了"><a href="#“一次编译，处处运行”失效了" class="headerlink" title="“一次编译，处处运行”失效了"></a>“一次编译，处处运行”失效了</h2><p>以往依托于字节码和JVM，确实可以处处运行。但是静态编译只是把字节码作为中间变量，是生成二进制可执行文件的中间工具。为MacOS平台编译的unix可执行文件没办法在windows和linux上接着执行。</p><h2 id="java的许多动态特性都不直接生效了"><a href="#java的许多动态特性都不直接生效了" class="headerlink" title="java的许多动态特性都不直接生效了"></a>java的许多动态特性都不直接生效了</h2><p>例如动态类加载，反射，动态代理等。</p><ul><li>动态类加载失效：Native Image在构建时就需要知道应用会用到的所有类，然后把这些类打包进二进制文件。这样在运行时就不需要再加载任何类了，因为所有需要的类都已经在里面了。</li><li>反射失效：java反射的原理是根据类的字节码获取类的信息。而在静态编译中，编译期就要把代码全部编译完，且不会保留任何类的元数据。程序运行时动态反射指定的类对静态编译而言是不知道的。这就会导致即使字节码存在，元数据的丢失也会导致反射失效。<br>因为反射就是通过类的元数据加载这个类的方法和字段的。所以需要手动指定哪些类会被反射，静态编译才会把它们的元数据和字节码编译进最终生成的二进制文件中</li><li>动态代理失效：不管JDK代理还是CGLIB代理，都是基于原有字节码创建新的字节码。而在静态编译中，由于没有了字节码和元数据的概念，动态代理自然就和反射一样失效了。</li></ul><blockquote><h6 id="为什么静态编译会丢失元数据？"><a href="#为什么静态编译会丢失元数据？" class="headerlink" title="为什么静态编译会丢失元数据？"></a>为什么静态编译会丢失元数据？</h6><p>待补充</p></blockquote><h2 id="基于字节码改写实现的Java-Agent将不再适用"><a href="#基于字节码改写实现的Java-Agent将不再适用" class="headerlink" title="基于字节码改写实现的Java Agent将不再适用"></a>基于字节码改写实现的Java Agent将不再适用</h2><p>因为没有了字节码概念，所以之前我们通过 Java Agent 做到的各种可观测能力，例如收集 Trace&#x2F;Metrics 等信号这些能力都不能生效了。</p><p>总的来说，静态编译导致的字节码缺失是java程序的许多特性都不直接生效的根本原因。</p><h2 id="如何解决静态编译带来的问题？"><a href="#如何解决静态编译带来的问题？" class="headerlink" title="如何解决静态编译带来的问题？"></a>如何解决静态编译带来的问题？</h2><p>参考原文第二部分：<img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-14-GraalVM/img.png" alt="image.png"></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-14-GraalVM/img_1.png" alt="image.png"><br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-14-GraalVM/img_2.png" alt="image.png"><br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-14-GraalVM/img_3.png" alt="image.png"></p><p>总的来说，是通过在native编译前先用普通的jvm执行一遍，把需要修改和增强的扩展点识别出来保存下来，然后native编译的时候再基于这些东西去增强。</p><p>对于加载过程之前的字节码修改可以前置到编译时期，对运行时的，像arthas，又该如何解决呢？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 字节码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 静态编译 </tag>
            
            <tag> JIT </tag>
            
            <tag> AOT </tag>
            
            <tag> native image </tag>
            
            <tag> GraalVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL三大日志</title>
      <link href="/2024/07/13/2024-07-13-%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/"/>
      <url>/2024/07/13/2024-07-13-%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是三大日志"><a href="#什么是三大日志" class="headerlink" title="什么是三大日志"></a>什么是三大日志</h2><ul><li>**bin日志： **保存的是当前数据库中最新的数据以及表结构变更的语句，不包含每行数据的历史版本。</li><li><strong>undo日志：</strong>不仅保存了最新的数据，也保存了每行数据的历史版本，为事务回滚和MVCC提供了支持。</li><li><strong>redo日志：</strong>保存内存缓冲区BufferPool中脏页的数据，不保存已经被刷到磁盘中的数据，也就是说，redo日志保存的数据是不全的。redo日志只是为了应对因为断电等原因BufferPool还没来得及刷到磁盘就丢失了的情况。redo日志默认每秒钟都会刷一次盘，事务提交时也会刷盘，mysql关闭时也会刷盘。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>redo的作用是对Bufferpool中脏页的持久化。</strong>保存的是脏页更新后的值。<br>而undo保存的更新前的值。对undo的刷盘是异步的，不知道它什么时候刷。万一刷盘过程中宕机，bufferpool脏页的数据就全没了。为了不让它全没，就有了redo对Bufferpool的持久化。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="三个log的记录顺序是什么"><a href="#三个log的记录顺序是什么" class="headerlink" title="三个log的记录顺序是什么?"></a>三个log的记录顺序是什么?</h3><ul><li>undo：在事务开启时就会记录数据；</li><li>redo： 在增删改语句执行之前就会记录数据；</li><li>bin： 在增删改语句执行之后会生成一条binlog。事务提交时这条binlog会写入磁盘的binlog。<br>一个log文件写满之后，会创建一个新的log文件接着写入。</li></ul><h3 id="为什么有了-binlog，-还要有-redo-log？"><a href="#为什么有了-binlog，-还要有-redo-log？" class="headerlink" title="为什么有了 binlog， 还要有 redo log？"></a>为什么有了 binlog， 还要有 redo log？</h3><p>这个问题跟 MySQL 的时间线有关系。<br>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。<br>而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。</p><h3 id="有了undolog为啥还需要redolog呢，不能直接undolog-最新数据刷盘吗"><a href="#有了undolog为啥还需要redolog呢，不能直接undolog-最新数据刷盘吗" class="headerlink" title="有了undolog为啥还需要redolog呢，不能直接undolog+最新数据刷盘吗"></a>有了undolog为啥还需要redolog呢，不能直接undolog+最新数据刷盘吗</h3><p>最新数据也就是BufferPool里面的内存数据，当增删改的sql执行成功后，一些缓存页就会被修改，这些被修改的数据以脏页的形式存放在BufferPool中。<br>一旦服务器宕机，这些脏页的数据就全没了。<br>所以要保证脏页的数据在宕机之间就被持久化。而这就靠redolog保证了。<br>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会<strong>先</strong>更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来。<br>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化。根据redo就可以恢复完整的原内存数据了。</p><h3 id="为什么要增加一个redolog来保证BufferPool脏页的持久化？直接把脏页持久化到磁盘不行吗？redolog也是持久化到磁盘啊？"><a href="#为什么要增加一个redolog来保证BufferPool脏页的持久化？直接把脏页持久化到磁盘不行吗？redolog也是持久化到磁盘啊？" class="headerlink" title="为什么要增加一个redolog来保证BufferPool脏页的持久化？直接把脏页持久化到磁盘不行吗？redolog也是持久化到磁盘啊？"></a>为什么要增加一个redolog来保证BufferPool脏页的持久化？直接把脏页持久化到磁盘不行吗？redolog也是持久化到磁盘啊？</h3><h4 id="直接持久化Buffer-Pool的局限性"><a href="#直接持久化Buffer-Pool的局限性" class="headerlink" title="直接持久化Buffer Pool的局限性"></a>直接持久化Buffer Pool的局限性</h4><ol><li><strong>性能影响</strong>：脏页的数据在B+树中存储的位置基本不是连续的，必然会有大量的随机IO。</li><li><strong>并发问题</strong>：直接将Buffer Pool的内容写回磁盘会导致更多的锁竞争，因为多个事务可能同时尝试写入相同的页面。</li><li><strong>数据完整性风险</strong>：如果在事务提交过程中发生崩溃，而修改尚未完全写入磁盘，那么数据可能处于不一致状态。</li></ol><h4 id="redoLog的改善"><a href="#redoLog的改善" class="headerlink" title="redoLog的改善"></a>redoLog的改善</h4><ol><li><strong>性能影响</strong>：redo的写入是顺序的，是磁盘顺序io，比随机io快得多</li><li><strong>并发问题</strong>：redo是由后台单线程管理的，天然避免了并发问题。</li><li><strong>数据完整性风险</strong>：InnoDB维护一个叫做Checkpoint的机制，它记录了最后成功完成的Redo Log的位置。在系统重启时，InnoDB可以从这个位置开始重做，以确保所有已完成的事务都被正确处理</li></ol><blockquote><p>本问题的回答由AI生成<br><a href="https://lxblog.com/qianwen/share?shareId=cf89a692-e026-4745-a132-fe6afc901f2b">https://lxblog.com/qianwen/share?shareId=cf89a692-e026-4745-a132-fe6afc901f2b</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2024/07/11/2024-07-11-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2024/07/11/2024-07-11-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<br><p>set nx命令设置锁， key是锁名，value是自定义结构。<br>set成功会返回1，没有成功会返回0.单线程执行使得争夺锁的那些进程具有了互斥性  </p><h2 id="一个进程持有锁之后，如果它挂了，那么这把锁不是永远都无法释放了吗？"><a href="#一个进程持有锁之后，如果它挂了，那么这把锁不是永远都无法释放了吗？" class="headerlink" title="一个进程持有锁之后，如果它挂了，那么这把锁不是永远都无法释放了吗？"></a>一个进程持有锁之后，如果它挂了，那么这把锁不是永远都无法释放了吗？</h2><p>最简单的方式可以给锁设置一个过期时间  </p><h2 id="如果进程在执行一个耗时比较久的任务，任务还没执行锁就过期了，其它实例获取了锁，然后该进程执行完毕后试图释放锁，却发现锁不在自己这就会有一些问题了，怎么办？"><a href="#如果进程在执行一个耗时比较久的任务，任务还没执行锁就过期了，其它实例获取了锁，然后该进程执行完毕后试图释放锁，却发现锁不在自己这就会有一些问题了，怎么办？" class="headerlink" title="如果进程在执行一个耗时比较久的任务，任务还没执行锁就过期了，其它实例获取了锁，然后该进程执行完毕后试图释放锁，却发现锁不在自己这就会有一些问题了，怎么办？"></a>如果进程在执行一个耗时比较久的任务，任务还没执行锁就过期了，其它实例获取了锁，然后该进程执行完毕后试图释放锁，却发现锁不在自己这就会有一些问题了，怎么办？</h2><p>set nx时，将value设置为该进程的进程id。<br>再使用lua脚本：<code>EVAL &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot; 1 keyName clientID</code><br>判断锁的所有者是否与传入的客户端 ID 匹配。如果匹配，则删除锁并返回 1；如果不匹配，则返回 0。</p><p>然后java里面有一个封装后的redis包叫redission。它里面封装了一个看门狗的机制，每隔30秒检查一次看看这个任务有没有结束，没结束就给延长锁的过期时间，保证在执行期间只有这么一个进程可以获取锁。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一条SQL带你理清页、索引、锁的关系</title>
      <link href="/2024/07/10/2024-07-10-%E4%B8%80%E6%9D%A1SQL%E5%B8%A6%E4%BD%A0%E7%90%86%E6%B8%85%E9%A1%B5%E3%80%81%E7%B4%A2%E5%BC%95%E3%80%81%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2024/07/10/2024-07-10-%E4%B8%80%E6%9D%A1SQL%E5%B8%A6%E4%BD%A0%E7%90%86%E6%B8%85%E9%A1%B5%E3%80%81%E7%B4%A2%E5%BC%95%E3%80%81%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>user表,id是主键,有a,b,c三个字段，都是int,a有索引，b有索引<br>问：<code>**update user set a = 1 where c = 2**;</code>这条语句怎么执行？<br>思考：先干什么？后干什么？全表扫描？扫的对象是什么？数据页？索引页？<br>哪个素引？为什么扫这个素引？扫的过程要上锁，上的什么锁？为什么上这个锁？不上行不行？<br>拿到锁后要干什么？更新？怎么更新？更新完后还有什么操作吗？直接结束了？<br>非聚簇索引上修改了字段值会怎样？有了解吗？为什么这样设计？<br>如果此时有其它事务来并发，如何保证事务隔离的？<br><code>select id from user where a = 1 lock in share mode;</code>怎么办？<br>如果第一条sql变成：<code>update user set id = id+1 where a = 1;</code>又如何执行？   </p><h1 id="update-user-set-a-1-where-c-2"><a href="#update-user-set-a-1-where-c-2" class="headerlink" title="update user set a = 1 where c = 2;"></a><code>update user set a = 1 where c = 2;</code></h1><p>先执行<code>update user set a = 1 where c = 2;</code><br>再执行<code>select id from user where a = 1 lock in share mode;</code>  </p><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-10-MySQL/img.png" alt="image.png"></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-10-MySQL/img_1.png" alt="image.png"><br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-10-MySQL/img_2.png" alt="image.png"></p><p>除了默认的主键索引之外，还有建立在a,b字段上的普通索引。每个索引一颗B+树。  </p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p><strong>“</strong><code>**update user set a = 1 where c = 2；**</code><strong>”</strong><br>where子句里的条件能用什么索引优化查询吗？没有，c字段没有与之相关联的索引，这条语句的执行只能在主键索引的B+树中逐行扫描（也就是说，加的锁是组合锁，而不是表锁，并不是全表扫描）,<br>这里参考up的解释：<img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-10-MySQL/img_3.png" alt="image.png"><br>简而言之就是，表锁开销太大了没必要，不如用组合锁。虽然效果上是锁住了全表，但不是表锁。  </p><p>从主键索引B+树中找到对应的行数据后，将a的值设置为1。（索引页节点二分查找，叶子节点遍历查找）<br>结束了吗？<br>没有，还要维护其它索引的B+树。  </p><h2 id="维护索引B-树"><a href="#维护索引B-树" class="headerlink" title="维护索引B+树"></a>维护索引B+树</h2><p>b索引因为只包含主键和b字段，和a字段无关，不用维护。<br>在维护a索引的过程中，根据主键索引查出来的修改之前a字段所有值去在a索引B+树中查询出对应的叶子节点中的数据。<br>然后修改a字段的值就结束了？<br>没有。<br>a索引的B+树是根据a字段的值有序排列节点的。修改了a字段的值，有序性被打破，就要重建有序性。<br>如何重建？<br>先删后插。<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-10-MySQL/img_4.png" alt="image.png"><br>如上图，将涉及到的节点全删了，再把更新后的新节点根据有序性插入到对应的位置上。<br>这样就完成了对索引B+树的维护。  </p><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>假设原来a &#x3D; 1的数据有3行，现在由于update语句，又增加了3行，但是update语句因为维护B+树的原因还没提交。<br>在维护B+树的过程中，如果有新的语句被执行：<br><code>**select id from user where a = 1 lock in share mode;**</code><strong>（“in share mode”使得这条sql成为当前读）</strong><br>会怎么样？查出来3条还是6条？<br>和事务隔离性有关吗？<br>无关。事务隔离性只针对普通的select这样的走MVCC的快照读，顺着版本链读下去。<br><code>lock in share mode</code>、<code>update</code>、<code>delete</code>、<code>select ..... for update</code>等等关键字都是当前读，强制读取最新数据。那么这样的语句在并发环境中就涉及到了锁的问题。<br>维护a索引B+树期间，是先删后插的形式，那么插入就需要意向锁。此时上文的select语句被执行，且走a索引。需要访问被删除和新增的节点。这样的并发情况下，意向锁是怎么被加上的？</p><p>为了便于表述，执行完<code>**update user set a = 1 where c = 2**;</code>并维护a索引B+树的事务称为A，后续并发执行<code>**select id from user where a = 1 lock in share mode;**</code>的事务称为B。<br>A不会上意向锁，锁是B替A加的。  </p><p>插入意向锁的上锁过程很有懒加载的思想。有并发情况才上锁，没有就不加。<br>也就是说，后续并发执行的B事务通过ReadView得知对最新数据做出修改地事务还没提交，于是为A事务加了插入意向锁，锁不是A事务加的！<br>B在替A上锁后，就阻塞等待了，真是个好人我哭死  </p><h1 id="update-user-set-id-id-1-where-a-1"><a href="#update-user-set-id-id-1-where-a-1" class="headerlink" title="update user set id = id+1 where a = 1;"></a><code>update user set id = id+1 where a = 1;</code></h1><p>先执行<code>**update user set id = id + 1 where a = 1;**</code><br>再执行<code>**select id from user where a = 1 lock in share mode;**</code><br>大致情况与前一种情况相同。但是有差异：<br>执行第一条sql时<br>先走a索引查询,显式地锁住a &#x3D; 1 的记录，拿到主键id之后再去主键索引上回表找到主键索引的数据，也是显式地锁住。再根据主键索引里的b字段数据去b索引里回表查询找到对应的主键id，隐式地锁住。总共涉及到了两次回表操作，一个隐式锁，两个显式锁。<br>由于本次的update语句涉及到了修改主键，那么需要维护的B+树就不止a索引的了。三个B+树都要维护。<br>修改后如果不影响有序性，则直接修改即可，但如果影响到了B+树的有序性，就需要先删后插。  </p><h1 id="如何区分显式锁和隐式锁？"><a href="#如何区分显式锁和隐式锁？" class="headerlink" title="如何区分显式锁和隐式锁？"></a>如何区分显式锁和隐式锁？</h1><p>显式锁是由开发者手动控制的锁，需要在代码中显式地指定锁的类型和范围。在MySQL中，显式锁通常是指使用<code>LOCK TABLES</code>语句或者<code>SELECT ... FOR UPDATE</code>语句来加锁，用于实现对数据的精确控制。</p><p>隐式锁是由数据库系统自动管理的锁，不需要开发者手动介入。在MySQL中，隐式锁通常是指数据库系统在执行SQL语句时自动加上的锁，用于保证数据的一致性和事务的原子性。<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-10-MySQL/img_5.png" alt="image.png"></p><h1 id="up的总结"><a href="#up的总结" class="headerlink" title="up的总结"></a>up的总结</h1><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-10-MySQL/img_6.png" alt="image.png"></p><blockquote><p>优雅_0v0. (2024, June 07). 一条SQL带你理清页、索引、锁的关系，95%的人回答不上来！. Retrieved from<a href="https://www.bilibili.com/video/BV1CM4m127Uq?vd_source=6df57b2b8470f0f2c9187d097a219270">一条SQL带你理清页、索引、锁的关系，95%的人回答不上来！_哔哩哔哩_bilibili</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL表空间结构</title>
      <link href="/2024/07/03/2024-07-03-MySQL%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/"/>
      <url>/2024/07/03/2024-07-03-MySQL%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>小林coding那边已经很详细了，这里我只对一些比较重要的点和不太懂的地方做出补充<br>小林coding. (n.d.). MySQL 一行记录是怎么存储的？. Retrieved from <a href="https://xiaolincoding.com/mysql/base/row_format.html#%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">MySQL 一行记录是怎么存储的？</a></p></blockquote><h1 id="表空间结构"><a href="#表空间结构" class="headerlink" title="表空间结构"></a>表空间结构</h1><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-03-MySQL/img.png" alt="image.png"></p><ul><li>行， 自然对应数据表中的每一行数据</li><li>页， 有限行的集合。查询的时候肯定不是一行数据一行数据读取，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。而是读取一批的行数据。存储这一批行数据的结构叫做页</li><li>区， 固然每次可以批量读取页数据，但如果每一页在磁盘不连续，那么就会出现大量随机磁盘IO。为了提升性能，把一批的页顺序存储在一个结构里，叫做区。</li><li>段， 在B+树存储引擎里，分有索引段、数据段和回滚段三部分。索引段用于存储非叶子节点，数据段存储叶子节点。区在叶子节点中通过双向链表连接。而回滚段就和MVCC有关了，为事务隔离性提供了支持</li></ul><h1 id="行结构"><a href="#行结构" class="headerlink" title="行结构"></a>行结构</h1><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。<br>这里只介绍Compact行格式。<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-03-MySQL/img_1.png" alt="COMPACT.drawio.jpg"></p><h2 id="null值列表"><a href="#null值列表" class="headerlink" title="null值列表"></a>null值列表</h2><p><strong>null值列表都是以16进制数表示的</strong><br>null值列表转换为二进制后<strong>每一位代表对应的列</strong>（逆序对应，如下图）<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-03-MySQL/img_2.png" alt="image.png"></p><h2 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h2><p><strong>变长字段（varchar）长度列表和null值列表都是以16进制数表示的</strong><br>但是与null列表不同，这里展开为二进制没有任何意义，因为保存的是某个varchar字段占据的字节数大小。其中每个16进制数据倒序对应于每个varchar字段,参考上图</p><h2 id="具体结构示意图"><a href="#具体结构示意图" class="headerlink" title="具体结构示意图"></a>具体结构示意图</h2><p>假设有表数据如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> COMPACT;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-03-MySQL/img_3.png" alt="image.png"><br>选取有代表性的第二条记录：</p><ul><li>name 列的值为 bb，真实数据占用的字节数是2字节，<strong>十六进制 0x02</strong>；</li><li>phone 列的值为 1234，真实数据占用的字节数是 4 字节，<strong>十六进制 0x04</strong>；</li><li>age 列和 id 列不是变长字段，所以这里不用管。</li></ul><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-03-MySQL/img_4.png" alt="image.png"><br><strong>由于逆序对应,</strong><br>变长字段长度列表中，04代表phone字段在这一行占据了4个字节，02代表name字段在这一行占据了2个字节。<br>null值列表中，16进制0X04展开为二进制是100，第三位的1代表对应的最后一个字段age是null，第二位的0代表对应的phone字段不为null；第一位的0代表对应的name字段不为null。<br>注意，NULL 值并不会存储在行格式中的真实数据部分。也就是说第二行的真实数据部分只有列一和列二，列三不存在。</p><h2 id="每个数据库表的行格式都有「NULL-值列表」吗？"><a href="#每个数据库表的行格式都有「NULL-值列表」吗？" class="headerlink" title="每个数据库表的行格式都有「NULL 值列表」吗？"></a>每个数据库表的行格式都有「NULL 值列表」吗？</h2><p>NULL 值列表也不是必须的。<br><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。<br>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（ 因为不满8位会补0凑齐所以NULL 值列表至少占用 1 字节空间,）。</p><h2 id="为什么是逆序存放？"><a href="#为什么是逆序存放？" class="headerlink" title="为什么是逆序存放？"></a>为什么是逆序存放？</h2><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-03-MySQL/img_5.png" alt="image.png"></p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-03-MySQL/img_9.png" alt="img.png"><br>如上图，逆序存放可以让<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。<br>如橙色的name列可以和它对应的记录“0”靠的更近</p><h1 id="行数据溢出"><a href="#行数据溢出" class="headerlink" title="行数据溢出"></a>行数据溢出</h1><p>页的大小默认是16KB，<code>16384字节</code>。如果像varchar、 TEXT、BLOB这样不定长度的字段 非常大，导致一页都存不下一行数据，那么就会发生行溢出的情况<br>这是本页只会存储这一行的一部分数据，剩下的放在另一页里，两页通过指针连接<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-03-MySQL/img_8.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RDB&amp;AOF</title>
      <link href="/2024/07/02/2024-07-02-AOF&amp;RDB/"/>
      <url>/2024/07/02/2024-07-02-AOF&amp;RDB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>小林coding那边已经很详细了，这里我只对一些比较重要的点和不太懂的地方做出补充<br><a href="https://xiaolincoding.com/redis/">小林Coding&#x2F;Redis</a>  </p></blockquote><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>AOF是将kv以命令的形式保存在缓存区。缓存区的数据会被追加到AOF文件中，每秒一次</p><h2 id="三种刷盘策略"><a href="#三种刷盘策略" class="headerlink" title="三种刷盘策略"></a>三种刷盘策略</h2><p>每次新增kv时，先执行写命令，再把kv保存到AOF缓存区,比起先保存到缓存区再执行写命令，这样做的好处是如果命令执行不成功，就不需要去修改缓冲区或者磁盘的AOF文件了。<br>那么缓存区的数据何时被刷盘呢？</p><ol><li>每次执行写命令后就刷盘，这样做性能不好</li><li>不去管刷盘，把刷盘的时机交给操作系统决定。这样做会丢失不定量的数据</li><li>每隔一秒或者一个固定的时间，刷盘。相比于前两种，这是折中的方案。</li></ol><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-02-AOF&RDB/img_2.png"></p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>随着程序的运行，总有一些kv被反复修改过。那么这条kv每次被修改的命令都会被保存，但只有最后的命令才有效。所以缓解AOF文件体积庞大的着手点就是每条kv只保存最后的命令。<br>完整过程：</p><ol><li><p><strong>创建一个新的空的AOF文件</strong></p><blockquote><p>为什么不复用现有的AOF文件？重写失败了那这个文件就被污染了</p></blockquote></li><li><p><strong>主进程fork出一个子进程，子进程通过复制父进程的页表可以共享父进程的内存，节约内存。</strong></p><blockquote><p>为什么不是创建一个线程？线程之间共享的内存，所有线程都有写权限。势必会引发并发问题,需要加锁解决。而父子进程之间共享内存，两进程都只有读权限，执行写命令的话会触发写时复制</p></blockquote></li><li><p><strong>读取redis的所有kv,将每条kv以命令的形式保存在新的AOF文件中。</strong></p><blockquote><p>如果在此期间，主进程对共享内存执行了写操作，那么被该写操作影响的内存会被复制一份，写操作的内存对象变成了复制后的内存。原来的内存供其他进程接着使用。</p></blockquote></li><li><p><strong>主进程把AOF持久化期间执行的写命令保存在缓存区。</strong></p></li><li><p><strong>新的AOF文件接着读取主进程缓存区的数据写入。完成后覆盖原有AOF文件。AOF重写过程结束。</strong></p></li></ol><blockquote><p><strong>什么是写时复制？</strong><br>写时复制是一种优化策略，主要用于操作系统和编程语言中，以减少不必要的数据复制，从而提高效率和节省内存。其工作原理如下：</p><ul><li>当多个进程或线程需要访问相同的资源（如内存页或文件）时，它们共享同一份资源。</li><li>只有当其中一个进程或线程尝试修改资源时，系统才会为这个特定的进程或线程创建资源的一份副本，并且只修改副本，而原始资源保持不变，供其他进程或线程继续共享。</li><li>这种机制可以显著减少内存的使用，尤其是在处理大量相同数据的场景下，比如在虚拟化环境中或在多进程共享大量相同代码和数据的应用中。</li></ul><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-02-AOF&RDB/img_1.png"></p></blockquote><p>另外，写时复制的时候会出现这么个极端的情况。</p><blockquote><p>在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。<br>那么极端情况下，<strong>如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍</strong>。<br>所以，针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。</p></blockquote><h2 id="AOF存在的问题（原文）"><a href="#AOF存在的问题（原文）" class="headerlink" title="AOF存在的问题（原文）"></a>AOF存在的问题（<a href="https://mp.weixin.qq.com/s/v9yvJo7mKb5Hffw8Dw7gDQ">原文</a>）</h2><h3 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h3><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-02-AOF&RDB/img_3.png" alt="AOF 示例图"></p><p>从 AOF 示例图可以看到，在AOF重写期间，主进程会将fork之后的数据变化写进aof_rewrite_buf中，aof_rewrite_buf和aof_buf中的内容绝大部分都是重复的，因此这将带来额外的内存冗余开销。  </p><p>从Redis INFO中的aof_rewrite_buffer_length字段可以看到当前时刻aof_rewrite_buf占用的内存大小。如下面显示的，在高写入流量下aof_rewrite_buffer_length几乎和aof_buffer_length占用了同样大的内存空间，几乎浪费了一倍的内存。</p><p><code>aof_pending_rewrite:0aof_buffer_length:35500aof_rewrite_buffer_length:34000aof_pending_bio_fsync:0</code><br>当aof_rewrite_buf占用的内存大小超过一定阈值时，我们将在Redis日志中看到如下信息。可以看到，aof_rewrite_buf占用了100MB的内存空间且主进程和子进程之间传输了2135MB的数据（子进程在通过pipe读取这些数据时也会有内部读buffer的内存开销）。</p><blockquote><p>3351:M 25 Jan 2022 09:55:39.655 * Background append only file rewriting started by pid 68173351:M 25 Jan 2022 09:57:51.864 * AOF rewrite child asks to stop sending diffs.6817:C 25 Jan 2022 09:57:51.864 * Parent agreed to stop sending diffs. Finalizing AOF…6817:C 25 Jan 2022 09:57:51.864 * Concatenating 2135.60 MB of AOF diff received from parent.3351:M 25 Jan 2022 09:57:56.545 * Background AOF buffer size: 100 MB</p></blockquote><p>对于内存型数据库Redis而言，这是一笔不小的开销。<br>AOFRW带来的内存开销有可能导致Redis内存突然达到maxmemory限制，从而影响正常命令的写入，<br>甚至会触发操作系统限制被OOM Killer杀死，导致Redis不可服务。</p><h3 id="磁盘-IO-增加"><a href="#磁盘-IO-增加" class="headerlink" title="磁盘 IO 增加"></a>磁盘 IO 增加</h3><p>如前文所述，在AOFRW期间，主进程除了会将执行过的写命令写到aof_buf之外，还会写一份到aof_rewrite_buf中。aof_buf中的数据最终会被写入到当前使用的旧AOF文件中，产生磁盘IO。同时，aof_rewrite_buf中的数据也会被写入重写生成的新AOF文件中，产生磁盘IO。因此，同一份数据会产生两次磁盘IO。</p><h3 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h3><p>在Redis 7.0 (已发布RC1) 中Multi Part AOF（下文简称为MP-AOF，本特性由阿里云数据库Tair团队贡献）已对上述问题作出了改进<br>具体策略见<a href="https://mp.weixin.qq.com/s/v9yvJo7mKb5Hffw8Dw7gDQ">原文</a></p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>对于一条kv，AOF记录它的方式是记录创建它的命令。而RDB则是记录这条kv本身。<br>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p><ul><li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会<strong>阻塞主线程</strong>；</li><li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li></ul><p>RDB快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。这是一个非常“重”的操作。对redis服务器有一些性能上的影响。因此RDB的刷盘不能像AOF那样频繁（AOF将缓存区的数据追加到AOF文件中，每秒一次）。<br>因此通常RDB每隔几分钟才会执行一次，一旦服务器宕机，RDB比AOF丢失的数据更多。</p><h2 id="子进程与写时复制"><a href="#子进程与写时复制" class="headerlink" title="子进程与写时复制"></a>子进程与写时复制</h2><p>参考上文AOF部分对子进程与写时复制的介绍。<br>在执行RDB复制时，由于子进程和写时复制的原因，redis服务器依然能够对外提供服务。执行RDB快照的子进程是对复制过后的内存操作的，不影响父进程。</p><p>但是fork子进程的过程会短暂的阻塞父进程。因为需要复制父进程的页表给子进程。</p><h2 id="RDB子进程复制与写时复制的缺陷"><a href="#RDB子进程复制与写时复制的缺陷" class="headerlink" title="RDB子进程复制与写时复制的缺陷"></a>RDB子进程复制与写时复制的缺陷</h2><p>在保存数据期间主进程写入的数据会以写时复制的形式保存在内存里。不会被本次的RDB给持久化。<br>如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会<strong>丢失主线程在快照期间修改的数据</strong>。</p><h3 id="为什么AOF不会有这个问题？"><a href="#为什么AOF不会有这个问题？" class="headerlink" title="为什么AOF不会有这个问题？"></a>为什么AOF不会有这个问题？</h3><p>因为持久化期间主进程执行的写命令被置入了缓冲区。子进程也会读取这个缓冲区的数据。</p><h3 id="为什么RDB不仿照AOF解决这个问题"><a href="#为什么RDB不仿照AOF解决这个问题" class="headerlink" title="为什么RDB不仿照AOF解决这个问题?"></a>为什么RDB不仿照AOF解决这个问题?</h3><p>不是解决不了，而是这样做不符合RDB的设计理念。<br>RDB的目的是保存某一时间点的所有数据的快照。关键在于，某个时间点。发生在这个时间点后的数据不归RDB管。</p><h1 id="RDB与AOF的对比与混合使用"><a href="#RDB与AOF的对比与混合使用" class="headerlink" title="RDB与AOF的对比与混合使用"></a>RDB与AOF的对比与混合使用</h1><h2 id="RDB优点："><a href="#RDB优点：" class="headerlink" title="RDB优点："></a>RDB优点：</h2><p>由于RDB保存的kv数据本身，恢复数据就会比AOF快不少（AOF要把所有命令执行一遍）。</p><h2 id="AOF优点："><a href="#AOF优点：" class="headerlink" title="AOF优点："></a>AOF优点：</h2><p>AOF由于秒级刷盘的策略，服务器宕机丢失的数据比RDB少得多。在Always刷盘策略下，甚至不会丢失数据。</p><p>能不能集两者优点与一身呢？</p><h2 id="RDB与AOF合体使用"><a href="#RDB与AOF合体使用" class="headerlink" title="RDB与AOF合体使用"></a>RDB与AOF合体使用</h2><p>redis.conf文件中有一条设置：<br><code>aof-use-rdb-preamble yes</code><br>开启后，会以混合持久化的形式保证数据持久化。<strong>这样就使得持久化期间的新增的数据也会被持久化。</strong><br>当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。<br>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-02-AOF&RDB/img.png"><br>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。<br>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从复制</title>
      <link href="/2024/07/01/2024-07-01-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2024/07/01/2024-07-01-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>小林coding那边已经很详细了，这里我只对一些比较重要的点和不太懂的地方做出补充<br><a href="https://xiaolincoding.com/redis/">小林Coding&#x2F;Redis</a>  </p></blockquote><h1 id="分摊主服务器的压力"><a href="#分摊主服务器的压力" class="headerlink" title="分摊主服务器的压力"></a>分摊主服务器的压力</h1><p>在主服务器和从服务器同步数据期间，如果从服务器数量非常多，那么传输RDB文件会大大占据主服务器的网络带宽，影响服务。所以从服务器不必是主服务器的从服务器，也可以是从服务器的从服务器，如下图：<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-01-Redis/img.png" alt="image.png"><br>主服务器只把RDB文件传给少量的从服务器，这些从服务器再把RDB文件传给其他的从服务器。这样就大大减少了数据同步对主服务器的影响。</p><h1 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h1><p>如果从服务器网络阻塞，导致数据没有被及时同步。又该如何保持主从之间数据的一致性呢？<br>重新传输一遍全量的RDB文件吗？太低效了。</p><p><strong>Redis是这样做的：</strong><br>从服务器网络正常后发送增量复制的信号给主服务器，主服务器把从服务器断线期间的写命令发给从服务器。<br>问题在于，<strong>主服务器怎么知道哪些写命令发生在这个从服务器断线期间的</strong>？</p><p>redis服务器有一个叫repl_backlog_buffer的缓冲区。所有的写命令都会被记录在这个缓冲区里。并维护一个偏移量用于标记当前最新的写命令的偏移量。<br>从服务器重连后把自己的偏移量发给主服务器。主服务器就可以根据双方的偏移量知道哪些数据要增量复制给从服务器。<br>问题又来了，<strong>缓冲区不可能一直存着数据吧？时间久了溢出怎么办？</strong><br>其实这个缓冲区默认只有1M大小。当缓冲区写满后，主服务器继续写入的话，就会覆盖之前的数据<br>那么在网络恢复时，如果从服务器想读的数据已经被覆盖了，主服务器就会采用全量同步，这个方式比增量同步的性能损耗要大很多。<br>为了尽可能得避免全量复制，应该把这个缓冲区设置地大一点。<br>具体大小可以根据这个式子得到：<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-07-01-Redis/img_1.png" alt="image.png"></p><ul><li>second 为从服务器断线后重新连接上主服务器所需的平均 时间(以秒计算)。</li><li>write_size_per_second 则是主服务器平均每秒产生的写命令数据量大小。</li></ul><p>举个例子，如果主服务器平均每秒产生 1 MB 的写命令，而从服务器断线之后平均要 5 秒才能重新连接主服务器。<br>那么 repl_backlog_buffer 大小就不能低于 5 MB，否则新写地命令就会覆盖旧数据了。<br>当然，为了应对一些突发的情况，可以将 repl_backlog_buffer 的大小设置为此基础上的 2 倍，也就是 10 MB。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幻读与不可重复读的区别</title>
      <link href="/2024/05/13/2024-05-13-%E5%B9%BB%E8%AF%BB%E4%B8%8E%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/05/13/2024-05-13-%E5%B9%BB%E8%AF%BB%E4%B8%8E%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不可重复读是由其他事务的更新操作造成的，而幻读则是由本事务的更新操作造成的  </p></blockquote><p>不可重复读指的是：某事务第一次读取变量A的值为1，其它事务将其更新为2。后这个某事务读到了其它事务对A更新后的值2。前后读取的这个变量的值不相同。  </p><p>而幻读指的是：某事务第一次读取变量A&#x3D;1的行数据 <strong>条数</strong> 是五条，之后再次读取变量A&#x3D;1的行数据 <strong>条数</strong> ，发现变成了六条。前后数据条数不一致</p><p>列举一个幻读场景：<br>事务X第一次读取一批量的行数据1，2，3，4，5，共有五条数据。之后事务Y新增一行数据6。后事务X对6这行数据update了，<br>再去读这一批数据的值，发现读到的是1，2, 3 , 4 , 5, 6，共有六条数据。多了个一条数据，和第一次的结果不相同  </p><p>2024.05.16update:以上文中幻读的场景举例，某事务在快照读的情况下，确实查不到新增的数据，但是，update语句是不管什么readview快照的，它是当前读。update语句一定读取的是最新的数据。如果某事务对第六行数据做了update操作（这时，某事务根据readview是查不到这行数据的，但是可以对它update。这很违和，但确实存在），update结束之后，第六行数据对应的事务id就变成了某事务本身。后续再根据readview查数据，就可以把第六行数据查出来了。<br><strong>所以，可重复读级别下没有完全解决幻读问题。</strong><br><br></p><p><strong>如何在可重复读级别下，尽可能的解决幻读呢？（以下情况默认Innodb引擎）</strong><br>那就是在创建事务之后，立刻执行 select … for update 这类当前读的语句，因为它会对记录加临键锁（组合锁），从而避免其他事务插入一条新记录。<br>而普通的select语句是通过MVCC读的，不涉及到锁。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表成环问题</title>
      <link href="/2024/05/02/2024-05-02-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%88%90%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/02/2024-05-02-%E5%93%88%E5%B8%8C%E8%A1%A8%E6%88%90%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<br><p>默认此情况仅发生在1.7版本下并发对哈希表扩容的情况下</p><p>第一步：线程启动，有线程T1和线程T2都准备对HashMap进行扩容操作， 此时T1和T2指向的都是链表的头节点A，而T1和T2的下一个节点分别是T1.next和T2.next，它们都指向B节点。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-05-05-Hash/v2-7c4590d100e68c47384fd7f1358c0a08_1440w.jpeg"></p><p>第二步：开始扩容，这时候，假设线程T2的时间片用完，进入了休眠状态，而线程T1开始执行扩容操作，一直到线程T1扩容完成后，线程T2才被唤醒。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-05-05-Hash/v2-8b6feb5274fcc8bc61409484e5cc81cd_1440w.jpeg"><br />T1完成扩容之后的场景就变成动画所示的这样。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-05-05-Hash/v2-d915684c6f7ff0b3f65474a1d7ca2550_1440w.jpeg"></p><p>因为HashMap扩容采用的是头插法，线程T1执行之后，链表中的节点顺序发生了改变。但线程T2对于发生的一切还是不可知的，所以它指向的节点引用依然没变。如图所示，T2指向的是A节点，T2.next指向的是B节点。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-05-05-Hash/img.png"></p><p>当线程T1执行完成之后，线程T2恢复执行时，死循环就发生了。</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-05-05-Hash/v2-757f3c71752b15b59a956f6f5b131822_1440w.jpeg"><br />因为T1执行完扩容之后，B节点的下一个节点是A，而T2线程指向的首节点是A，第二个节点是B，这个顺序刚好和T1扩容之前的节点顺序是相反的。T1执行完之后的顺序是B到A，而T2的顺序是A到B，这样A节点和B节点就形成了死循环。</p><p>简而言之，扩容使得链表的方向发生了反转。而T2线程由于处于阻塞状态对这一切都不知情。T2持有的节点的引用还是A，A的next还是B。但是B的next由于扩容的原因反过来指向了A。死循环就发生了。</p><p>TODO 成环之后呢？T2节点执行扩容会发生什么？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap &amp; HashMap</title>
      <link href="/2024/04/28/2024-04-28-TreeMap&amp;HashMap/"/>
      <url>/2024/04/28/2024-04-28-TreeMap&amp;HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="内部实现："><a href="#内部实现：" class="headerlink" title="内部实现："></a><strong>内部实现</strong>：</h1><ul><li>HashMap 使用哈希表（基于数组和链表&#x2F;红黑树的组合）实现，通过计算键的哈希值来快速访问值。</li><li>TreeMap 使用红黑树实现，这使得它能够保持键的自然排序或自定义排序。</li></ul><h1 id="排序特性："><a href="#排序特性：" class="headerlink" title="排序特性："></a><strong>排序特性</strong>：</h1><ul><li>HashMap 不保证任何特定的顺序，键值对的存储和检索顺序可能随时间变化。</li><li>TreeMap 则保持了键的排序，要么按照键的升序（Comparable），要么按照自定义比较器（Comparator）排序，这使得你可以有序地遍历键值对。</li></ul><h1 id="性能："><a href="#性能：" class="headerlink" title="性能："></a>性能：</h1><ul><li>在平均情况下，HashMap 的插入、删除和查找操作的性能较好，接近 O(1)。</li><li>TreeMap 的插入、删除和查找操作的性能略逊，为 O(log n)，但由于有序性，在某些场景下可能更适合。</li></ul><h1 id="线程安全性："><a href="#线程安全性：" class="headerlink" title="线程安全性："></a><strong>线程安全性</strong>：</h1><ul><li>它们两者都是非线程安全的。但是hashMap有线程安全的版本，treeMap没有<blockquote><p><strong>面试可能会问：如何把treeMap修改为线程安全的？</strong><br>最好的方法是使用替代品，比如ConcurrentSkipListMap。他与treemap一样实现了排序功能，不过是基于跳表实现的。ConcurrentSkipListMap保持了元素的有序性，并允许高并发的插入、删除和访问操作，非常适合那些需要线程安全且按键排序的场景。</p><p>其次：</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">boolean</span> replaceOld)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        addEntryToEmptyMap(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> t.value;</span><br><span class="line">                <span class="keyword">if</span> (replaceOld || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                    t.value = value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Objects.requireNonNull(key);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">        <span class="comment">//这里通过do-while循环判断有没有树上的节点的key与新节点的key重复</span></span><br><span class="line">        <span class="comment">//如果有就替换value，return</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> t.value;</span><br><span class="line">                <span class="keyword">if</span> (replaceOld || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                    t.value = value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    addEntry(key, value, parent, cmp &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(K key, V value, Entry&lt;K, V&gt; parent, <span class="type">boolean</span> addToLeft)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (addToLeft)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以给52行new出来的节点上锁，这样就线程安全了</p></blockquote><h1 id="为什么HashMap线程不安全？"><a href="#为什么HashMap线程不安全？" class="headerlink" title="为什么HashMap线程不安全？"></a>为什么HashMap线程不安全？</h1><ul><li><p>数据丢失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br></pre></td></tr></table></figure><p>通过上面Java7中的源码分析一下为什么会出现数据丢失，如果有两条线程同时执行到这条语句 table[i]&#x3D;null,时两个线程都会区创建Entry,这样存入会出现数据丢失。</p></li><li><p>数据重复</p></li><li><p>扩容时发生死循环（头插法造成，Java8已修复）</p></li></ul><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-04-28-TreeMap/v2-114b7455a189ab16390d60491b5c47b2_720w.jpeg"></p><p>如果有两个线程同时发现自己都key不存在，而这两个线程的key实际是相同的，在向链表中写入的时候第一线程将e设置为了自己的Entry,而第二个线程执行到了e.next，此时拿到的是最后一个节点，依然会将自己持有是数据插入到链表中，这样就出现了数据 重复。 通过商品put源码可以发现，是先将数据写入到map中，再根据元素到个数再决定是否做resize.在resize过程中还会出现一个更为诡异都问题死循环。 这个原因主要是因为hashMap在resize过程中对链表进行了一次倒序处理。假设两个线程同时进行resize, A-&gt;B 第一线程在处理过程中比较慢，第二个线程已经完成了倒序，变成了B-A 那么就出现了循环，B-&gt;A-&gt;B.这样就出现了就会出现CPU使用率飙升。 在下午突然收到其中一台机器CPU利用率不足告警，将jstack内容分析发现，可能出现了死循环和数据丢失情况，当然对于链表的操作同样存在问题。<br> PS:在这个过程中可以发现，之所以出现死循环，主要还是在于对于链表对倒序处理，在Java 8中，已经不在使用倒序列表，死循环问题得到了极大改善。 </p><blockquote><p><a href="https://www.zhihu.com/question/28516433/answer/281307231">hashmap的线程不安全体现在哪里？ - 知乎</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized底层</title>
      <link href="/2024/04/05/2024-04-05-synchronized%E5%BA%95%E5%B1%82/"/>
      <url>/2024/04/05/2024-04-05-synchronized%E5%BA%95%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<br><p>synchronized可以修饰方法、静态方法、代码块。修饰方法和静态方法时，方法的字节码文件中会多一个标识：ACC_SYNCHRONIZED。<br>当调用设置了 ACC_SYNCHRONIZED 的方法时，执行线程进入监视器（monitor），然后执行这个方法，方法执行完毕后退出监视器。需要注意的是，无论这个方法是正常完成还是突然完成，在执行线程拥有监视器期间，没有其他线程可以进入这个方法。</p><h2 id="关于monitor"><a href="#关于monitor" class="headerlink" title="关于monitor"></a>关于monitor</h2><p>上文我们总是把 monitor 翻译为监视器，其实各位如果系统地学习过操作系统，对 monitor 一定不陌生，它也被翻译为管程。常见的进程同步与互斥机制就是信号量和管程，相比起信号量，管程有一个重要特性：在一个时刻只能有一个进程使用管程，即进程在无法继续执行的时候不能一直占用管程，否则其它进程将永远不能使用管程。也就是说管程天生支持进程互斥。<br>其实使用管程是能够实现信号量的，并且也能用信号量实现管程。但是管程封装的比较好，相比起信号量来需要我们编写的代码更少，更加易用。<br>把管程翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。<br>而对象和monitor是一一对应的</p><h2 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h2><p>执行 monitorenter 的线程会尝试获得监视器的所有权，或者说尝试获得对象的锁（反过来说就是不加 synchronized 的对象是不会被锁住的）。<br>另外，每个监视器都维护着一个自己被持有次数的计数器，具体如下：<br>如果与对象关联的监视器的计数器为零，则线程进入监视器成为该监视器的拥有者，并将计数器设置为 1。<br>当同一个线程再次进入该对象的监视器的时候，计数器会再次自增(这也说明了synchronized是可重入锁)。<br>当其他线程想获得该对象关联的监视器的时候，就会被阻塞住，直到该监视器的计数器为 0 才会再次尝试获得其所有权</p><h2 id="关于monitorexit"><a href="#关于monitorexit" class="headerlink" title="关于monitorexit"></a>关于monitorexit</h2><p>某个线程想要执行 monitorexit 指令，那它一定得是某个监视器的拥有者才行。<br>当某个线程执行 monitorexit 指令的时候，该线程拥有的监视器的计数器就会减一。如果计数器为 0，就表明该线程不再拥有监视器了，这样，其他线程就可以去尝试获得这个监视器了。</p><p>当synchronized修饰代码块时，代码块所处的那个方法的字节码中会多出两个指令 monitorenter 和 monitorexit，也就是说在同步方法块中，JVM 使用 monitorenter 和 monitorexit 这两个指令实现同步。</p><h2 id="锁是如何升级的呢？"><a href="#锁是如何升级的呢？" class="headerlink" title="锁是如何升级的呢？"></a>锁是如何升级的呢？</h2><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-04-05-synchonized/img.png"></p><p>锁标志位 “01” + 是否是偏向锁 “0” 表示无锁状态，也就是说该对象没有被锁定<br>锁标志位 “01” + 是否是偏向锁 “1” 表示偏向锁状态</p><h3 id="轻量级锁加锁的过程是这样的："><a href="#轻量级锁加锁的过程是这样的：" class="headerlink" title="轻量级锁加锁的过程是这样的："></a>轻量级锁加锁的过程是这样的：</h3><ol><li>Mark Word 的初始状态：在代码即将进入同步块的时候，如果此同步对象没有被锁定，也即 Mark Word 中的锁标志位 “01” + 是否是偏向锁 “0”：</li></ol><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-04-05-synchonized/img_1.png"></p><ol start="2"><li>在当前线程的栈帧中建立一个锁记录：Java 虚拟机会在将在当前线程的栈帧中建立一个名为 锁记录（Lock Record） 的空间，Lock Record 中有一个字段 displaced_header，用于后续存储锁对象的 Mark Word 的拷贝：</li></ol><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-04-05-synchonized/img_2.png"></p><ol start="3"><li>复制锁对象的 Mark Word 到锁记录中：把锁对象的 Mark Word 复制到锁记录中，更具体来讲，是将 Mark Word 放到锁记录的 displaced_header 属性中。官方给这个复制过来的记录起名 Displaced Mark Word：</li></ol><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-04-05-synchonized/img_3.png"></p><ol start="4"><li>使用 CAS 操作更新锁对象的 Mark Word。Java 虚拟机使用 CAS 操作尝试把锁对象的 Mark Word 更新为指向锁记录的指针，并将锁记录里的 owner 指针指向对象的 Mark Word。如果这个更新操作成功了，就表明获取轻量级锁成功，也就是说该线程拥有了这个对象的锁！并且该对象 Mark Word 的锁标志位会被改为 00，即表示此对象处于轻量级锁定状态。如果这个更新操作失败了，那有两种可能性：<ol><li>当前线程已经拥有了这个对象锁（直接进入同步块继续执行）</li><li>存在其他的线程竞争获取这个对象锁（膨胀成重量级锁，锁标志的状态值变为 10，Mark Word 中存储的就是指向重量级锁（互斥量）的指针</li></ol></li></ol><p>为了证实到底是哪种情况，虚拟机首先会检查该对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行（synchronized 是可重入锁）。</p><p>假设锁的状态是轻量级锁，下图反应了对象的 Mark word 和线程栈中锁记录的状态，可以看到左边线程栈中包含3个指向当前锁对象的 Lock Record。其中栈中最高位的锁记录为第一次获取轻量级锁时分配的，其 Displaced Mark word 的值为锁对象 obj 加锁之前的 Mark word，之后的每次锁重入都会在线程栈中分配一个 Displaced Mark word 为 null 的锁记录。<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-04-05-synchonized/img_4.png"><br>那么问题来了，为什么 synchronized 重入的时候 Java 虚拟机要在线程栈中添加 Displaced Mark word 为 null 的锁记录呢？<br>首先锁重入次数是一定要记录下来的，因为每次解锁都需要对应一次加锁，只有解锁次数等于加锁次数时，该锁才真正的被释放，也就是在解锁时需要用到说锁的重入次数。<br>最简单的记录锁重入次数的方案就是将其记录在对象头的 Mark word 中，但 Mark word 大小有限，没有多出来的地方存放该信息了。另一个方案就是在锁纪录中记录重入次数，但这样做的话，每次重入获得锁的时候都需要遍历该线程的栈找到对应的锁纪录，然后去修改重入次数的值，显然这样效率不是很高。<br>所以最终 Hotspot 选择了每次重入获得锁都添加一个锁记录来表示锁的重入，这样有几个 Displaced Mark word 为 null 的锁记录就表示发生了几次锁重入，非常简单。<br>以上，就是 synchronized 锁重入的原理。</p><p>再来看 CAS 更新操作失败的第二种情况，如果这个更新操作失败了并且该对象的 Mark Word 并没有指向当前线程的栈帧，就说明多个线程竞争锁。注意！！！这里就是我说的《Java 并发编程的艺术》书中出现错误的地方，我们来看原文</p><blockquote><p>线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，<u>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</u></p></blockquote><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-04-05-synchonized/img_5.png"><br>看上方划线的句子，话不多说，我们接着上面那段源码往下看：<br>可以看到并没有什么自旋操作，如果 CAS 成功就直接 return 了，如果失败就会执行下面的锁膨胀方法 ObjectSynchronizer::inflate，这里面同样也没有自旋操作。<br><strong>注意，从这段源码可以看到，锁的升级是用C++方法实现的</strong><br>所以从源码来看轻量级锁 CAS 失败（存在其他的线程竞争获取这个对象锁的情况）并不会自旋而是直接膨胀成重量级锁。</p><h2 id="关于对象头"><a href="#关于对象头" class="headerlink" title="关于对象头"></a>关于对象头</h2><p>我们上述讲到的所有底层原理，其实都在这句话的基础之上：Each object is associated with a monitor<br>那么，一个对象和一个 monitor 是如何关联起来的呢？<br>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。<br>其中，如果对象是数组类型，则虚拟机用 3 个字宽（Word）存储对象头（Mard Word、类型指针、数组长度），如果对象是非数组类型，则用 2 字宽存储对象头（Mard Word、类型指针）。在 32 位虚拟机中，1 字宽等于 4 字节，即 32 bit，如表所示：<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-04-05-synchonized/img_6.png"><br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-04-05-synchonized/img_7.png" alt="img.png"><br>Mark Word 就是对象与 monitor 关联的重点所在！ 《深入理解 Java 虚拟机 - 第 3 版》中是这样描述 Mark Word 的：</p><blockquote><p>HotSpot 虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32 个比特和 64 个比特，官方称它为 “Mark Word”。<br>对象需要存储的运行时数据很多，其实已经超出了 32、64 位 Bitmap 结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p></blockquote><blockquote><p>参考：<a href="https://leetcode.cn/leetbook/read/concurrency/aty716/">力扣</a></p></blockquote><p>TODO  JDK21有对对象头的瘦身</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装箱类</title>
      <link href="/2024/03/24/2024-03-24-%E8%A3%85%E7%AE%B1%E7%B1%BB%E4%B8%8Esynchronized/"/>
      <url>/2024/03/24/2024-03-24-%E8%A3%85%E7%AE%B1%E7%B1%BB%E4%B8%8Esynchronized/</url>
      
        <content type="html"><![CDATA[<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.Solution.Algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Third</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建两个线程并启动</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">unsafeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (i)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">unsafeThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (i)&#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        unsafeThread.start();</span><br><span class="line">        unsafeThread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待两个线程运行结束</span></span><br><span class="line">        unsafeThread.join();</span><br><span class="line">        unsafeThread1.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终的结果</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Unsafe i: &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当循环次数在127以内时，每次执行完毕i一定是0，这是由synchronized保证的。<br />但是循环次数大于127呢？<br /><br>i是一个Integer对象。在Java中，自动装箱的Integer对象在作为同步锁时，由于其值可能在内存中不唯一（因为Integer缓存了-128到127之间的值，超出这个范围的值才会每次创建新的对象），<br>可能导致意料之外的同步行为。</p><p>附上两个运行结果：</p><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-03-24-Integer&synchronized/img.png" alt="img.png"><br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-03-24-Integer&synchronized/img_1.png" alt="img_1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java里两种执行命令的方式比较</title>
      <link href="/2024/03/09/2024-03-09-ProcessBuilder&amp;Runtime.getRuntime().exec()/"/>
      <url>/2024/03/09/2024-03-09-ProcessBuilder&amp;Runtime.getRuntime().exec()/</url>
      
        <content type="html"><![CDATA[<br><blockquote><p>我的网盘程序部署在服务器上，前端资源通过nginx托管。但不知为何，nginx总是每隔几天就被kill了。所以我在后台程序内部搞了一个定时任务<br><br>每隔一段时间重启nginx。执行重启命令使用了Runtime.exec方法。但后来在实习过程中发现公司的项目里执行命令行命令使用了ProcessBuilder。<br><br>于是我研究（GPT）了一下两者的区别，并写下这篇笔记。</p></blockquote><p>Runtime.getRuntime().exec(cmd); 和使用 ProcessBuilder 来创建并启动进程之间有几个主要的区别：</p><ol><li><p>参数处理</p><ol><li>Runtime.exec(String cmd) 方法接受一个单一的字符串参数，这个字符串应该是一个完整的命令行，包括所有的参数和必要的分隔符（在Windows上是空格，在Unix&#x2F;Linux上通常是空格和引号）。这意味着你必须自己处理所有参数的拼接和转义，这可能会导致一些难以察觉的错误和安全问题（如命令注入攻击）。</li><li>ProcessBuilder 允许你以更结构化的方式设置命令和参数。你可以将命令和每个参数作为单独的字符串传递给 ProcessBuilder 的构造函数或 command 方法。ProcessBuilder 会自动处理这些参数，使得代码更清晰、更安全。</li></ol></li><li><p>错误流处理：</p><ol><li>使用 Runtime.exec 时，默认情况下标准输出流（stdout）和标准错误流（stderr）是分开的。你需要单独处理这两个流，否则可能会丢失错误信息或导致程序挂起。</li><li>ProcessBuilder 允许你通过 redirectErrorStream(true) 方法将 stderr 重定向到 stdout，从而简化输出处理。</li></ol></li><li><p>环境变量和工作目录：</p><ol><li>ProcessBuilder 提供了更多的配置选项，如设置环境变量（通过 environment() 方法）和工作目录（通过 directory() 方法）。而 Runtime.exec 提供的配置选项较少。</li></ol></li><li><p>线程安全性：</p><ol><li>ProcessBuilder 是线程安全的，而 Runtime.exec 不是。如果你在多线程环境中使用 Runtime.exec，需要格外小心以避免潜在的问题。</li></ol></li><li><p>资源管理：</p><ol><li>ProcessBuilder 返回的 Process 对象提供了更多关于子进程状态的信息，比如是否活着（通过 isAlive() 方法）以及等待进程结束并获取退出值（通过 waitFor() 方法）。 </li><li>使用 Runtime.exec 时，你也需要手动管理子进程的输入&#x2F;输出流，并确保它们在使用后被正确关闭，以避免资源泄漏。</li></ol></li><li><p>异常处理：</p><ol><li>ProcessBuilder 的 start() 方法不会抛出 IOException，但是返回的 Process 对象的 waitFor() 方法会抛出。这使得错误处理更加明确。</li><li>Runtime.exec 直接抛出 IOException，这可能需要更多的异常处理代码。</li></ol></li></ol><p>总的来说，ProcessBuilder 提供了更灵活、更安全、更易于管理的进程创建和配置选项。因此，在现代Java编程中，通常推荐使用 ProcessBuilder 而不是 Runtime.exec 来创建和启动进程。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="/2024/02/16/2024-02-16-volatile/"/>
      <url>/2024/02/16/2024-02-16-volatile/</url>
      
        <content type="html"><![CDATA[<br><p><a name="UnhI0"></a></p><h1 id="第一个作用：保证可见性"><a href="#第一个作用：保证可见性" class="headerlink" title="第一个作用：保证可见性"></a>第一个作用：保证可见性</h1><p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主内存中，当其他线程读取此变量时，会去主内存中读取新值。这样就保证了多个线程之间的可见性</p><p>** 假如B线程时刻X去主存里读volatile修饰的变量的值，A线程在时刻Y修改了该变量的值，在时刻Z将修改后的值写回主存。现在时刻X在时刻Y和Z的中间，该变量被修改的时间点早于B读取它的时间，但B却没有读取到。那么可见性保证了吗？  **<br /><strong>这种情况不存在，总线机制保证B一定能读取到修改后的值。</strong><br /><strong>具体见下文解释：</strong><br />上文提到了：“当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主内存中，当其他线程读取此变量时，会去主内存中读取新值”，实际上是这样的：<br />线程的CPU会一直在总线BUS上嗅探其内部缓存中的内存地址在其他处理器的操作情况，一旦嗅探到某处处理器打算修改其内存地址中的值，而该内存地址刚好也在自己的内部缓存中，那么处理器就会强制让自己对该缓存地址的无效。所以当该处理器要访问该数据的时候，由于发现自己缓存的数据无效了，就会去主存中访问。<br />这里涉及到了缓存一致性协议。<br />也就是说，只要修改的时间点发生在读取之前，即使还没来得及写回主存，其它线程的CPU也会让自己的cache中的该变量无效，让读操作一定去主存读。<br />事实上，完整的 MESI 协议更复杂，但我们没必要记得这么细。我们只需要记住最关键的 2 点：</p><ul><li>关键 1 - 阻止同时有多个核心修改的共享数据： <strong>当一个 CPU 核心要求修改数据时，会先广播 RFO 请求获得 Cache 块的所有权，并将其它 CPU 核心中对应的 Cache 块置为已失效状态</strong>；</li><li>关键 2 - 延迟回写： 只有在需要的时候才将数据写回内存，当一个 CPU 核心要求访问已失效状态的 Cache 块时，会先要求其它核心先将数据写回内存，再从内存读取。</li></ul><p>关键1中的”当一个 CPU 核心要求修改数据时，会先广播 RFO 请求获得 Cache 块的所有权，并将其它 CPU 核心中对应的 Cache 块置为已失效状态“就是解决上文”该变量被修改的时间点早于B读取它的时间，但B却没有读取到“这种情况的。保证B一定能读到。</p><blockquote><p>如果有多个CPU同时对volatile变量做写操作。如何保证顺序？或者说，如何保证串行化？<br>由总线仲裁系统保证。<br>总线的独占性要求同一时刻最多只有一个主模块占用总线，天然地会将所有核心对内存的读写操作串行化。如果多个核心同时发起总线事务，此时总线仲裁单元会对竞争做出仲裁，未获胜的事务只能等待获胜的事务处理完成后才能执行。’</p><p>参考来源：<a href="https://cloud.tencent.com/developer/article/2197853">https://cloud.tencent.com/developer/article/2197853</a></p></blockquote><p>:::info<br>关于happens-before原则：<br />实现了该原则的编译器承诺： 在满足一些条件后：</p><ol><li>如果一个操作在另一个操作之前发生（happens - before），那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。即使第一个操作的结果产生时间晚于第二个操作的开始时间。</li><li>两个操作之间存在 Happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 Happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 Happens-before 关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM 允许这种重排序）</li></ol><p>happens-before原则的条件有下面这些：</p><ol><li><strong>程序顺序规则</strong>：一个线程内的操作按代码顺序发生。</li><li><strong>管程锁定规则</strong>：解锁操作发生在随后的同一个锁的加锁操作之前。</li><li><strong>volatile变量规则</strong>：对volatile字段的写操作发生在随后的读操作之前。</li><li><strong>线程启动规则</strong>：线程的start()方法调用发生在该线程的任何操作之前。</li><li><strong>线程终止规则</strong>：线程的所有操作都发生在线程的终止之前。</li><li><strong>对象终结规则</strong>：对象的finalize()方法调用发生在该对象的垃圾回收之前。</li><li><strong>线程中断规则</strong>：Thread.interrupted()方法检测到中断状态的发生，发生在实际的中断操作之前</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li></ol><p>只要你的代码满足了这八条规则中的任何一条，或者通过规则间的传递性和组合可以满足，那么编译器就一定能实现happens-before。<br />在任何一条都不满足的情况下，happens-before原则不会生效。<br><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-02-16-volatile/img.png" alt="image.png"><br /> <strong>为什么线程启动、终止、中断规则和对象终结规则也和这里完全没有关系？</strong><br />因为这些规则与线程的生命周期有关。示例中的代码片段并没有涉及到线程的启动、终止或中断，因此这些规则也不适用。<br>:::</p><p><a name="t4ehk"></a></p><h1 id="第二个作用：禁止指令重排"><a href="#第二个作用：禁止指令重排" class="headerlink" title="第二个作用：禁止指令重排"></a>第二个作用：禁止指令重排</h1><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-02-16-volatile/image_1.png" alt="image.png"><br />假如某个变量的读写涉及到了2条指令，那么由于指令重排序的原因，第一条指令和第二条指令中间可能穿插了多条其它线程的指令，导致读写速度变慢。加上volatile修饰去禁止指令重排序后，会提高该线程的运行效率。<br />指令重排序保证结果不受影响，但不保证这原本的多条指令集合是顺序执行的。<br><a name="DYoyN"></a></p><h1 id="双重校验锁DCL："><a href="#双重校验锁DCL：" class="headerlink" title="双重校验锁DCL："></a>双重校验锁DCL：</h1><p>关于 volatile 最出名的应用就是单例模式的 <strong>双重校验锁（Double Checked Locking，DCL）</strong> 写法了。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"><span class="comment">// 私有化构造方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">SingleTon</span><span class="params">()</span>&#123;&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingleTon</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 第一次校验，减少锁的竞争  </span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; </span><br><span class="line">                <span class="keyword">synchronized</span> (SingleTon.class) &#123;</span><br><span class="line">                       <span class="comment">// 第二次校验</span></span><br><span class="line">                        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;     </span><br><span class="line">                            instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来解释下这两重校验分别作了什么：<br><a name="aJ33Z"></a></p><h2 id="第一重校验："><a href="#第一重校验：" class="headerlink" title="第一重校验："></a>第一重校验：</h2><p>由于单例模式只需要创建一次实例，所以如果多次调用 getInstance 方法的话，应该直接返回第一次创建的实例。因此其实大部分时间都是不需要去执行同步方法里面的代码的，减少了锁的竞争。这样，第一重校验大大提高了性能。<br><a name="piQea"></a></p><h2 id="第二重校验："><a href="#第二重校验：" class="headerlink" title="第二重校验："></a>第二重校验：</h2><p>我们先假设没有第二重校验。<br />假设线程 t1 执行了第一重校验后，判断为 instance &#x3D;&#x3D; null；<br />就在这个时候，发生上下文切换，另一个线程 t2 获得了 CPU 调度，并且也执行了第一重校验，也判断 instance &#x3D;&#x3D; null，随后 t2 获得锁，创建实例；<br />然后，发生上下文切换，t1 又重新获得 CPU 调度，由于之前已经进行了第一重校验，结果为 true（不会再次判断），所以 t1 也会去获得锁并创建实例。这样就会导致创建多个实例。<br />所以需要在同步块里面进行第二重校验，如果实例为空，才进行创建。</p><p>再来解释下为什么 instance 一定要用 volatile 这个关键字来修饰。</p><p>这里就是 volatile 第二项特性 - 禁止指令重排的应用。在 Java 语言层面上，创建对象仅仅是一个 new 关键字而已，而在 JVM 中，对象的创建其实并不是一蹴而就的，忽略掉一些 JVM 底层的细节比如设置对象头啥的，对象的创建可以大致分三个步骤：</p><ol><li>在堆中为对象分配内存空间</li><li>调用构造函数，初始化实例</li><li>将栈中的对象引用指向刚分配的内存空间</li><li><br /></li></ol><p>那么由于 JVM 指令重排优化的存在，有可能第二步和第三步发生交换：</p><ol><li>在堆中为对象分配内存空间</li><li>将栈中的对象引用指向刚分配的内存空间（<strong>线程可能在这个时刻获取了未初始化的instance</strong>）</li><li>调用构造函数，初始化实例</li></ol><p>现在考虑重排序后，两个线程发生了以下调用：<br /><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-02-16-volatile/image.png" alt="image.png"><br />在这种情况下，线程 T2 访问到的就是一个未完成初始化的对象，是个半成品，会报空指针异常的错误。<br />所以说，instance 一定要用 volatile 这个关键字来修饰，从而禁止指令重排。</p><blockquote><p>作者：飞天小牛肉<br />链接：<a href="https://leetcode.cn/leetbook/read/concurrency/a8hxqg/">https://leetcode.cn/leetbook/read/concurrency/a8hxqg/</a><br />来源：力扣（LeetCode）<br />著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程和操作系统线程的区别</title>
      <link href="/2024/02/13/2024-02-13-Java%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/02/13/2024-02-13-Java%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>在 JDK 1.2 及以后，JVM 选择了更加稳定且方便使用的操作系统原生的内核级线程，通过系统调用，将线程的调度交给了操作系统内核。而操作系统内核线程和Java线程有一对一、一对多、多对多这几种模型。具体与操作系统有关。</p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h3><p>多个用户级线程对应到某一个内核线程上</p><h3 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h3><p>一个用户级线程对应一个内核态线程</p><h3 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h3><p>任意数量的用户线程复用到相同或更少数量的内核线程上，结合了一对一和多对一模型的最佳特性</p><p><strong>现今 Java 中线程的本质，其实就是操作系统中的线程</strong>，其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现（一对一，多对一），比如在 Windows 中 Java 就是基于 Win32 线程库来管理线程，且 Windows 采用的是一对一的线程模型。</p><h2 id="关于线程库"><a href="#关于线程库" class="headerlink" title="关于线程库"></a>关于线程库</h2><p>线程库就是为开发人员提供创建和管理线程的一套 API。<br>当然，线程库不仅可以在用户空间中实现，还可以在内核空间中实现。前者涉及仅在用户空间内实现的 API 函数，没有内核支持。后者涉及系统调用，也就是说调用库中的一个 API 函数将会导致对内核的系统调用，并且需要具有线程库支持的内核。</p><p>三个主要的线程库：<br>1）POSIX Pthreads：可以作为用户或内核库提供，作为 POSIX 标准的扩展<br>2）Win32 线程：用于 Window 操作系统的内核级线程库<br>3）Java 线程：Java 线程 API 通常采用宿主系统的线程库来实现，也就是说在 Win 系统上，Java 线程 API 通常采用 Win API 来实现，在 UNIX 类系统上，采用 Pthread 来实现。</p><blockquote><p><a href="https://leetcode.cn/leetbook/read/concurrency/atqmpr/">力扣</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024-01-31-由一道力扣题引发的对Java中HashMap的思考</title>
      <link href="/2024/01/31/2024-01-31-%E7%94%B1%E4%B8%80%E9%81%93%E5%8A%9B%E6%89%A3%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9Java%E4%B8%ADHashMap%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2024/01/31/2024-01-31-%E7%94%B1%E4%B8%80%E9%81%93%E5%8A%9B%E6%89%A3%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9Java%E4%B8%ADHashMap%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<br><p>哈希表插入是在尾节点插入，因为需要遍历哈希桶内所有链表节点判断重复</p><p>哈希表的底层是由数组、链表和红黑树实现的，数组作为哈希桶。<br />桶内的结点个数小于8链表实现，大于等于8红黑树实现<br />Java中所有类都继承了Object类，该类中有一个hashCode方法，是C++实现的native方法，将key的内存地址转化为32位int数a，再对a右移16位得到b，将a与b异或得到c作为key的哈希值。得到的哈希值对哈希桶长度 - 1做&amp;操作，结果就是key要被放入的桶的索引。如果这个结果超过了哈希桶长度，那么就会生成一个新的哈希桶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本方法在Objects.java文件内</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 判断插入的是否是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 不是红黑树节点则说明为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xyhaooo/picrepo/raw/master/articleSource/2024-01-31-HashMap/img.png"><br /><br>可以看到，在执行putVal方法之前，会调用native方法hashCode得到哈希值，由于这个方法会让每一个不同的对象都得到不同的哈希值，如果我们希望两个内存地址不同但相同内容的数组的哈希值也相等，就必须重写hashCode方法，使得相同内容的数组的哈希值也相等。<br />Java为许多常用的数据类型重写了hashCode()方法,使它们只要内容相同哈希值就也相同，比如String，Integer，Double等。比如在Integer类中哈希值就是其int类型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Returns a hash code based on the contents of the specified array. </span></span><br><span class="line"><span class="comment">For any two non-null int arrays a and b such that Arrays.equals(a, b), </span></span><br><span class="line"><span class="comment">it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : a)</span><br><span class="line">        result = <span class="number">31</span> * result + element;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常重写hashCode方法后还需要重写equals方法。这是因为对象通过调用 Object.hashCode（）生成哈希值，由于不可避免地会存在哈希值冲突的情况 因此hashCode 相同时 还需要再调用 equals 进行一次值的比较，但是若hashCode不同，将直接判定两个对象不同，跳过 equals ，这加快了冲突处理效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line"><span class="comment">//来源于Map.put()方法的底层实现代码的一部分</span></span><br></pre></td></tr></table></figure><p>第三行代码中，由于重写了hashCode方法，导致内容相同的数组具有相同的哈希值，于是判断p中的键是否等于传来的数组（比较地址）肯定是不等于的，于是执行key.equals方法。<br />因此，重写hashCode方法导致不同地址的对象具有了相同的哈希值后，为了让某些方法的底层实现将它们作为完全相同的对象，需要重写equals方法。</p><p>Object 类定义中对 hashCode和 equals 要求如下:</p><ul><li><strong>如果两个对象的equals的结果是相等的，则两个对象的 hashCode 的返回结果也必须是相同的。</strong></li><li><strong>任何时候重写equals，都必须同时重写hashCode</strong>。</li></ul><p>相关链接<br /><a href="https://zhuanlan.zhihu.com/p/354863363">源码解读HashMap底层结构与实现原理之一–put、get方法大起底</a><br /><a href="https://blog.csdn.net/yb546822612/category_10021000.html">底层原理_森森之火的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>软件工程专业2025届本科毕业生，Java服务端开发方向</br>工作经历：</br>2025年6月-至今 拼多多-Java开发</br><br>| 足球 ｜ LOL ｜ 程序员 | 吉他手 | <strong>非二次元</strong> ｜<br>有问题请联系：<a href="mailto:&#120;&#x79;&#x68;&#97;&#111;&#x5f;&#111;&#64;&#x66;&#x6f;&#x78;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;">&#120;&#x79;&#x68;&#97;&#111;&#x5f;&#111;&#64;&#x66;&#x6f;&#x78;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;</a></p><h1 id="关于本站"><a href="#关于本站" class="headerlink" title="关于本站"></a>关于本站</h1><p>是由github pages + hexo + github actions组成的博客<br>GitHub Pages：静态网站托管服务<br>Hexo：一个快速、简单、高效的博客框架<br>GitHub Actions：持续集成和持续交付（CI&#x2F;CD）平台<br>网站首页：Juzi-xyhao.github.io&#x2F;</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>archives</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/modify.css"/>
      <url>/css/modify.css</url>
      
        <content type="html"><![CDATA[#page-header,#page-header:before {  background: transparent !important;}#page-header.post-bg,#page-header.not-home-page {  height: 280px !important;}#page-header #post-info {  bottom: 40px !important;}#page-header #page-site-info {  top: 140px !important;}@media screen and (max-width: 768px) {  #page-header.not-home-page {    height: 200px !important;  }  #page-header #post-info {    bottom: 10px !important;  }  #page-header #page-site-info {    top: 100px !important;  }}.top-img {  height: 250px;  margin: -50px -40px 50px;  border-top-left-radius: inherit;  border-top-right-radius: inherit;  background-position: center center;  background-size: cover;  -webkit-transition: all 0.3s;  -moz-transition: all 0.3s;  -o-transition: all 0.3s;  -ms-transition: all 0.3s;  transition: all 0.3s;}@media screen and (max-width: 768px) {  .top-img {    height: 230px;    margin: -36px -14px 36px;  }}[data-theme='dark'] .top-img {  filter: brightness(0.8);}#footer:before {  background-color: transparent;}[data-theme='dark'] #footer:before {  background-color: transparent;}#footer-wrap,#footer-wrap a {  color: #fff;  -webkit-transition: unset;  -moz-transition: unset;  -o-transition: unset;  -ms-transition: unset;  transition: unset;}[data-theme='dark'] #footer-wrap,[data-theme='dark'] #footer-wrap a {  color: var(--light-grey);}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/mycss.css"/>
      <url>/css/mycss.css</url>
      
        <content type="html"><![CDATA[/* 修改字体 ------------------------------------------------------- *//*@font-face {*//*    font-family: 'tzy';*//*    !* 字体名自定义即可 *!*//*    src: url("https://cdn.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/font/ZhuZiAWan.woff2");*//*    !* 字体文件路径 *!*//*    font-display: swap;*//*}*/p {    /*font-family: 'tzy', sans-serif;*/    font-size: 16px;}font {    /*font-family: 'tzy', sans-serif;*/    font-size: 16px;}/*导航栏居中*/#nav .menus_items {    position: absolute;    width: fit-content;    left: 50%;    transform: translateX(-50%);}/*子菜单横向居中*/#nav .menus_items .menus_item:hover .menus_item_child{    display: flex;}/* 去除导航栏选项中底下的蓝条 */#nav *::after{    background-color: transparent!important;}/* 导航栏菜单鼠标移入字体放大 */#nav #site-name:hover,#nav .menus_item:hover,#nav #search-button:hover{    font-size:28px;}#footer {    position: relative;    background-attachment: scroll;    background-position: bottom;    background-size: cover;    background-color: transparent; /* 或者使用rgba值如上所述 */}body,.gitcalendar {    /*font-family: tzy !important;*/    font-size: 16px;}/* 局部优化 ------------------------------------------------------- */.categoryBar-list {    max-height: 400px;}.clock-row {    overflow: hidden;    text-overflow: ellipsis;}/*3s为加载动画的时间，1为加载动画的次数，ease-in-out为动画效果*/#page-header,#web_bg {    -webkit-animation: imgblur 2s 1 ease-in-out;    animation: imgblur 2s 1 ease-in-out;}/*适配使用-webkit内核的浏览器 */@-webkit-keyframes imgblur {    0% {        -webkit-filter: blur(5px);    }    100% {        -webkit-filter: blur(0px);    }}.table-wrap img {    margin: 0.6rem auto 0.1rem !important;}/* 标签外挂 网站卡片 start */.site-card-group img {    margin: 0 auto 0.1rem !important;}.site-card-group .info a img {    margin-right: 10px !important;}[data-theme='dark'] .site-card-group .site-card .info .title {    color: #f0f0f0 !important;}[data-theme='dark'] .site-card-group .site-card .info .desc {    color: rgba(255,255,255,0.7) !important;}.site-card-group .info .desc {    margin-top: 4px !important;}/* 代码块颜色 */figure.highlight pre .addition {    color: #00bf03 !important;}@-moz-keyframes imgblur {    0% {        filter: blur(5px);    }    100% {        filter: blur(0px);    }}@-webkit-keyframes imgblur {    0% {        filter: blur(5px);    }    100% {        filter: blur(0px);    }}@-o-keyframes imgblur {    0% {        filter: blur(5px);    }    100% {        filter: blur(0px);    }}@keyframes imgblur {    0% {        filter: blur(5px);    }    100% {        filter: blur(0px);    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/transpancy.css"/>
      <url>/css/transpancy.css</url>
      
        <content type="html"><![CDATA[/* 文章页背景 */.layout_post>#post {    /* 以下代表透明度为0.7 可以自行修改*/    background: rgba(255,255,255,.9);}/* 所有页面背景 */#aside_content .card-widget, #recent-posts>.recent-post-item, .layout_page>div:first-child:not(.recent-posts), .layout_post>#page, .layout_post>#post, .read-mode .layout_post>#post{    /* 以下代表透明度为0.7 */    background: rgba(255,255,255,.9);}/*侧边卡片的透明度 */:root {    --card-bg: rgba(255, 255, 255, .9);}/* 页脚透明 */#footer {    /* 以下代表透明度为0.7 */    background: rgba(255,255,255, .0);}p {    /*font-family: 'tzy', sans-serif;*/    font-size: 16px;}font {    /*font-family: 'tzy', sans-serif;*/    font-size: 16px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/scripts/modify.js"/>
      <url>/scripts/modify.js</url>
      
        <content type="html"><![CDATA['use strict';const cheerio = require('cheerio');/** * 在页面插入新顶部图 * @param {cheerio.Root} $ Root */function insertTopImg($) {    let header = $('#page-header');    if (header.length === 0) return;    let background = header.css('background-image');    if (!background) return;    $('#post, #page, #archive, #tag, #category').prepend(`<div class="top-img" style="background-image: ${background};"></div>`);}hexo.extend.filter.register('after_render:html', function(str, data) {    let $ = cheerio.load(str, {        decodeEntities: false    });    insertTopImg($);    return $.html();});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
